   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 3A00      		.string	":"
  13               	.LC1:
  14 0002 2564 00   		.string	"%d"
  15               		.text
  16               	.global	int_to_uart
  18               	int_to_uart:
  19               	.LFB11:
  20               		.file 1 "main.c"
   1:main.c        **** #include <avr/interrupt.h>
   2:main.c        **** #include <avr/eeprom.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <stdlib.h>
   5:main.c        **** #include <avr/pgmspace.h>
   6:main.c        **** #include <ctype.h>
   7:main.c        **** #include <stdint.h>
   8:main.c        **** #include <avr/wdt.h>
   9:main.c        **** #include <math.h>
  10:main.c        **** 
  11:main.c        **** #include "io.h"
  12:main.c        **** #include "disp.h"
  13:main.c        **** #include "usart.h"
  14:main.c        **** //#include "temp_18b20.h"
  15:main.c        **** 
  16:main.c        **** #define F_CPU 8000000UL  // Частота MHz
  17:main.c        **** 
  18:main.c        **** #include "vars.h"
  19:main.c        **** #include "subs.h"
  20:main.c        **** 
  21:main.c        **** //----------------------------------------------
  22:main.c        **** 
  23:main.c        **** void int_to_uart(char *id, int16_t num)
  24:main.c        **** {
  21               		.loc 1 24 0
  22               		.cfi_startproc
  23               	.LVL0:
  24 0000 0F93      		push r16
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 16, -2
  28 0002 1F93      		push r17
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 17, -3
  32 0004 CF93      		push r28
  33               	.LCFI2:
  34               		.cfi_def_cfa_offset 5
  35               		.cfi_offset 28, -4
  36 0006 DF93      		push r29
  37               	.LCFI3:
  38               		.cfi_def_cfa_offset 6
  39               		.cfi_offset 29, -5
  40 0008 CDB7      		in r28,__SP_L__
  41 000a DEB7      		in r29,__SP_H__
  42               	.LCFI4:
  43               		.cfi_def_cfa_register 28
  44 000c 2A97      		sbiw r28,10
  45               	.LCFI5:
  46               		.cfi_def_cfa_offset 16
  47 000e 0FB6      		in __tmp_reg__,__SREG__
  48 0010 F894      		cli
  49 0012 DEBF      		out __SP_H__,r29
  50 0014 0FBE      		out __SREG__,__tmp_reg__
  51 0016 CDBF      		out __SP_L__,r28
  52               	/* prologue: function */
  53               	/* frame size = 10 */
  54               	/* stack size = 14 */
  55               	.L__stack_usage = 14
  56 0018 162F      		mov r17,r22
  57 001a 072F      		mov r16,r23
  25:main.c        **** //    struct m2bytes nbuf;
  26:main.c        ****     //USART_PutChar('\x0d');
  27:main.c        ****     USART_SendStr(id);
  58               		.loc 1 27 0
  59 001c 0E94 0000 		call USART_SendStr
  60               	.LVL1:
  28:main.c        ****     USART_SendStr(":");
  61               		.loc 1 28 0
  62 0020 80E0      		ldi r24,lo8(.LC0)
  63 0022 90E0      		ldi r25,hi8(.LC0)
  64 0024 0E94 0000 		call USART_SendStr
  65               	.LVL2:
  29:main.c        ****     /*    nbuf.one = num;
  30:main.c        ****      num_to_str(&nbuf);
  31:main.c        ****      USART_PutChar(nbuf.one);
  32:main.c        ****      USART_PutChar(nbuf.two);
  33:main.c        ****      */
  34:main.c        ****     char buf[10];
  35:main.c        ****     snprintf(buf, sizeof(buf), "%d", num);
  66               		.loc 1 35 0
  67 0028 0F93      		push r16
  68 002a 1F93      		push r17
  69 002c 80E0      		ldi r24,lo8(.LC1)
  70 002e 90E0      		ldi r25,hi8(.LC1)
  71 0030 9F93      		push r25
  72 0032 8F93      		push r24
  73 0034 1F92      		push __zero_reg__
  74 0036 8AE0      		ldi r24,lo8(10)
  75 0038 8F93      		push r24
  76 003a 8E01      		movw r16,r28
  77 003c 0F5F      		subi r16,-1
  78 003e 1F4F      		sbci r17,-1
  79 0040 1F93      		push r17
  80 0042 0F93      		push r16
  81 0044 0E94 0000 		call snprintf
  82               	.LVL3:
  36:main.c        ****     USART_SendStr(buf);
  83               		.loc 1 36 0
  84 0048 C801      		movw r24,r16
  85 004a 0E94 0000 		call USART_SendStr
  86               	.LVL4:
  37:main.c        ****     USART_PutChar(';');
  87               		.loc 1 37 0
  88 004e 8BE3      		ldi r24,lo8(59)
  89 0050 0E94 0000 		call USART_PutChar
  90               	.LVL5:
  38:main.c        **** //    buf[cnt];
  39:main.c        **** }
  91               		.loc 1 39 0
  92 0054 0FB6      		in __tmp_reg__,__SREG__
  93 0056 F894      		cli
  94 0058 DEBF      		out __SP_H__,r29
  95 005a 0FBE      		out __SREG__,__tmp_reg__
  96 005c CDBF      		out __SP_L__,r28
  97               	/* epilogue start */
  98 005e 2A96      		adiw r28,10
  99 0060 0FB6      		in __tmp_reg__,__SREG__
 100 0062 F894      		cli
 101 0064 DEBF      		out __SP_H__,r29
 102 0066 0FBE      		out __SREG__,__tmp_reg__
 103 0068 CDBF      		out __SP_L__,r28
 104 006a DF91      		pop r29
 105 006c CF91      		pop r28
 106 006e 1F91      		pop r17
 107 0070 0F91      		pop r16
 108 0072 0895      		ret
 109               		.cfi_endproc
 110               	.LFE11:
 112               	.global	__fixsfsi
 113               	.global	float_to_uart
 115               	float_to_uart:
 116               	.LFB12:
  40:main.c        **** 
  41:main.c        **** void float_to_uart(char *id, float num)
  42:main.c        **** {
 117               		.loc 1 42 0
 118               		.cfi_startproc
 119               	.LVL6:
 120 0074 CF93      		push r28
 121               	.LCFI6:
 122               		.cfi_def_cfa_offset 3
 123               		.cfi_offset 28, -2
 124 0076 DF93      		push r29
 125               	.LCFI7:
 126               		.cfi_def_cfa_offset 4
 127               		.cfi_offset 29, -3
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 2 */
 131               	.L__stack_usage = 2
 132 0078 EC01      		movw r28,r24
  43:main.c        ****     int_to_uart(id, num);
 133               		.loc 1 43 0
 134 007a CB01      		movw r24,r22
 135 007c BA01      		movw r22,r20
 136 007e 0E94 0000 		call __fixsfsi
 137               	.LVL7:
 138 0082 CE01      		movw r24,r28
 139               	/* epilogue start */
  44:main.c        ****     /*    USART_SendStr(id);
  45:main.c        ****      USART_SendStr(":");
  46:main.c        ****      int8_t buf[10];
  47:main.c        ****      int8_t cnt = snprintf(buf, sizeof(buf), "%g", num);
  48:main.c        ****      USART_SendStr(buf);
  49:main.c        ****      USART_Putint8_t(';');
  50:main.c        ****      */
  51:main.c        **** }
 140               		.loc 1 51 0
 141 0084 DF91      		pop r29
 142 0086 CF91      		pop r28
 143               	.LVL8:
  43:main.c        ****     int_to_uart(id, num);
 144               		.loc 1 43 0
 145 0088 0C94 0000 		jmp int_to_uart
 146               	.LVL9:
 147               		.cfi_endproc
 148               	.LFE12:
 150               	.global	uart_nl
 152               	uart_nl:
 153               	.LFB13:
  52:main.c        **** 
  53:main.c        **** void uart_nl(void)
  54:main.c        **** {
 154               		.loc 1 54 0
 155               		.cfi_startproc
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 0 */
 159               	.L__stack_usage = 0
  55:main.c        ****     USART_PutChar('\x0d');
 160               		.loc 1 55 0
 161 008c 8DE0      		ldi r24,lo8(13)
 162 008e 0E94 0000 		call USART_PutChar
 163               	.LVL10:
  56:main.c        ****     USART_PutChar('\n');
 164               		.loc 1 56 0
 165 0092 8AE0      		ldi r24,lo8(10)
 166 0094 0C94 0000 		jmp USART_PutChar
 167               	.LVL11:
 168               		.cfi_endproc
 169               	.LFE13:
 171               	.global	__vector_13
 173               	__vector_13:
 174               	.LFB14:
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** //-------------------- Timer on 0.5 sec -----------------------
  60:main.c        **** 
  61:main.c        **** ISR (TIMER1_OVF_vect)
  62:main.c        **** {
 175               		.loc 1 62 0
 176               		.cfi_startproc
 177 0098 1F92      		push r1
 178               	.LCFI8:
 179               		.cfi_def_cfa_offset 3
 180               		.cfi_offset 1, -2
 181 009a 0F92      		push r0
 182               	.LCFI9:
 183               		.cfi_def_cfa_offset 4
 184               		.cfi_offset 0, -3
 185 009c 0FB6      		in r0,__SREG__
 186 009e 0F92      		push r0
 187 00a0 1124      		clr __zero_reg__
 188 00a2 8F93      		push r24
 189               	.LCFI10:
 190               		.cfi_def_cfa_offset 5
 191               		.cfi_offset 24, -4
 192 00a4 9F93      		push r25
 193               	.LCFI11:
 194               		.cfi_def_cfa_offset 6
 195               		.cfi_offset 25, -5
 196               	/* prologue: Signal */
 197               	/* frame size = 0 */
 198               	/* stack size = 5 */
 199               	.L__stack_usage = 5
  63:main.c        ****     cli();
 200               		.loc 1 63 0
 201               	/* #APP */
 202               	 ;  63 "main.c" 1
 203 00a6 F894      		cli
 204               	 ;  0 "" 2
  64:main.c        ****     TCNT1 = 0x10000 - (F_CPU / 256);
 205               		.loc 1 64 0
 206               	/* #NOAPP */
 207 00a8 8EEE      		ldi r24,lo8(-18)
 208 00aa 95E8      		ldi r25,lo8(-123)
 209 00ac 9093 8500 		sts 132+1,r25
 210 00b0 8093 8400 		sts 132,r24
  65:main.c        **** 
  66:main.c        ****     SET_FLAG(f_e1sec);
 211               		.loc 1 66 0
 212 00b4 8091 0000 		lds r24,flags
 213 00b8 8160      		ori r24,lo8(1)
 214 00ba 8093 0000 		sts flags,r24
  67:main.c        **** 
  68:main.c        **** //    SET_BIT(time_flag, tf_dps_en);
  69:main.c        ****     sei();
 215               		.loc 1 69 0
 216               	/* #APP */
 217               	 ;  69 "main.c" 1
 218 00be 7894      		sei
 219               	 ;  0 "" 2
 220               	/* epilogue start */
  70:main.c        **** }
 221               		.loc 1 70 0
 222               	/* #NOAPP */
 223 00c0 9F91      		pop r25
 224 00c2 8F91      		pop r24
 225 00c4 0F90      		pop r0
 226 00c6 0FBE      		out __SREG__,r0
 227 00c8 0F90      		pop r0
 228 00ca 1F90      		pop r1
 229 00cc 1895      		reti
 230               		.cfi_endproc
 231               	.LFE14:
 233               	.global	test_vent_enc
 235               	test_vent_enc:
 236               	.LFB15:
  71:main.c        **** 
  72:main.c        **** //********************** Vent Enc INT**********************
  73:main.c        **** void test_vent_enc(int8_t up)
  74:main.c        **** {
 237               		.loc 1 74 0
 238               		.cfi_startproc
 239               	.LVL12:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
  75:main.c        ****     if (get_input(IN_BTN_V_UP) == get_input(IN_BTN_V_DWN)) {
 244               		.loc 1 75 0
 245 00ce 99B1      		in r25,0x9
 246 00d0 23B1      		in r18,0x3
 247 00d2 9095      		com r25
 248 00d4 991F      		rol r25
 249 00d6 9927      		clr r25
 250 00d8 991F      		rol r25
 251 00da 2170      		andi r18,lo8(1)
 252 00dc 9217      		cp r25,r18
 253 00de 01F0      		breq .L5
  76:main.c        **** 	if (up) {
 254               		.loc 1 76 0
 255 00e0 8823      		tst r24
 256 00e2 01F0      		breq .L7
 257               	.LVL13:
 258               	.LBB64:
 259               	.LBB65:
  77:main.c        **** 	    vent_enc++;
 260               		.loc 1 77 0
 261 00e4 8091 0000 		lds r24,vent_enc
 262               	.LVL14:
 263 00e8 8F5F      		subi r24,lo8(-(1))
 264 00ea 00C0      		rjmp .L8
 265               	.LVL15:
 266               	.L7:
 267               	.LBE65:
 268               	.LBE64:
  78:main.c        **** 	} else {
  79:main.c        **** 	    vent_enc--;
 269               		.loc 1 79 0
 270 00ec 8091 0000 		lds r24,vent_enc
 271               	.LVL16:
 272 00f0 8150      		subi r24,lo8(-(-1))
 273               	.L8:
 274 00f2 8093 0000 		sts vent_enc,r24
 275               	.L5:
 276 00f6 0895      		ret
 277               		.cfi_endproc
 278               	.LFE15:
 280               	.global	__vector_3
 282               	__vector_3:
 283               	.LFB16:
  80:main.c        **** 	}
  81:main.c        ****     }
  82:main.c        **** }
  83:main.c        **** 
  84:main.c        **** ISR (PCINT0_vect) // IN_BTN_V_DWN Vent
  85:main.c        **** {
 284               		.loc 1 85 0
 285               		.cfi_startproc
 286 00f8 1F92      		push r1
 287               	.LCFI12:
 288               		.cfi_def_cfa_offset 3
 289               		.cfi_offset 1, -2
 290 00fa 0F92      		push r0
 291               	.LCFI13:
 292               		.cfi_def_cfa_offset 4
 293               		.cfi_offset 0, -3
 294 00fc 0FB6      		in r0,__SREG__
 295 00fe 0F92      		push r0
 296 0100 1124      		clr __zero_reg__
 297 0102 2F93      		push r18
 298               	.LCFI14:
 299               		.cfi_def_cfa_offset 5
 300               		.cfi_offset 18, -4
 301 0104 3F93      		push r19
 302               	.LCFI15:
 303               		.cfi_def_cfa_offset 6
 304               		.cfi_offset 19, -5
 305 0106 4F93      		push r20
 306               	.LCFI16:
 307               		.cfi_def_cfa_offset 7
 308               		.cfi_offset 20, -6
 309 0108 5F93      		push r21
 310               	.LCFI17:
 311               		.cfi_def_cfa_offset 8
 312               		.cfi_offset 21, -7
 313 010a 6F93      		push r22
 314               	.LCFI18:
 315               		.cfi_def_cfa_offset 9
 316               		.cfi_offset 22, -8
 317 010c 7F93      		push r23
 318               	.LCFI19:
 319               		.cfi_def_cfa_offset 10
 320               		.cfi_offset 23, -9
 321 010e 8F93      		push r24
 322               	.LCFI20:
 323               		.cfi_def_cfa_offset 11
 324               		.cfi_offset 24, -10
 325 0110 9F93      		push r25
 326               	.LCFI21:
 327               		.cfi_def_cfa_offset 12
 328               		.cfi_offset 25, -11
 329 0112 AF93      		push r26
 330               	.LCFI22:
 331               		.cfi_def_cfa_offset 13
 332               		.cfi_offset 26, -12
 333 0114 BF93      		push r27
 334               	.LCFI23:
 335               		.cfi_def_cfa_offset 14
 336               		.cfi_offset 27, -13
 337 0116 EF93      		push r30
 338               	.LCFI24:
 339               		.cfi_def_cfa_offset 15
 340               		.cfi_offset 30, -14
 341 0118 FF93      		push r31
 342               	.LCFI25:
 343               		.cfi_def_cfa_offset 16
 344               		.cfi_offset 31, -15
 345               	/* prologue: Signal */
 346               	/* frame size = 0 */
 347               	/* stack size = 15 */
 348               	.L__stack_usage = 15
  86:main.c        ****     cli();
 349               		.loc 1 86 0
 350               	/* #APP */
 351               	 ;  86 "main.c" 1
 352 011a F894      		cli
 353               	 ;  0 "" 2
  87:main.c        ****     test_vent_enc(1);
 354               		.loc 1 87 0
 355               	/* #NOAPP */
 356 011c 81E0      		ldi r24,lo8(1)
 357 011e 0E94 0000 		call test_vent_enc
 358               	.LVL17:
  88:main.c        ****     sei();
 359               		.loc 1 88 0
 360               	/* #APP */
 361               	 ;  88 "main.c" 1
 362 0122 7894      		sei
 363               	 ;  0 "" 2
 364               	/* epilogue start */
  89:main.c        **** }
 365               		.loc 1 89 0
 366               	/* #NOAPP */
 367 0124 FF91      		pop r31
 368 0126 EF91      		pop r30
 369 0128 BF91      		pop r27
 370 012a AF91      		pop r26
 371 012c 9F91      		pop r25
 372 012e 8F91      		pop r24
 373 0130 7F91      		pop r23
 374 0132 6F91      		pop r22
 375 0134 5F91      		pop r21
 376 0136 4F91      		pop r20
 377 0138 3F91      		pop r19
 378 013a 2F91      		pop r18
 379 013c 0F90      		pop r0
 380 013e 0FBE      		out __SREG__,r0
 381 0140 0F90      		pop r0
 382 0142 1F90      		pop r1
 383 0144 1895      		reti
 384               		.cfi_endproc
 385               	.LFE16:
 387               	.global	__vector_5
 389               	__vector_5:
 390               	.LFB17:
  90:main.c        **** 
  91:main.c        **** ISR (PCINT2_vect) // IN_BTN_V_UP Vent
  92:main.c        **** {
 391               		.loc 1 92 0
 392               		.cfi_startproc
 393 0146 1F92      		push r1
 394               	.LCFI26:
 395               		.cfi_def_cfa_offset 3
 396               		.cfi_offset 1, -2
 397 0148 0F92      		push r0
 398               	.LCFI27:
 399               		.cfi_def_cfa_offset 4
 400               		.cfi_offset 0, -3
 401 014a 0FB6      		in r0,__SREG__
 402 014c 0F92      		push r0
 403 014e 1124      		clr __zero_reg__
 404 0150 2F93      		push r18
 405               	.LCFI28:
 406               		.cfi_def_cfa_offset 5
 407               		.cfi_offset 18, -4
 408 0152 3F93      		push r19
 409               	.LCFI29:
 410               		.cfi_def_cfa_offset 6
 411               		.cfi_offset 19, -5
 412 0154 4F93      		push r20
 413               	.LCFI30:
 414               		.cfi_def_cfa_offset 7
 415               		.cfi_offset 20, -6
 416 0156 5F93      		push r21
 417               	.LCFI31:
 418               		.cfi_def_cfa_offset 8
 419               		.cfi_offset 21, -7
 420 0158 6F93      		push r22
 421               	.LCFI32:
 422               		.cfi_def_cfa_offset 9
 423               		.cfi_offset 22, -8
 424 015a 7F93      		push r23
 425               	.LCFI33:
 426               		.cfi_def_cfa_offset 10
 427               		.cfi_offset 23, -9
 428 015c 8F93      		push r24
 429               	.LCFI34:
 430               		.cfi_def_cfa_offset 11
 431               		.cfi_offset 24, -10
 432 015e 9F93      		push r25
 433               	.LCFI35:
 434               		.cfi_def_cfa_offset 12
 435               		.cfi_offset 25, -11
 436 0160 AF93      		push r26
 437               	.LCFI36:
 438               		.cfi_def_cfa_offset 13
 439               		.cfi_offset 26, -12
 440 0162 BF93      		push r27
 441               	.LCFI37:
 442               		.cfi_def_cfa_offset 14
 443               		.cfi_offset 27, -13
 444 0164 EF93      		push r30
 445               	.LCFI38:
 446               		.cfi_def_cfa_offset 15
 447               		.cfi_offset 30, -14
 448 0166 FF93      		push r31
 449               	.LCFI39:
 450               		.cfi_def_cfa_offset 16
 451               		.cfi_offset 31, -15
 452               	/* prologue: Signal */
 453               	/* frame size = 0 */
 454               	/* stack size = 15 */
 455               	.L__stack_usage = 15
  93:main.c        ****     cli();
 456               		.loc 1 93 0
 457               	/* #APP */
 458               	 ;  93 "main.c" 1
 459 0168 F894      		cli
 460               	 ;  0 "" 2
  94:main.c        ****     test_vent_enc(0);
 461               		.loc 1 94 0
 462               	/* #NOAPP */
 463 016a 80E0      		ldi r24,0
 464 016c 0E94 0000 		call test_vent_enc
 465               	.LVL18:
  95:main.c        ****     sei();
 466               		.loc 1 95 0
 467               	/* #APP */
 468               	 ;  95 "main.c" 1
 469 0170 7894      		sei
 470               	 ;  0 "" 2
 471               	/* epilogue start */
  96:main.c        **** }
 472               		.loc 1 96 0
 473               	/* #NOAPP */
 474 0172 FF91      		pop r31
 475 0174 EF91      		pop r30
 476 0176 BF91      		pop r27
 477 0178 AF91      		pop r26
 478 017a 9F91      		pop r25
 479 017c 8F91      		pop r24
 480 017e 7F91      		pop r23
 481 0180 6F91      		pop r22
 482 0182 5F91      		pop r21
 483 0184 4F91      		pop r20
 484 0186 3F91      		pop r19
 485 0188 2F91      		pop r18
 486 018a 0F90      		pop r0
 487 018c 0FBE      		out __SREG__,r0
 488 018e 0F90      		pop r0
 489 0190 1F90      		pop r1
 490 0192 1895      		reti
 491               		.cfi_endproc
 492               	.LFE17:
 494               	.global	test_temp_enc
 496               	test_temp_enc:
 497               	.LFB18:
  97:main.c        **** 
  98:main.c        **** //********************** Temp Enc INT**********************
  99:main.c        **** 
 100:main.c        **** void test_temp_enc(int8_t up)
 101:main.c        **** {
 498               		.loc 1 101 0
 499               		.cfi_startproc
 500               	.LVL19:
 501               	/* prologue: function */
 502               	/* frame size = 0 */
 503               	/* stack size = 0 */
 504               	.L__stack_usage = 0
 505               	.LBB72:
 506               	.LBB73:
 507               		.file 2 "subs.h"
   1:subs.h        **** //#include <avr/wdt.h>
   2:subs.h        **** #define XTAL F_CPU
   3:subs.h        **** #include <stdint.h>
   4:subs.h        **** #include <avr/interrupt.h>
   5:subs.h        **** 
   6:subs.h        **** #define BTN_LONG_DELAY	2
   7:subs.h        **** 
   8:subs.h        **** typedef enum {
   9:subs.h        ****     ADC0=0,
  10:subs.h        ****     ADC1 =1,
  11:subs.h        ****     ADC2 =2,
  12:subs.h        ****     ADC3 =3,
  13:subs.h        ****     ADC4 =4,
  14:subs.h        ****     ADC5 =5,
  15:subs.h        ****     ADC6 =6,
  16:subs.h        ****     ADC7 =7
  17:subs.h        **** } adc_in_type;
  18:subs.h        **** 
  19:subs.h        **** /*************************************************************************
  20:subs.h        ****  delay loop for small accurate delays: 16-bit counter, 4 cycles/loop
  21:subs.h        ****  *************************************************************************/
  22:subs.h        **** static inline void _delayFourCycles(uint16_t __count)
  23:subs.h        **** {
  24:subs.h        ****     if (__count == 0)
  25:subs.h        **** 	__asm__ __volatile__( "rjmp 1f\n 1:" );
  26:subs.h        ****     // 2 cycles
  27:subs.h        ****     else
  28:subs.h        **** 	__asm__ __volatile__ (
 508               		.loc 2 28 0
 509 0194 E2E0      		ldi r30,lo8(2)
 510 0196 F0E0      		ldi r31,0
 511               	/* #APP */
 512               	 ;  28 "subs.h" 1
 513 0198 3197      		1: sbiw r30,1
 514 019a 01F4      		brne 1b
 515               	 ;  0 "" 2
 516               	.LVL20:
 517               	/* #NOAPP */
 518               	.LBE73:
 519               	.LBE72:
 102:main.c        ****     delay(1);
 103:main.c        ****     if (get_input(IN_BTN_T_UP) == get_input(IN_BTN_T_DWN)) {
 520               		.loc 1 103 0
 521 019c 29B1      		in r18,0x9
 522 019e 99B1      		in r25,0x9
 523 01a0 23FB      		bst r18,3
 524 01a2 3327      		clr r19
 525 01a4 30F9      		bld r19,0
 526 01a6 21E0      		ldi r18,lo8(1)
 527 01a8 2327      		eor r18,r19
 528 01aa 92FB      		bst r25,2
 529 01ac 9927      		clr r25
 530 01ae 90F9      		bld r25,0
 531 01b0 2917      		cp r18,r25
 532 01b2 01F0      		breq .L12
 104:main.c        **** 	if (up) {
 533               		.loc 1 104 0
 534 01b4 8823      		tst r24
 535 01b6 01F0      		breq .L14
 536               	.LVL21:
 537               	.LBB74:
 538               	.LBB75:
 105:main.c        **** 	    temp_enc++;
 539               		.loc 1 105 0
 540 01b8 8091 0000 		lds r24,temp_enc
 541               	.LVL22:
 542 01bc 8F5F      		subi r24,lo8(-(1))
 543 01be 00C0      		rjmp .L15
 544               	.LVL23:
 545               	.L14:
 546               	.LBE75:
 547               	.LBE74:
 106:main.c        **** 	} else {
 107:main.c        **** 	    temp_enc--;
 548               		.loc 1 107 0
 549 01c0 8091 0000 		lds r24,temp_enc
 550               	.LVL24:
 551 01c4 8150      		subi r24,lo8(-(-1))
 552               	.L15:
 553 01c6 8093 0000 		sts temp_enc,r24
 554               	.L12:
 555 01ca 0895      		ret
 556               		.cfi_endproc
 557               	.LFE18:
 559               	.global	__vector_1
 561               	__vector_1:
 562               	.LFB19:
 108:main.c        **** 	}
 109:main.c        ****     }
 110:main.c        **** }
 111:main.c        **** 
 112:main.c        **** ISR (INT0_vect) // IN_BTN_T_DWN Temp
 113:main.c        **** {
 563               		.loc 1 113 0
 564               		.cfi_startproc
 565 01cc 1F92      		push r1
 566               	.LCFI40:
 567               		.cfi_def_cfa_offset 3
 568               		.cfi_offset 1, -2
 569 01ce 0F92      		push r0
 570               	.LCFI41:
 571               		.cfi_def_cfa_offset 4
 572               		.cfi_offset 0, -3
 573 01d0 0FB6      		in r0,__SREG__
 574 01d2 0F92      		push r0
 575 01d4 1124      		clr __zero_reg__
 576 01d6 2F93      		push r18
 577               	.LCFI42:
 578               		.cfi_def_cfa_offset 5
 579               		.cfi_offset 18, -4
 580 01d8 3F93      		push r19
 581               	.LCFI43:
 582               		.cfi_def_cfa_offset 6
 583               		.cfi_offset 19, -5
 584 01da 4F93      		push r20
 585               	.LCFI44:
 586               		.cfi_def_cfa_offset 7
 587               		.cfi_offset 20, -6
 588 01dc 5F93      		push r21
 589               	.LCFI45:
 590               		.cfi_def_cfa_offset 8
 591               		.cfi_offset 21, -7
 592 01de 6F93      		push r22
 593               	.LCFI46:
 594               		.cfi_def_cfa_offset 9
 595               		.cfi_offset 22, -8
 596 01e0 7F93      		push r23
 597               	.LCFI47:
 598               		.cfi_def_cfa_offset 10
 599               		.cfi_offset 23, -9
 600 01e2 8F93      		push r24
 601               	.LCFI48:
 602               		.cfi_def_cfa_offset 11
 603               		.cfi_offset 24, -10
 604 01e4 9F93      		push r25
 605               	.LCFI49:
 606               		.cfi_def_cfa_offset 12
 607               		.cfi_offset 25, -11
 608 01e6 AF93      		push r26
 609               	.LCFI50:
 610               		.cfi_def_cfa_offset 13
 611               		.cfi_offset 26, -12
 612 01e8 BF93      		push r27
 613               	.LCFI51:
 614               		.cfi_def_cfa_offset 14
 615               		.cfi_offset 27, -13
 616 01ea EF93      		push r30
 617               	.LCFI52:
 618               		.cfi_def_cfa_offset 15
 619               		.cfi_offset 30, -14
 620 01ec FF93      		push r31
 621               	.LCFI53:
 622               		.cfi_def_cfa_offset 16
 623               		.cfi_offset 31, -15
 624               	/* prologue: Signal */
 625               	/* frame size = 0 */
 626               	/* stack size = 15 */
 627               	.L__stack_usage = 15
 114:main.c        ****     cli();
 628               		.loc 1 114 0
 629               	/* #APP */
 630               	 ;  114 "main.c" 1
 631 01ee F894      		cli
 632               	 ;  0 "" 2
 115:main.c        ****     test_temp_enc(1);
 633               		.loc 1 115 0
 634               	/* #NOAPP */
 635 01f0 81E0      		ldi r24,lo8(1)
 636 01f2 0E94 0000 		call test_temp_enc
 637               	.LVL25:
 116:main.c        ****     sei();
 638               		.loc 1 116 0
 639               	/* #APP */
 640               	 ;  116 "main.c" 1
 641 01f6 7894      		sei
 642               	 ;  0 "" 2
 643               	/* epilogue start */
 117:main.c        **** }
 644               		.loc 1 117 0
 645               	/* #NOAPP */
 646 01f8 FF91      		pop r31
 647 01fa EF91      		pop r30
 648 01fc BF91      		pop r27
 649 01fe AF91      		pop r26
 650 0200 9F91      		pop r25
 651 0202 8F91      		pop r24
 652 0204 7F91      		pop r23
 653 0206 6F91      		pop r22
 654 0208 5F91      		pop r21
 655 020a 4F91      		pop r20
 656 020c 3F91      		pop r19
 657 020e 2F91      		pop r18
 658 0210 0F90      		pop r0
 659 0212 0FBE      		out __SREG__,r0
 660 0214 0F90      		pop r0
 661 0216 1F90      		pop r1
 662 0218 1895      		reti
 663               		.cfi_endproc
 664               	.LFE19:
 666               	.global	__vector_2
 668               	__vector_2:
 669               	.LFB20:
 118:main.c        **** 
 119:main.c        **** ISR (INT1_vect) // IN_BTN_T_UP Temp
 120:main.c        **** {
 670               		.loc 1 120 0
 671               		.cfi_startproc
 672 021a 1F92      		push r1
 673               	.LCFI54:
 674               		.cfi_def_cfa_offset 3
 675               		.cfi_offset 1, -2
 676 021c 0F92      		push r0
 677               	.LCFI55:
 678               		.cfi_def_cfa_offset 4
 679               		.cfi_offset 0, -3
 680 021e 0FB6      		in r0,__SREG__
 681 0220 0F92      		push r0
 682 0222 1124      		clr __zero_reg__
 683 0224 2F93      		push r18
 684               	.LCFI56:
 685               		.cfi_def_cfa_offset 5
 686               		.cfi_offset 18, -4
 687 0226 3F93      		push r19
 688               	.LCFI57:
 689               		.cfi_def_cfa_offset 6
 690               		.cfi_offset 19, -5
 691 0228 4F93      		push r20
 692               	.LCFI58:
 693               		.cfi_def_cfa_offset 7
 694               		.cfi_offset 20, -6
 695 022a 5F93      		push r21
 696               	.LCFI59:
 697               		.cfi_def_cfa_offset 8
 698               		.cfi_offset 21, -7
 699 022c 6F93      		push r22
 700               	.LCFI60:
 701               		.cfi_def_cfa_offset 9
 702               		.cfi_offset 22, -8
 703 022e 7F93      		push r23
 704               	.LCFI61:
 705               		.cfi_def_cfa_offset 10
 706               		.cfi_offset 23, -9
 707 0230 8F93      		push r24
 708               	.LCFI62:
 709               		.cfi_def_cfa_offset 11
 710               		.cfi_offset 24, -10
 711 0232 9F93      		push r25
 712               	.LCFI63:
 713               		.cfi_def_cfa_offset 12
 714               		.cfi_offset 25, -11
 715 0234 AF93      		push r26
 716               	.LCFI64:
 717               		.cfi_def_cfa_offset 13
 718               		.cfi_offset 26, -12
 719 0236 BF93      		push r27
 720               	.LCFI65:
 721               		.cfi_def_cfa_offset 14
 722               		.cfi_offset 27, -13
 723 0238 EF93      		push r30
 724               	.LCFI66:
 725               		.cfi_def_cfa_offset 15
 726               		.cfi_offset 30, -14
 727 023a FF93      		push r31
 728               	.LCFI67:
 729               		.cfi_def_cfa_offset 16
 730               		.cfi_offset 31, -15
 731               	/* prologue: Signal */
 732               	/* frame size = 0 */
 733               	/* stack size = 15 */
 734               	.L__stack_usage = 15
 121:main.c        ****     cli();
 735               		.loc 1 121 0
 736               	/* #APP */
 737               	 ;  121 "main.c" 1
 738 023c F894      		cli
 739               	 ;  0 "" 2
 122:main.c        ****     test_temp_enc(0);
 740               		.loc 1 122 0
 741               	/* #NOAPP */
 742 023e 80E0      		ldi r24,0
 743 0240 0E94 0000 		call test_temp_enc
 744               	.LVL26:
 123:main.c        ****     sei();
 745               		.loc 1 123 0
 746               	/* #APP */
 747               	 ;  123 "main.c" 1
 748 0244 7894      		sei
 749               	 ;  0 "" 2
 750               	/* epilogue start */
 124:main.c        **** }
 751               		.loc 1 124 0
 752               	/* #NOAPP */
 753 0246 FF91      		pop r31
 754 0248 EF91      		pop r30
 755 024a BF91      		pop r27
 756 024c AF91      		pop r26
 757 024e 9F91      		pop r25
 758 0250 8F91      		pop r24
 759 0252 7F91      		pop r23
 760 0254 6F91      		pop r22
 761 0256 5F91      		pop r21
 762 0258 4F91      		pop r20
 763 025a 3F91      		pop r19
 764 025c 2F91      		pop r18
 765 025e 0F90      		pop r0
 766 0260 0FBE      		out __SREG__,r0
 767 0262 0F90      		pop r0
 768 0264 1F90      		pop r1
 769 0266 1895      		reti
 770               		.cfi_endproc
 771               	.LFE20:
 773               	.global	set_def_vals
 775               	set_def_vals:
 776               	.LFB21:
 125:main.c        **** 
 126:main.c        **** //********************** **********************
 127:main.c        **** void set_def_vals(void)
 128:main.c        **** {
 777               		.loc 1 128 0
 778               		.cfi_startproc
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 129:main.c        ****     vars.setup_temp = 20;
 783               		.loc 1 129 0
 784 0268 E0E0      		ldi r30,lo8(vars)
 785 026a F0E0      		ldi r31,hi8(vars)
 786 026c 84E1      		ldi r24,lo8(20)
 787 026e 8183      		std Z+1,r24
 130:main.c        ****     vars.vent_nom_seg = 4;
 788               		.loc 1 130 0
 789 0270 84E0      		ldi r24,lo8(4)
 790 0272 8283      		std Z+2,r24
 131:main.c        ****     vars.temp_seg = 2;
 791               		.loc 1 131 0
 792 0274 82E0      		ldi r24,lo8(2)
 793 0276 8383      		std Z+3,r24
 132:main.c        ****     vars.wmode = wmode_auto;
 794               		.loc 1 132 0
 795 0278 1082      		st Z,__zero_reg__
 133:main.c        ****     vars.const_cnd_frost_t = COND_T_FROST;
 796               		.loc 1 133 0
 797 027a 8087      		std Z+8,r24
 134:main.c        ****     vars.pid_P_kfc = PID_P_KFC;
 798               		.loc 1 134 0
 799 027c 9AE0      		ldi r25,lo8(10)
 800 027e 9483      		std Z+4,r25
 135:main.c        ****     vars.pid_I_kfc = PID_I_KFC;
 801               		.loc 1 135 0
 802 0280 21E0      		ldi r18,lo8(1)
 803 0282 2583      		std Z+5,r18
 136:main.c        ****     vars.vent_var_kfc = VENT_VAR_KFC;
 804               		.loc 1 136 0
 805 0284 9683      		std Z+6,r25
 137:main.c        ****     vars.temp_seg_delay = TEMP_OUT_DELAY;
 806               		.loc 1 137 0
 807 0286 8783      		std Z+7,r24
 138:main.c        ****     vars.cond_enabled = 0;
 808               		.loc 1 138 0
 809 0288 1186      		std Z+9,__zero_reg__
 139:main.c        ****     vars.auto_defrost = 3;
 810               		.loc 1 139 0
 811 028a 83E0      		ldi r24,lo8(3)
 812 028c 8287      		std Z+10,r24
 813 028e 0895      		ret
 814               		.cfi_endproc
 815               	.LFE21:
 817               	.global	myread_eeprom
 819               	myread_eeprom:
 820               	.LFB22:
 140:main.c        **** }
 141:main.c        **** 
 142:main.c        **** void myread_eeprom(void)
 143:main.c        **** {
 821               		.loc 1 143 0
 822               		.cfi_startproc
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 0 */
 826               	.L__stack_usage = 0
 144:main.c        ****     cli();
 827               		.loc 1 144 0
 828               	/* #APP */
 829               	 ;  144 "main.c" 1
 830 0290 F894      		cli
 831               	 ;  0 "" 2
 145:main.c        ****     eeprom_read_buf((uint8_t *) &vars, EEMEM_VARS, sizeof(vars));
 832               		.loc 1 145 0
 833               	/* #NOAPP */
 834 0292 4BE0      		ldi r20,lo8(11)
 835 0294 50E0      		ldi r21,0
 836 0296 64E6      		ldi r22,lo8(100)
 837 0298 70E0      		ldi r23,0
 838 029a 80E0      		ldi r24,lo8(vars)
 839 029c 90E0      		ldi r25,hi8(vars)
 840 029e 0E94 0000 		call eeprom_read_buf
 841               	.LVL27:
 146:main.c        **** //    eeprom_read_block(&vars, 10, sizeof(vars));
 147:main.c        **** //    uint8_t tst = eeprom_read_byte(&ftst_ee);
 148:main.c        ****     uint8_t tst = eeprom_read_byte1(EEMEM_TST);
 842               		.loc 1 148 0
 843 02a2 82E3      		ldi r24,lo8(50)
 844 02a4 90E0      		ldi r25,0
 845 02a6 0E94 0000 		call eeprom_read_byte1
 846               	.LVL28:
 149:main.c        ****     if (tst != 0xaa) {
 847               		.loc 1 149 0
 848 02aa 8A3A      		cpi r24,lo8(-86)
 849 02ac 01F0      		breq .L19
 150:main.c        **** 	set_def_vals();
 850               		.loc 1 150 0
 851 02ae 0C94 0000 		jmp set_def_vals
 852               	.LVL29:
 853               	.L19:
 854 02b2 0895      		ret
 855               		.cfi_endproc
 856               	.LFE22:
 858               	.global	myupdate_eeprom
 860               	myupdate_eeprom:
 861               	.LFB23:
 151:main.c        ****     }
 152:main.c        **** }
 153:main.c        **** 
 154:main.c        **** void myupdate_eeprom(void)
 155:main.c        **** {
 862               		.loc 1 155 0
 863               		.cfi_startproc
 864               	/* prologue: function */
 865               	/* frame size = 0 */
 866               	/* stack size = 0 */
 867               	.L__stack_usage = 0
 156:main.c        ****     cli();
 868               		.loc 1 156 0
 869               	/* #APP */
 870               	 ;  156 "main.c" 1
 871 02b4 F894      		cli
 872               	 ;  0 "" 2
 157:main.c        ****     eeprom_update_buf(EEMEM_VARS, (uint8_t *) &vars, sizeof(vars));
 873               		.loc 1 157 0
 874               	/* #NOAPP */
 875 02b6 4BE0      		ldi r20,lo8(11)
 876 02b8 50E0      		ldi r21,0
 877 02ba 60E0      		ldi r22,lo8(vars)
 878 02bc 70E0      		ldi r23,hi8(vars)
 879 02be 84E6      		ldi r24,lo8(100)
 880 02c0 90E0      		ldi r25,0
 881 02c2 0E94 0000 		call eeprom_update_buf
 882               	.LVL30:
 158:main.c        ****     if (eeprom_read_byte1(EEMEM_TST) != 0xaa) {
 883               		.loc 1 158 0
 884 02c6 82E3      		ldi r24,lo8(50)
 885 02c8 90E0      		ldi r25,0
 886 02ca 0E94 0000 		call eeprom_read_byte1
 887               	.LVL31:
 888 02ce 8A3A      		cpi r24,lo8(-86)
 889 02d0 01F0      		breq .L21
 890               	.LBB78:
 891               	.LBB79:
 159:main.c        **** 	eeprom_write_byte1(EEMEM_TST, 0xaa);
 892               		.loc 1 159 0
 893 02d2 6AEA      		ldi r22,lo8(-86)
 894 02d4 82E3      		ldi r24,lo8(50)
 895 02d6 90E0      		ldi r25,0
 896 02d8 0C94 0000 		jmp eeprom_write_byte1
 897               	.LVL32:
 898               	.L21:
 899 02dc 0895      		ret
 900               	.LBE79:
 901               	.LBE78:
 902               		.cfi_endproc
 903               	.LFE23:
 905               	.global	switch_temp
 907               	switch_temp:
 908               	.LFB24:
 160:main.c        ****     }
 161:main.c        ****     /*
 162:main.c        ****      eeprom_update_block(&vars, 10, sizeof(vars));
 163:main.c        ****      uint8_t tst = 0xaa;
 164:main.c        ****      //eeprom_update_byte(&ftst_ee, &tst);
 165:main.c        ****      */
 166:main.c        **** }
 167:main.c        **** 
 168:main.c        **** /*
 169:main.c        ****  uint8_t hex_to_num(int8_t sym)
 170:main.c        ****  {
 171:main.c        ****  if (sym >= '0' && sym <= '9')
 172:main.c        ****  return (sym - '0');
 173:main.c        ****  else if (sym >= 'A' && sym <= 'F')
 174:main.c        ****  return (sym - 'A' + 10);
 175:main.c        ****  return (255);
 176:main.c        ****  }
 177:main.c        **** 
 178:main.c        ****  uint8_t str_to_num(struct m2bytes nbuf)
 179:main.c        ****  {
 180:main.c        ****  uint8_t num1, num2;
 181:main.c        **** 
 182:main.c        ****  num1 = hex_to_num(nbuf.one);
 183:main.c        ****  if (num1 >= 0 && num1 <= 9)
 184:main.c        ****  num1 *= 10;
 185:main.c        ****  else
 186:main.c        ****  return (255);
 187:main.c        ****  num2 = hex_to_num(nbuf.two);
 188:main.c        ****  if (num2 >= 0 && num2 <= 9)
 189:main.c        ****  return (num2 + num1);
 190:main.c        ****  return (255);
 191:main.c        ****  }
 192:main.c        **** 
 193:main.c        ****  void num_to_hex(struct m2bytes *nbuf)
 194:main.c        ****  {
 195:main.c        ****  uint8_t tmp, num;
 196:main.c        ****  //m2bytes nbuf;
 197:main.c        **** 
 198:main.c        ****  num = nbuf->one;
 199:main.c        ****  tmp = num / 16;
 200:main.c        ****  if (tmp > 9)
 201:main.c        ****  nbuf->one = tmp + 'A' - 10;
 202:main.c        ****  else
 203:main.c        ****  nbuf->one = tmp + '0';
 204:main.c        ****  num -= tmp * 16;
 205:main.c        ****  if (num > 9)
 206:main.c        ****  nbuf->two = num + 'A' - 10;
 207:main.c        ****  else
 208:main.c        ****  nbuf->two = num + '0';
 209:main.c        ****  }
 210:main.c        ****  */
 211:main.c        **** #define DELAY_ENC_BTWN 500
 212:main.c        **** #define DELAY_ENC_CKL_MS 30
 213:main.c        **** void switch_temp(int8_t up)
 214:main.c        **** {
 909               		.loc 1 214 0
 910               		.cfi_startproc
 911               	.LVL33:
 912               	/* prologue: function */
 913               	/* frame size = 0 */
 914               	/* stack size = 0 */
 915               	.L__stack_usage = 0
 215:main.c        ****     if (up) {
 916               		.loc 1 215 0
 917 02de 8823      		tst r24
 918 02e0 01F0      		breq .L24
 216:main.c        **** 	if (get_output(OUT_BTN_T_UP)) {
 919               		.loc 1 216 0
 920 02e2 5D9B      		sbis 0xb,5
 921 02e4 00C0      		rjmp .L25
 217:main.c        **** 	    pin_low(OUT_BTN_T_UP);
 922               		.loc 1 217 0
 923 02e6 5D98      		cbi 0xb,5
 924               	.LVL34:
 925               	.LBB80:
 926               	.LBB81:
 927               		.loc 2 28 0
 928 02e8 88EE      		ldi r24,lo8(-24)
 929 02ea 93E0      		ldi r25,lo8(3)
 930               	.LVL35:
 931               	/* #APP */
 932               	 ;  28 "subs.h" 1
 933 02ec 0197      		1: sbiw r24,1
 934 02ee 01F4      		brne 1b
 935               	 ;  0 "" 2
 936               	.LVL36:
 937               	/* #NOAPP */
 938               	.LBE81:
 939               	.LBE80:
 218:main.c        **** 	    delay(DELAY_ENC_BTWN);
 219:main.c        **** 	    pin_low(OUT_BTN_T_DWN);
 940               		.loc 1 219 0
 941 02f0 5C98      		cbi 0xb,4
 942 02f2 00C0      		rjmp .L26
 943               	.LVL37:
 944               	.L25:
 220:main.c        **** 	} else {
 221:main.c        **** 	    pin_high(OUT_BTN_T_UP);
 945               		.loc 1 221 0
 946 02f4 5D9A      		sbi 0xb,5
 947               	.LVL38:
 948               	.LBB82:
 949               	.LBB83:
 950               		.loc 2 28 0
 951 02f6 88EE      		ldi r24,lo8(-24)
 952 02f8 93E0      		ldi r25,lo8(3)
 953               	.LVL39:
 954               	/* #APP */
 955               	 ;  28 "subs.h" 1
 956 02fa 0197      		1: sbiw r24,1
 957 02fc 01F4      		brne 1b
 958               	 ;  0 "" 2
 959               	.LVL40:
 960               	/* #NOAPP */
 961               	.LBE83:
 962               	.LBE82:
 222:main.c        **** 	    delay(DELAY_ENC_BTWN);
 223:main.c        **** 	    pin_high(OUT_BTN_T_DWN);
 963               		.loc 1 223 0
 964 02fe 5C9A      		sbi 0xb,4
 965 0300 00C0      		rjmp .L26
 966               	.LVL41:
 967               	.L24:
 224:main.c        **** 	}
 225:main.c        ****     } else {
 226:main.c        **** 	if (get_output(OUT_BTN_T_UP)) {
 968               		.loc 1 226 0
 969 0302 5D9B      		sbis 0xb,5
 970 0304 00C0      		rjmp .L27
 227:main.c        **** 	    pin_low(OUT_BTN_T_DWN);
 971               		.loc 1 227 0
 972 0306 5C98      		cbi 0xb,4
 973               	.LVL42:
 974               	.LBB84:
 975               	.LBB85:
 976               		.loc 2 28 0
 977 0308 88EE      		ldi r24,lo8(-24)
 978 030a 93E0      		ldi r25,lo8(3)
 979               	.LVL43:
 980               	/* #APP */
 981               	 ;  28 "subs.h" 1
 982 030c 0197      		1: sbiw r24,1
 983 030e 01F4      		brne 1b
 984               	 ;  0 "" 2
 985               	.LVL44:
 986               	/* #NOAPP */
 987               	.LBE85:
 988               	.LBE84:
 228:main.c        **** 	    delay(DELAY_ENC_BTWN);
 229:main.c        **** 	    pin_low(OUT_BTN_T_UP);
 989               		.loc 1 229 0
 990 0310 5D98      		cbi 0xb,5
 991 0312 00C0      		rjmp .L26
 992               	.LVL45:
 993               	.L27:
 230:main.c        **** 	} else {
 231:main.c        **** 	    pin_high(OUT_BTN_T_DWN);
 994               		.loc 1 231 0
 995 0314 5C9A      		sbi 0xb,4
 996               	.LVL46:
 997               	.LBB86:
 998               	.LBB87:
 999               		.loc 2 28 0
 1000 0316 88EE      		ldi r24,lo8(-24)
 1001 0318 93E0      		ldi r25,lo8(3)
 1002               	.LVL47:
 1003               	/* #APP */
 1004               	 ;  28 "subs.h" 1
 1005 031a 0197      		1: sbiw r24,1
 1006 031c 01F4      		brne 1b
 1007               	 ;  0 "" 2
 1008               	.LVL48:
 1009               	/* #NOAPP */
 1010               	.LBE87:
 1011               	.LBE86:
 232:main.c        **** 	    delay(DELAY_ENC_BTWN);
 233:main.c        **** 	    pin_high(OUT_BTN_T_UP);
 1012               		.loc 1 233 0
 1013 031e 5D9A      		sbi 0xb,5
 1014               	.L26:
 234:main.c        **** 	}
 235:main.c        ****     }
 236:main.c        ****     delay_ms(DELAY_ENC_CKL_MS);
 1015               		.loc 1 236 0
 1016 0320 8EE1      		ldi r24,lo8(30)
 1017 0322 90E0      		ldi r25,0
 1018 0324 0C94 0000 		jmp delay_ms
 1019               	.LVL49:
 1020               		.cfi_endproc
 1021               	.LFE24:
 1023               	.global	switch_vent
 1025               	switch_vent:
 1026               	.LFB25:
 237:main.c        **** }
 238:main.c        **** 
 239:main.c        **** void switch_vent(int8_t up)
 240:main.c        **** {
 1027               		.loc 1 240 0
 1028               		.cfi_startproc
 1029               	.LVL50:
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 0 */
 1033               	.L__stack_usage = 0
 241:main.c        ****     if (up) {
 1034               		.loc 1 241 0
 1035 0328 8823      		tst r24
 1036 032a 01F0      		breq .L29
 242:main.c        **** 	if (get_output(OUT_BTN_V_UP)) {
 1037               		.loc 1 242 0
 1038 032c 5E9B      		sbis 0xb,6
 1039 032e 00C0      		rjmp .L30
 243:main.c        **** 	    pin_low(OUT_BTN_V_UP);
 1040               		.loc 1 243 0
 1041 0330 5E98      		cbi 0xb,6
 1042               	.LVL51:
 1043               	.LBB88:
 1044               	.LBB89:
 1045               		.loc 2 28 0
 1046 0332 88EE      		ldi r24,lo8(-24)
 1047 0334 93E0      		ldi r25,lo8(3)
 1048               	.LVL52:
 1049               	/* #APP */
 1050               	 ;  28 "subs.h" 1
 1051 0336 0197      		1: sbiw r24,1
 1052 0338 01F4      		brne 1b
 1053               	 ;  0 "" 2
 1054               	.LVL53:
 1055               	/* #NOAPP */
 1056               	.LBE89:
 1057               	.LBE88:
 244:main.c        **** 	    delay(DELAY_ENC_BTWN);
 245:main.c        **** 	    pin_low(OUT_BTN_V_DWN);
 1058               		.loc 1 245 0
 1059 033a 2998      		cbi 0x5,1
 1060 033c 00C0      		rjmp .L31
 1061               	.LVL54:
 1062               	.L30:
 246:main.c        **** 	} else {
 247:main.c        **** 	    pin_high(OUT_BTN_V_UP);
 1063               		.loc 1 247 0
 1064 033e 5E9A      		sbi 0xb,6
 1065               	.LVL55:
 1066               	.LBB90:
 1067               	.LBB91:
 1068               		.loc 2 28 0
 1069 0340 88EE      		ldi r24,lo8(-24)
 1070 0342 93E0      		ldi r25,lo8(3)
 1071               	.LVL56:
 1072               	/* #APP */
 1073               	 ;  28 "subs.h" 1
 1074 0344 0197      		1: sbiw r24,1
 1075 0346 01F4      		brne 1b
 1076               	 ;  0 "" 2
 1077               	.LVL57:
 1078               	/* #NOAPP */
 1079               	.LBE91:
 1080               	.LBE90:
 248:main.c        **** 	    delay(DELAY_ENC_BTWN);
 249:main.c        **** 	    pin_high(OUT_BTN_V_DWN);
 1081               		.loc 1 249 0
 1082 0348 299A      		sbi 0x5,1
 1083 034a 00C0      		rjmp .L31
 1084               	.LVL58:
 1085               	.L29:
 250:main.c        **** 	}
 251:main.c        ****     } else {
 252:main.c        **** 	if (get_output(OUT_BTN_V_UP)) {
 1086               		.loc 1 252 0
 1087 034c 5E9B      		sbis 0xb,6
 1088 034e 00C0      		rjmp .L32
 253:main.c        **** 	    pin_low(OUT_BTN_V_DWN);
 1089               		.loc 1 253 0
 1090 0350 2998      		cbi 0x5,1
 1091               	.LVL59:
 1092               	.LBB92:
 1093               	.LBB93:
 1094               		.loc 2 28 0
 1095 0352 88EE      		ldi r24,lo8(-24)
 1096 0354 93E0      		ldi r25,lo8(3)
 1097               	.LVL60:
 1098               	/* #APP */
 1099               	 ;  28 "subs.h" 1
 1100 0356 0197      		1: sbiw r24,1
 1101 0358 01F4      		brne 1b
 1102               	 ;  0 "" 2
 1103               	.LVL61:
 1104               	/* #NOAPP */
 1105               	.LBE93:
 1106               	.LBE92:
 254:main.c        **** 	    delay(DELAY_ENC_BTWN);
 255:main.c        **** 	    pin_low(OUT_BTN_V_UP);
 1107               		.loc 1 255 0
 1108 035a 5E98      		cbi 0xb,6
 1109 035c 00C0      		rjmp .L31
 1110               	.LVL62:
 1111               	.L32:
 256:main.c        **** 	} else {
 257:main.c        **** 	    pin_high(OUT_BTN_V_DWN);
 1112               		.loc 1 257 0
 1113 035e 299A      		sbi 0x5,1
 1114               	.LVL63:
 1115               	.LBB94:
 1116               	.LBB95:
 1117               		.loc 2 28 0
 1118 0360 88EE      		ldi r24,lo8(-24)
 1119 0362 93E0      		ldi r25,lo8(3)
 1120               	.LVL64:
 1121               	/* #APP */
 1122               	 ;  28 "subs.h" 1
 1123 0364 0197      		1: sbiw r24,1
 1124 0366 01F4      		brne 1b
 1125               	 ;  0 "" 2
 1126               	.LVL65:
 1127               	/* #NOAPP */
 1128               	.LBE95:
 1129               	.LBE94:
 258:main.c        **** 	    delay(DELAY_ENC_BTWN);
 259:main.c        **** 	    pin_high(OUT_BTN_V_UP);
 1130               		.loc 1 259 0
 1131 0368 5E9A      		sbi 0xb,6
 1132               	.L31:
 260:main.c        **** 	}
 261:main.c        ****     }
 262:main.c        ****     delay_ms(DELAY_ENC_CKL_MS);
 1133               		.loc 1 262 0
 1134 036a 8EE1      		ldi r24,lo8(30)
 1135 036c 90E0      		ldi r25,0
 1136 036e 0C94 0000 		jmp delay_ms
 1137               	.LVL66:
 1138               		.cfi_endproc
 1139               	.LFE25:
 1141               	.global	switch_cond
 1143               	switch_cond:
 1144               	.LFB26:
 263:main.c        **** }
 264:main.c        **** 
 265:main.c        **** void switch_cond(char on)
 266:main.c        **** {
 1145               		.loc 1 266 0
 1146               		.cfi_startproc
 1147               	.LVL67:
 1148               	/* prologue: function */
 1149               	/* frame size = 0 */
 1150               	/* stack size = 0 */
 1151               	.L__stack_usage = 0
 267:main.c        ****     /*    if (!on) {
 268:main.c        ****      SET_FLAG(f_mode_hot);
 269:main.c        ****      }
 270:main.c        ****      */
 271:main.c        ****     if (vars.cond_enabled) {
 1152               		.loc 1 271 0
 1153 0372 9091 0000 		lds r25,vars+9
 1154 0376 9923      		tst r25
 1155 0378 01F0      		breq .L34
 272:main.c        **** 	if (on && vent_seg_cur > 0) {
 1156               		.loc 1 272 0
 1157 037a 8823      		tst r24
 1158 037c 01F0      		breq .L35
 1159               		.loc 1 272 0 is_stmt 0 discriminator 1
 1160 037e 8091 0000 		lds r24,vent_seg_cur
 1161               	.LVL68:
 1162 0382 1816      		cp __zero_reg__,r24
 1163 0384 04F4      		brge .L35
 1164               	.LVL69:
 1165               	.LBB98:
 1166               	.LBB99:
 273:main.c        **** 	    CLR_FLAG(f_cond_ind_flash);
 1167               		.loc 1 273 0 is_stmt 1
 1168 0386 8091 0000 		lds r24,flags
 1169 038a 8F7D      		andi r24,lo8(-33)
 1170 038c 8093 0000 		sts flags,r24
 274:main.c        **** 	    pin_high(OUT_FROST_SW);
 1171               		.loc 1 274 0
 1172 0390 459A      		sbi 0x8,5
 1173 0392 0895      		ret
 1174               	.LVL70:
 1175               	.L35:
 1176               	.LBE99:
 1177               	.LBE98:
 275:main.c        **** 	} else {
 276:main.c        **** 	    SET_FLAG(f_cond_ind_flash);
 1178               		.loc 1 276 0
 1179 0394 8091 0000 		lds r24,flags
 1180 0398 8062      		ori r24,lo8(32)
 1181 039a 00C0      		rjmp .L40
 1182               	.LVL71:
 1183               	.L34:
 277:main.c        **** 	    pin_low(OUT_FROST_SW);
 278:main.c        **** 	}
 279:main.c        ****     } else {
 280:main.c        **** 	CLR_FLAG(f_cond_ind_flash);
 1184               		.loc 1 280 0
 1185 039c 8091 0000 		lds r24,flags
 1186               	.LVL72:
 1187 03a0 8F7D      		andi r24,lo8(-33)
 1188               	.L40:
 1189 03a2 8093 0000 		sts flags,r24
 281:main.c        **** 	pin_low(OUT_FROST_SW);
 1190               		.loc 1 281 0
 1191 03a6 4598      		cbi 0x8,5
 1192 03a8 0895      		ret
 1193               		.cfi_endproc
 1194               	.LFE26:
 1196               	.global	test_cond_ON
 1198               	test_cond_ON:
 1199               	.LFB27:
 282:main.c        ****     }
 283:main.c        **** }
 284:main.c        **** 
 285:main.c        **** uint8_t test_cond_ON(void)
 286:main.c        **** {
 1200               		.loc 1 286 0
 1201               		.cfi_startproc
 1202               	/* prologue: function */
 1203               	/* frame size = 0 */
 1204               	/* stack size = 0 */
 1205               	.L__stack_usage = 0
 287:main.c        ****     return get_output(OUT_FROST_SW);
 1206               		.loc 1 287 0
 1207 03aa 88B1      		in r24,0x8
 288:main.c        **** }
 1208               		.loc 1 288 0
 1209 03ac 85FB      		bst r24,5
 1210 03ae 8827      		clr r24
 1211 03b0 80F9      		bld r24,0
 1212 03b2 0895      		ret
 1213               		.cfi_endproc
 1214               	.LFE27:
 1216               	.global	__floatunsisf
 1217               	.global	__addsf3
 1218               	.global	__divsf3
 1219               	.global	__subsf3
 1220               	.global	__mulsf3
 1221               	.global	calcTempFromADC
 1223               	calcTempFromADC:
 1224               	.LFB28:
 289:main.c        **** 
 290:main.c        **** float calcTempFromADC(adc_in_type input)
 291:main.c        **** {
 1225               		.loc 1 291 0
 1226               		.cfi_startproc
 1227               	.LVL73:
 1228 03b4 CF92      		push r12
 1229               	.LCFI68:
 1230               		.cfi_def_cfa_offset 3
 1231               		.cfi_offset 12, -2
 1232 03b6 DF92      		push r13
 1233               	.LCFI69:
 1234               		.cfi_def_cfa_offset 4
 1235               		.cfi_offset 13, -3
 1236 03b8 EF92      		push r14
 1237               	.LCFI70:
 1238               		.cfi_def_cfa_offset 5
 1239               		.cfi_offset 14, -4
 1240 03ba FF92      		push r15
 1241               	.LCFI71:
 1242               		.cfi_def_cfa_offset 6
 1243               		.cfi_offset 15, -5
 1244 03bc CF93      		push r28
 1245               	.LCFI72:
 1246               		.cfi_def_cfa_offset 7
 1247               		.cfi_offset 28, -6
 1248 03be DF93      		push r29
 1249               	.LCFI73:
 1250               		.cfi_def_cfa_offset 8
 1251               		.cfi_offset 29, -7
 1252               	/* prologue: function */
 1253               	/* frame size = 0 */
 1254               	/* stack size = 6 */
 1255               	.L__stack_usage = 6
 292:main.c        ****     ADC_Mux(input);
 1256               		.loc 1 292 0
 1257 03c0 0E94 0000 		call ADC_Mux
 1258               	.LVL74:
 1259 03c4 C6E0      		ldi r28,lo8(6)
 1260 03c6 D0E0      		ldi r29,0
 293:main.c        ****     float resf = 0;
 1261               		.loc 1 293 0
 1262 03c8 C12C      		mov r12,__zero_reg__
 1263 03ca D12C      		mov r13,__zero_reg__
 1264 03cc 7601      		movw r14,r12
 1265               	.LVL75:
 1266               	.L44:
 1267               	.LBB100:
 294:main.c        ****     for (int i = 0; i < ADC_MCNT; i++) {
 295:main.c        **** 	ADC_Start();
 1268               		.loc 1 295 0
 1269 03ce 0E94 0000 		call ADC_Start
 1270               	.LVL76:
 1271               	.L43:
 296:main.c        **** 	while (ADCIsRun())
 1272               		.loc 1 296 0 discriminator 1
 1273 03d2 8091 7A00 		lds r24,122
 1274 03d6 86FD      		sbrc r24,6
 1275 03d8 00C0      		rjmp .L43
 297:main.c        **** 	    ;
 298:main.c        **** 	resf += ADC_GetData();
 1276               		.loc 1 298 0 discriminator 2
 1277 03da 0E94 0000 		call ADC_GetData
 1278               	.LVL77:
 1279 03de BC01      		movw r22,r24
 1280 03e0 80E0      		ldi r24,0
 1281 03e2 90E0      		ldi r25,0
 1282 03e4 0E94 0000 		call __floatunsisf
 1283               	.LVL78:
 1284 03e8 9B01      		movw r18,r22
 1285 03ea AC01      		movw r20,r24
 1286 03ec C701      		movw r24,r14
 1287 03ee B601      		movw r22,r12
 1288 03f0 0E94 0000 		call __addsf3
 1289               	.LVL79:
 1290 03f4 6B01      		movw r12,r22
 1291 03f6 7C01      		movw r14,r24
 1292               	.LVL80:
 1293 03f8 2197      		sbiw r28,1
 1294               	.LVL81:
 294:main.c        **** 	ADC_Start();
 1295               		.loc 1 294 0 discriminator 2
 1296 03fa 01F4      		brne .L44
 1297               	.LVL82:
 1298               	.LBE100:
 299:main.c        ****     }
 300:main.c        **** 
 301:main.c        ****     resf /= ADC_MCNT;
 302:main.c        **** 
 303:main.c        ****     resf = 3132.0f / resf - 1;
 1299               		.loc 1 303 0
 1300 03fc 20E0      		ldi r18,0
 1301 03fe 30E0      		ldi r19,0
 1302 0400 40EC      		ldi r20,lo8(-64)
 1303 0402 50E4      		ldi r21,lo8(64)
 1304 0404 0E94 0000 		call __divsf3
 1305               	.LVL83:
 1306 0408 9B01      		movw r18,r22
 1307 040a AC01      		movw r20,r24
 1308 040c 60E0      		ldi r22,0
 1309 040e 70EC      		ldi r23,lo8(-64)
 1310 0410 83E4      		ldi r24,lo8(67)
 1311 0412 95E4      		ldi r25,lo8(69)
 1312 0414 0E94 0000 		call __divsf3
 1313               	.LVL84:
 1314 0418 20E0      		ldi r18,0
 1315 041a 30E0      		ldi r19,0
 1316 041c 40E8      		ldi r20,lo8(-128)
 1317 041e 5FE3      		ldi r21,lo8(63)
 1318 0420 0E94 0000 		call __subsf3
 1319               	.LVL85:
 1320 0424 9B01      		movw r18,r22
 1321 0426 AC01      		movw r20,r24
 1322               	.LVL86:
 304:main.c        ****     resf = 100.0f / resf;
 305:main.c        **** 
 306:main.c        ****     resf = (TR_NTC_KFC * TR_NTC_T0_GRAD_K) / (TR_NTC_KFC + (TR_NTC_T0_GRAD_K * log(resf / TR_NTC_T0
 1323               		.loc 1 306 0
 1324 0428 60E0      		ldi r22,0
 1325 042a 70E0      		ldi r23,0
 1326 042c 88EC      		ldi r24,lo8(-56)
 1327 042e 92E4      		ldi r25,lo8(66)
 1328 0430 0E94 0000 		call __divsf3
 1329               	.LVL87:
 1330 0434 20E0      		ldi r18,0
 1331 0436 30E0      		ldi r19,0
 1332 0438 40E6      		ldi r20,lo8(96)
 1333 043a 51E4      		ldi r21,lo8(65)
 1334 043c 0E94 0000 		call __divsf3
 1335               	.LVL88:
 1336 0440 0E94 0000 		call log
 1337               	.LVL89:
 307:main.c        **** 	    + 0.5;
 308:main.c        **** 
 309:main.c        ****     return resf;
 1338               		.loc 1 309 0
 1339 0444 23E3      		ldi r18,lo8(51)
 1340 0446 33E9      		ldi r19,lo8(-109)
 1341 0448 42E9      		ldi r20,lo8(-110)
 1342 044a 53E4      		ldi r21,lo8(67)
 1343 044c 0E94 0000 		call __mulsf3
 1344               	.LVL90:
 1345 0450 20E0      		ldi r18,0
 1346 0452 30E0      		ldi r19,0
 1347 0454 4FE2      		ldi r20,lo8(47)
 1348 0456 55E4      		ldi r21,lo8(69)
 1349 0458 0E94 0000 		call __addsf3
 1350               	.LVL91:
 1351 045c 9B01      		movw r18,r22
 1352 045e AC01      		movw r20,r24
 1353 0460 60E4      		ldi r22,lo8(64)
 1354 0462 75E6      		ldi r23,lo8(101)
 1355 0464 88E4      		ldi r24,lo8(72)
 1356 0466 99E4      		ldi r25,lo8(73)
 1357 0468 0E94 0000 		call __divsf3
 1358               	.LVL92:
 1359 046c 23E3      		ldi r18,lo8(51)
 1360 046e 33E9      		ldi r19,lo8(-109)
 1361 0470 48E8      		ldi r20,lo8(-120)
 1362 0472 53E4      		ldi r21,lo8(67)
 1363 0474 0E94 0000 		call __subsf3
 1364               	.LVL93:
 1365 0478 20E0      		ldi r18,0
 1366 047a 30E0      		ldi r19,0
 1367 047c 40E0      		ldi r20,0
 1368 047e 5FE3      		ldi r21,lo8(63)
 1369 0480 0E94 0000 		call __addsf3
 1370               	.LVL94:
 1371               	/* epilogue start */
 310:main.c        **** }
 1372               		.loc 1 310 0
 1373 0484 DF91      		pop r29
 1374 0486 CF91      		pop r28
 1375               	.LVL95:
 1376 0488 FF90      		pop r15
 1377 048a EF90      		pop r14
 1378 048c DF90      		pop r13
 1379 048e CF90      		pop r12
 1380 0490 0895      		ret
 1381               		.cfi_endproc
 1382               	.LFE28:
 1384               	.global	bootVarsInit
 1386               	bootVarsInit:
 1387               	.LFB29:
 1388               		.file 3 "calc.c"
   1:calc.c        **** void bootVarsInit(void)
   2:calc.c        **** {
 1389               		.loc 3 2 0
 1390               		.cfi_startproc
 1391               	/* prologue: function */
 1392               	/* frame size = 0 */
 1393               	/* stack size = 0 */
 1394               	.L__stack_usage = 0
   3:calc.c        ****     vent_add_prc = 0;
 1395               		.loc 3 3 0
 1396 0492 1092 0000 		sts vent_add_prc,__zero_reg__
   4:calc.c        ****     temp_out_prc = 0;
 1397               		.loc 3 4 0
 1398 0496 1092 0000 		sts temp_out_prc,__zero_reg__
   5:calc.c        ****     temp_out_delay = TEMP_OUT_DELAY;
 1399               		.loc 3 5 0
 1400 049a 82E0      		ldi r24,lo8(2)
 1401 049c 8093 0000 		sts temp_out_delay,r24
   6:calc.c        ****     bootUp_delay = 0;
 1402               		.loc 3 6 0
 1403 04a0 1092 0000 		sts bootUp_delay,__zero_reg__
   7:calc.c        **** 
   8:calc.c        **** //    powerUp_time_sec = 0;
   9:calc.c        ****     Ipid = 0.0f;
 1404               		.loc 3 9 0
 1405 04a4 1092 0000 		sts Ipid,__zero_reg__
 1406 04a8 1092 0000 		sts Ipid+1,__zero_reg__
 1407 04ac 1092 0000 		sts Ipid+2,__zero_reg__
 1408 04b0 1092 0000 		sts Ipid+3,__zero_reg__
  10:calc.c        ****     last_delta = 0.0f;
 1409               		.loc 3 10 0
 1410 04b4 1092 0000 		sts last_delta,__zero_reg__
 1411 04b8 1092 0000 		sts last_delta+1,__zero_reg__
 1412 04bc 1092 0000 		sts last_delta+2,__zero_reg__
 1413 04c0 1092 0000 		sts last_delta+3,__zero_reg__
  11:calc.c        ****     flags = 0;
 1414               		.loc 3 11 0
 1415 04c4 1092 0000 		sts flags,__zero_reg__
  12:calc.c        ****     SET_FLAG(f_mode_hot);
 1416               		.loc 3 12 0
 1417 04c8 8091 0000 		lds r24,flags
 1418 04cc 8260      		ori r24,lo8(2)
 1419 04ce 8093 0000 		sts flags,r24
  13:calc.c        ****     CLR_FLAG(f_cond_btn_press);
 1420               		.loc 3 13 0
 1421 04d2 8091 0000 		lds r24,flags
 1422 04d6 8F7E      		andi r24,lo8(-17)
 1423 04d8 8093 0000 		sts flags,r24
  14:calc.c        **** //    downHeadFlag = 0;
  15:calc.c        **** //    upHeadFlag = 0;
  16:calc.c        ****     cond_needs_of_cool = 0;
 1424               		.loc 3 16 0
 1425 04dc 1092 0000 		sts cond_needs_of_cool,__zero_reg__
 1426 04e0 0895      		ret
 1427               		.cfi_endproc
 1428               	.LFE29:
 1430               	.global	getTempSalon
 1432               	getTempSalon:
 1433               	.LFB30:
  17:calc.c        **** }
  18:calc.c        **** 
  19:calc.c        **** float getTempSalon(void)
  20:calc.c        **** {
 1434               		.loc 3 20 0
 1435               		.cfi_startproc
 1436               	/* prologue: function */
 1437               	/* frame size = 0 */
 1438               	/* stack size = 0 */
 1439               	.L__stack_usage = 0
  21:calc.c        ****     /*   float ts =calcTempFromADC(IN_ADC_T_SALON);
  22:calc.c        ****      if(ts < )
  23:calc.c        ****      cond_over_cool_delta
  24:calc.c        ****      return ts;
  25:calc.c        ****      */
  26:calc.c        ****     return calcTempFromADC(IN_ADC_T_SALON);
 1440               		.loc 3 26 0
 1441 04e2 87E0      		ldi r24,lo8(7)
 1442 04e4 0C94 0000 		jmp calcTempFromADC
 1443               	.LVL96:
 1444               		.cfi_endproc
 1445               	.LFE30:
 1447               	.global	getTempIsparit
 1449               	getTempIsparit:
 1450               	.LFB31:
  27:calc.c        **** }
  28:calc.c        **** 
  29:calc.c        **** float getTempIsparit(void)
  30:calc.c        **** {
 1451               		.loc 3 30 0
 1452               		.cfi_startproc
 1453               	/* prologue: function */
 1454               	/* frame size = 0 */
 1455               	/* stack size = 0 */
 1456               	.L__stack_usage = 0
  31:calc.c        ****     return calcTempFromADC(IN_ADC_T_FROST);
 1457               		.loc 3 31 0
 1458 04e8 86E0      		ldi r24,lo8(6)
 1459 04ea 0C94 0000 		jmp calcTempFromADC
 1460               	.LVL97:
 1461               		.cfi_endproc
 1462               	.LFE31:
 1464               	.global	prc2Seg
 1466               	prc2Seg:
 1467               	.LFB32:
  32:calc.c        **** }
  33:calc.c        **** 
  34:calc.c        **** uint8_t prc2Seg(uint8_t segs, uint8_t prc)
  35:calc.c        **** {
 1468               		.loc 3 35 0
 1469               		.cfi_startproc
 1470               	.LVL98:
 1471 04ee CF93      		push r28
 1472               	.LCFI74:
 1473               		.cfi_def_cfa_offset 3
 1474               		.cfi_offset 28, -2
 1475               	/* prologue: function */
 1476               	/* frame size = 0 */
 1477               	/* stack size = 1 */
 1478               	.L__stack_usage = 1
 1479 04f0 C82F      		mov r28,r24
  36:calc.c        ****     prc = check_range(0, prc, 100);
 1480               		.loc 3 36 0
 1481 04f2 70E0      		ldi r23,0
 1482 04f4 44E6      		ldi r20,lo8(100)
 1483 04f6 50E0      		ldi r21,0
 1484 04f8 80E0      		ldi r24,0
 1485 04fa 90E0      		ldi r25,0
 1486               	.LVL99:
 1487 04fc 0E94 0000 		call check_range
 1488               	.LVL100:
  37:calc.c        ****     uint16_t tmp = (segs * prc + segs) / 100;
  38:calc.c        ****     return tmp;
 1489               		.loc 3 38 0
 1490 0500 9C01      		movw r18,r24
 1491 0502 3327      		clr r19
 1492 0504 2F5F      		subi r18,-1
 1493 0506 3F4F      		sbci r19,-1
 1494 0508 C29F      		mul r28,r18
 1495 050a C001      		movw r24,r0
 1496 050c C39F      		mul r28,r19
 1497 050e 900D      		add r25,r0
 1498 0510 1124      		clr __zero_reg__
 1499               	.LVL101:
 1500 0512 64E6      		ldi r22,lo8(100)
 1501 0514 70E0      		ldi r23,0
 1502 0516 0E94 0000 		call __divmodhi4
 1503               	.LVL102:
 1504 051a 862F      		mov r24,r22
 1505               	/* epilogue start */
  39:calc.c        **** }
 1506               		.loc 3 39 0
 1507 051c CF91      		pop r28
 1508               	.LVL103:
 1509 051e 0895      		ret
 1510               		.cfi_endproc
 1511               	.LFE32:
 1513               	.global	seg2Prc
 1515               	seg2Prc:
 1516               	.LFB33:
  40:calc.c        **** 
  41:calc.c        **** uint8_t seg2Prc(uint8_t segs, uint8_t seg)
  42:calc.c        **** {
 1517               		.loc 3 42 0
 1518               		.cfi_startproc
 1519               	.LVL104:
 1520               	/* prologue: function */
 1521               	/* frame size = 0 */
 1522               	/* stack size = 0 */
 1523               	.L__stack_usage = 0
  43:calc.c        ****     //seg = check_range(0, seg, segs);
  44:calc.c        ****     uint16_t tmp = (seg * 100) / segs;
  45:calc.c        ****     return tmp;
 1524               		.loc 3 45 0
 1525 0520 94E6      		ldi r25,lo8(100)
 1526 0522 699F      		mul r22,r25
 1527 0524 9001      		movw r18,r0
 1528 0526 1124      		clr __zero_reg__
 1529 0528 682F      		mov r22,r24
 1530               	.LVL105:
 1531 052a 70E0      		ldi r23,0
 1532 052c C901      		movw r24,r18
 1533               	.LVL106:
 1534 052e 0E94 0000 		call __divmodhi4
 1535               	.LVL107:
 1536 0532 862F      		mov r24,r22
  46:calc.c        **** }
 1537               		.loc 3 46 0
 1538 0534 0895      		ret
 1539               		.cfi_endproc
 1540               	.LFE33:
 1542               	.global	set_vent_seg
 1544               	set_vent_seg:
 1545               	.LFB34:
  47:calc.c        **** 
  48:calc.c        **** void set_vent_seg(uint8_t seg_vent, int8_t full_sync)
  49:calc.c        **** {
 1546               		.loc 3 49 0
 1547               		.cfi_startproc
 1548               	.LVL108:
 1549 0536 FF92      		push r15
 1550               	.LCFI75:
 1551               		.cfi_def_cfa_offset 3
 1552               		.cfi_offset 15, -2
 1553 0538 0F93      		push r16
 1554               	.LCFI76:
 1555               		.cfi_def_cfa_offset 4
 1556               		.cfi_offset 16, -3
 1557 053a 1F93      		push r17
 1558               	.LCFI77:
 1559               		.cfi_def_cfa_offset 5
 1560               		.cfi_offset 17, -4
 1561 053c CF93      		push r28
 1562               	.LCFI78:
 1563               		.cfi_def_cfa_offset 6
 1564               		.cfi_offset 28, -5
 1565 053e DF93      		push r29
 1566               	.LCFI79:
 1567               		.cfi_def_cfa_offset 7
 1568               		.cfi_offset 29, -6
 1569               	/* prologue: function */
 1570               	/* frame size = 0 */
 1571               	/* stack size = 5 */
 1572               	.L__stack_usage = 5
 1573 0540 062F      		mov r16,r22
  50:calc.c        ****     seg_vent = check_range(0, seg_vent, VENT_SEGs);
 1574               		.loc 3 50 0
 1575 0542 682F      		mov r22,r24
 1576               	.LVL109:
 1577 0544 70E0      		ldi r23,0
 1578 0546 48E0      		ldi r20,lo8(8)
 1579 0548 50E0      		ldi r21,0
 1580 054a 80E0      		ldi r24,0
 1581 054c 90E0      		ldi r25,0
 1582               	.LVL110:
 1583 054e 0E94 0000 		call check_range
 1584               	.LVL111:
 1585 0552 EC01      		movw r28,r24
 1586 0554 182F      		mov r17,r24
 1587               	.LVL112:
  51:calc.c        **** 
  52:calc.c        ****     if (seg_vent == 0) { //add sync
 1588               		.loc 3 52 0
 1589 0556 8111      		cpse r24,__zero_reg__
 1590 0558 00C0      		rjmp .L53
  53:calc.c        **** 	switch_vent(0);
 1591               		.loc 3 53 0
 1592 055a 80E0      		ldi r24,0
 1593               	.LVL113:
 1594 055c 0E94 0000 		call switch_vent
 1595               	.LVL114:
  54:calc.c        **** 	switch_cond(0); // выключаем кондиционер
 1596               		.loc 3 54 0
 1597 0560 80E0      		ldi r24,0
 1598 0562 0E94 0000 		call switch_cond
 1599               	.LVL115:
 1600 0566 00C0      		rjmp .L54
 1601               	.LVL116:
 1602               	.L53:
  55:calc.c        ****     } else if (seg_vent == VENT_SEGs) {
 1603               		.loc 3 55 0
 1604 0568 8830      		cpi r24,lo8(8)
 1605 056a 01F4      		brne .L54
  56:calc.c        **** 	switch_vent(1);
 1606               		.loc 3 56 0
 1607 056c 81E0      		ldi r24,lo8(1)
 1608               	.LVL117:
 1609 056e 0E94 0000 		call switch_vent
 1610               	.LVL118:
 1611               	.L54:
  57:calc.c        ****     }
  58:calc.c        **** 
  59:calc.c        ****     if (vent_seg_cur != seg_vent) {
 1612               		.loc 3 59 0
 1613 0572 8091 0000 		lds r24,vent_seg_cur
 1614 0576 9E01      		movw r18,r28
 1615 0578 3327      		clr r19
 1616 057a 082E      		mov __tmp_reg__,r24
 1617 057c 000C      		lsl r0
 1618 057e 990B      		sbc r25,r25
 1619 0580 8217      		cp r24,r18
 1620 0582 9307      		cpc r25,r19
 1621 0584 01F0      		breq .L52
 1622               	.LVL119:
 1623               	.LBB101:
  60:calc.c        **** 	uint8_t seg_v = seg_vent;
  61:calc.c        **** 	if (full_sync) {
 1624               		.loc 3 61 0
 1625 0586 0023      		tst r16
 1626 0588 01F0      		breq .L56
 1627 058a 00E0      		ldi r16,0
 1628               	.LVL120:
 1629               	.L57:
 1630               	.LBB102:
  62:calc.c        **** 	    for (uint8_t i = 0; i < vent_seg_cur + 2; i++) {
 1631               		.loc 3 62 0 discriminator 1
 1632 058c 8091 0000 		lds r24,vent_seg_cur
 1633 0590 082E      		mov __tmp_reg__,r24
 1634 0592 000C      		lsl r0
 1635 0594 990B      		sbc r25,r25
 1636 0596 0196      		adiw r24,1
 1637 0598 202F      		mov r18,r16
 1638 059a 30E0      		ldi r19,0
 1639 059c 8217      		cp r24,r18
 1640 059e 9307      		cpc r25,r19
 1641 05a0 04F0      		brlt .L66
  63:calc.c        **** 		switch_vent(0);
 1642               		.loc 3 63 0 discriminator 3
 1643 05a2 80E0      		ldi r24,0
 1644 05a4 0E94 0000 		call switch_vent
 1645               	.LVL121:
  62:calc.c        **** 	    for (uint8_t i = 0; i < vent_seg_cur + 2; i++) {
 1646               		.loc 3 62 0 discriminator 3
 1647 05a8 0F5F      		subi r16,lo8(-(1))
 1648               	.LVL122:
 1649 05aa 00C0      		rjmp .L57
 1650               	.L66:
 1651               	.LBE102:
  64:calc.c        **** 	    }
  65:calc.c        **** 	    delay_ms(DELAY_ENC_CKL_MS);
 1652               		.loc 3 65 0
 1653 05ac 8EE1      		ldi r24,lo8(30)
 1654 05ae 90E0      		ldi r25,0
 1655 05b0 0E94 0000 		call delay_ms
 1656               	.LVL123:
 1657               	.LBB103:
  66:calc.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
 1658               		.loc 3 66 0
 1659 05b4 00E0      		ldi r16,0
 1660               	.LVL124:
 1661               	.L59:
 1662               		.loc 3 66 0 is_stmt 0 discriminator 1
 1663 05b6 0117      		cp r16,r17
 1664 05b8 00F4      		brsh .L65
  67:calc.c        **** 		switch_vent(1);
 1665               		.loc 3 67 0 is_stmt 1 discriminator 3
 1666 05ba 81E0      		ldi r24,lo8(1)
 1667 05bc 0E94 0000 		call switch_vent
 1668               	.LVL125:
  66:calc.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
 1669               		.loc 3 66 0 discriminator 3
 1670 05c0 0F5F      		subi r16,lo8(-(1))
 1671               	.LVL126:
 1672 05c2 00C0      		rjmp .L59
 1673               	.LVL127:
 1674               	.L65:
 1675               	.LBE103:
  68:calc.c        **** 	    }
  69:calc.c        **** 	} else {
  70:calc.c        **** 	    int8_t up = 0;
  71:calc.c        **** 	    if (seg_vent > vent_seg_cur) {
  72:calc.c        **** 		seg_vent = seg_vent - vent_seg_cur; // delta
  73:calc.c        **** 		up = 1;
  74:calc.c        **** 	    } else {
  75:calc.c        **** 		seg_vent = vent_seg_cur - seg_vent; // delta
  76:calc.c        **** 	    }
  77:calc.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
  78:calc.c        **** 		switch_vent(up);
  79:calc.c        **** 	    }
  80:calc.c        **** 	}
  81:calc.c        **** 	vent_seg_cur = seg_v;
 1676               		.loc 3 81 0
 1677 05c4 C093 0000 		sts vent_seg_cur,r28
 1678 05c8 00C0      		rjmp .L52
 1679               	.LVL128:
 1680               	.L56:
 1681               	.LBB104:
  71:calc.c        **** 		seg_vent = seg_vent - vent_seg_cur; // delta
 1682               		.loc 3 71 0
 1683 05ca 8091 0000 		lds r24,vent_seg_cur
 1684 05ce 082E      		mov __tmp_reg__,r24
 1685 05d0 000C      		lsl r0
 1686 05d2 990B      		sbc r25,r25
 1687 05d4 8217      		cp r24,r18
 1688 05d6 9307      		cpc r25,r19
 1689 05d8 04F4      		brge .L61
  72:calc.c        **** 		up = 1;
 1690               		.loc 3 72 0
 1691 05da 8091 0000 		lds r24,vent_seg_cur
 1692 05de 1C2F      		mov r17,r28
 1693 05e0 181B      		sub r17,r24
 1694               	.LVL129:
  73:calc.c        **** 	    } else {
 1695               		.loc 3 73 0
 1696 05e2 FF24      		clr r15
 1697 05e4 F394      		inc r15
 1698 05e6 00C0      		rjmp .L62
 1699               	.LVL130:
 1700               	.L61:
  75:calc.c        **** 	    }
 1701               		.loc 3 75 0
 1702 05e8 1091 0000 		lds r17,vent_seg_cur
 1703 05ec 1C1B      		sub r17,r28
 1704               	.LVL131:
  70:calc.c        **** 	    if (seg_vent > vent_seg_cur) {
 1705               		.loc 3 70 0
 1706 05ee F12C      		mov r15,__zero_reg__
 1707               	.LVL132:
 1708               	.L62:
 1709               	.LBB105:
  77:calc.c        **** 		switch_vent(up);
 1710               		.loc 3 77 0
 1711 05f0 00E0      		ldi r16,0
 1712               	.LVL133:
 1713               	.L63:
  77:calc.c        **** 		switch_vent(up);
 1714               		.loc 3 77 0 is_stmt 0 discriminator 1
 1715 05f2 1017      		cp r17,r16
 1716 05f4 01F0      		breq .L65
  78:calc.c        **** 	    }
 1717               		.loc 3 78 0 is_stmt 1 discriminator 3
 1718 05f6 8F2D      		mov r24,r15
 1719 05f8 0E94 0000 		call switch_vent
 1720               	.LVL134:
  77:calc.c        **** 		switch_vent(up);
 1721               		.loc 3 77 0 discriminator 3
 1722 05fc 0F5F      		subi r16,lo8(-(1))
 1723               	.LVL135:
 1724 05fe 00C0      		rjmp .L63
 1725               	.LVL136:
 1726               	.L52:
 1727               	/* epilogue start */
 1728               	.LBE105:
 1729               	.LBE104:
 1730               	.LBE101:
  82:calc.c        ****     }
  83:calc.c        **** }
 1731               		.loc 3 83 0
 1732 0600 DF91      		pop r29
 1733 0602 CF91      		pop r28
 1734 0604 1F91      		pop r17
 1735 0606 0F91      		pop r16
 1736 0608 FF90      		pop r15
 1737 060a 0895      		ret
 1738               		.cfi_endproc
 1739               	.LFE34:
 1741               	.global	set_vent_prc
 1743               	set_vent_prc:
 1744               	.LFB35:
  84:calc.c        **** 
  85:calc.c        **** void set_vent_prc(uint8_t prc, int8_t full_sync)
  86:calc.c        **** {
 1745               		.loc 3 86 0
 1746               		.cfi_startproc
 1747               	.LVL137:
 1748 060c CF93      		push r28
 1749               	.LCFI80:
 1750               		.cfi_def_cfa_offset 3
 1751               		.cfi_offset 28, -2
 1752               	/* prologue: function */
 1753               	/* frame size = 0 */
 1754               	/* stack size = 1 */
 1755               	.L__stack_usage = 1
 1756 060e C62F      		mov r28,r22
  87:calc.c        ****     uint8_t seg_vent = prc2Seg(VENT_SEGs, prc);
 1757               		.loc 3 87 0
 1758 0610 682F      		mov r22,r24
 1759               	.LVL138:
 1760 0612 88E0      		ldi r24,lo8(8)
 1761               	.LVL139:
 1762 0614 0E94 0000 		call prc2Seg
 1763               	.LVL140:
  88:calc.c        ****     set_vent_seg(seg_vent, full_sync);
 1764               		.loc 3 88 0
 1765 0618 6C2F      		mov r22,r28
 1766               	/* epilogue start */
  89:calc.c        **** }
 1767               		.loc 3 89 0
 1768 061a CF91      		pop r28
 1769               	.LVL141:
  88:calc.c        ****     set_vent_seg(seg_vent, full_sync);
 1770               		.loc 3 88 0
 1771 061c 0C94 0000 		jmp set_vent_seg
 1772               	.LVL142:
 1773               		.cfi_endproc
 1774               	.LFE35:
 1776               	.global	set_temp
 1778               	set_temp:
 1779               	.LFB36:
  90:calc.c        **** 
  91:calc.c        **** void set_temp(uint8_t prc, int8_t full_sync)
  92:calc.c        **** {
 1780               		.loc 3 92 0
 1781               		.cfi_startproc
 1782               	.LVL143:
 1783 0620 0F93      		push r16
 1784               	.LCFI81:
 1785               		.cfi_def_cfa_offset 3
 1786               		.cfi_offset 16, -2
 1787 0622 1F93      		push r17
 1788               	.LCFI82:
 1789               		.cfi_def_cfa_offset 4
 1790               		.cfi_offset 17, -3
 1791 0624 CF93      		push r28
 1792               	.LCFI83:
 1793               		.cfi_def_cfa_offset 5
 1794               		.cfi_offset 28, -4
 1795 0626 DF93      		push r29
 1796               	.LCFI84:
 1797               		.cfi_def_cfa_offset 6
 1798               		.cfi_offset 29, -5
 1799               	/* prologue: function */
 1800               	/* frame size = 0 */
 1801               	/* stack size = 4 */
 1802               	.L__stack_usage = 4
 1803 0628 D62F      		mov r29,r22
  93:calc.c        ****     uint8_t seg_temp = prc2Seg(TEMP_SEGs, prc);
 1804               		.loc 3 93 0
 1805 062a 682F      		mov r22,r24
 1806               	.LVL144:
 1807 062c 8FE0      		ldi r24,lo8(15)
 1808               	.LVL145:
 1809 062e 0E94 0000 		call prc2Seg
 1810               	.LVL146:
 1811 0632 C82F      		mov r28,r24
 1812               	.LVL147:
  94:calc.c        **** 
  95:calc.c        ****     if (seg_temp == 0) { //add sync
 1813               		.loc 3 95 0
 1814 0634 8111      		cpse r24,__zero_reg__
 1815 0636 00C0      		rjmp .L69
  96:calc.c        **** 	switch_temp(0);
 1816               		.loc 3 96 0
 1817 0638 80E0      		ldi r24,0
 1818               	.LVL148:
 1819 063a 00C0      		rjmp .L86
 1820               	.LVL149:
 1821               	.L69:
  97:calc.c        ****     } else if (seg_temp == TEMP_SEGs) {
 1822               		.loc 3 97 0
 1823 063c 8F30      		cpi r24,lo8(15)
 1824 063e 01F4      		brne .L70
  98:calc.c        **** 	switch_temp(1);
 1825               		.loc 3 98 0
 1826 0640 81E0      		ldi r24,lo8(1)
 1827               	.LVL150:
 1828               	.L86:
 1829 0642 0E94 0000 		call switch_temp
 1830               	.LVL151:
 1831               	.L70:
  99:calc.c        ****     }
 100:calc.c        **** 
 101:calc.c        ****     if (temp_seg_cur != seg_temp) {
 1832               		.loc 3 101 0
 1833 0646 8091 0000 		lds r24,temp_seg_cur
 1834 064a 2C2F      		mov r18,r28
 1835 064c 30E0      		ldi r19,0
 1836 064e 082E      		mov __tmp_reg__,r24
 1837 0650 000C      		lsl r0
 1838 0652 990B      		sbc r25,r25
 1839 0654 8217      		cp r24,r18
 1840 0656 9307      		cpc r25,r19
 1841 0658 01F4      		brne .+2
 1842 065a 00C0      		rjmp .L68
 1843               	.LVL152:
 1844               	.LBB106:
 102:calc.c        **** 	uint8_t seg_t = seg_temp;
 103:calc.c        **** 	if (full_sync) {
 1845               		.loc 3 103 0
 1846 065c DD23      		tst r29
 1847 065e 01F0      		breq .L72
 1848               	.LBB107:
 104:calc.c        **** 	    int8_t up = (temp_seg_cur > TEMP_SEGs / 2);
 1849               		.loc 3 104 0
 1850 0660 1091 0000 		lds r17,temp_seg_cur
 1851 0664 01E0      		ldi r16,lo8(1)
 1852 0666 1830      		cpi r17,lo8(8)
 1853 0668 04F4      		brge .L73
 1854 066a 00E0      		ldi r16,0
 1855               	.L73:
 1856               	.LVL153:
 1857 066c D9E0      		ldi r29,lo8(9)
 1858               	.LVL154:
 1859               	.L74:
 1860               	.LBB108:
 105:calc.c        **** 	    for (uint8_t i = 0; i < TEMP_SEGs / 2 + 2; i++) {
 106:calc.c        **** 		switch_temp(up);
 1861               		.loc 3 106 0 discriminator 3
 1862 066e 802F      		mov r24,r16
 1863 0670 0E94 0000 		call switch_temp
 1864               	.LVL155:
 1865 0674 D150      		subi r29,lo8(-(-1))
 1866               	.LVL156:
 105:calc.c        **** 	    for (uint8_t i = 0; i < TEMP_SEGs / 2 + 2; i++) {
 1867               		.loc 3 105 0 discriminator 3
 1868 0676 01F4      		brne .L74
 1869               	.LBE108:
 107:calc.c        **** 	    }
 108:calc.c        **** 	    if (up) {
 1870               		.loc 3 108 0
 1871 0678 1830      		cpi r17,lo8(8)
 1872 067a 04F0      		brlt .L84
 109:calc.c        **** 		seg_temp = TEMP_SEGs - seg_temp;
 1873               		.loc 3 109 0
 1874 067c DFE0      		ldi r29,lo8(15)
 1875               	.LVL157:
 1876 067e DC1B      		sub r29,r28
 1877               	.LVL158:
 1878 0680 00C0      		rjmp .L75
 1879               	.LVL159:
 1880               	.L84:
 1881               	.LBE107:
 1882               	.LBE106:
  93:calc.c        **** 
 1883               		.loc 3 93 0
 1884 0682 DC2F      		mov r29,r28
 1885               	.LVL160:
 1886               	.L75:
 1887               	.LBB113:
 1888               	.LBB110:
 110:calc.c        **** 	    }
 111:calc.c        **** 	    up = !up;
 1889               		.loc 3 111 0
 1890 0684 01E0      		ldi r16,lo8(1)
 1891               	.LVL161:
 1892 0686 1830      		cpi r17,lo8(8)
 1893 0688 04F0      		brlt .L76
 1894 068a 00E0      		ldi r16,0
 1895               	.L76:
 1896               	.LVL162:
 112:calc.c        **** 	    delay_ms(DELAY_ENC_CKL_MS);
 1897               		.loc 3 112 0
 1898 068c 8EE1      		ldi r24,lo8(30)
 1899 068e 90E0      		ldi r25,0
 1900 0690 0E94 0000 		call delay_ms
 1901               	.LVL163:
 1902               	.LBB109:
 113:calc.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 1903               		.loc 3 113 0
 1904 0694 10E0      		ldi r17,0
 1905               	.LVL164:
 1906               	.L77:
 1907               		.loc 3 113 0 is_stmt 0 discriminator 1
 1908 0696 D117      		cp r29,r17
 1909 0698 01F0      		breq .L83
 114:calc.c        **** 		switch_temp(up);
 1910               		.loc 3 114 0 is_stmt 1 discriminator 3
 1911 069a 802F      		mov r24,r16
 1912 069c 0E94 0000 		call switch_temp
 1913               	.LVL165:
 113:calc.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 1914               		.loc 3 113 0 discriminator 3
 1915 06a0 1F5F      		subi r17,lo8(-(1))
 1916               	.LVL166:
 1917 06a2 00C0      		rjmp .L77
 1918               	.LVL167:
 1919               	.L83:
 1920               	.LBE109:
 1921               	.LBE110:
 115:calc.c        **** 	    }
 116:calc.c        **** 	} else {
 117:calc.c        **** 	    int8_t up = 0;
 118:calc.c        **** 	    if (seg_temp > temp_seg_cur) {
 119:calc.c        **** 		seg_temp = seg_temp - temp_seg_cur; // delta
 120:calc.c        **** 		up = 1;
 121:calc.c        **** 	    } else {
 122:calc.c        **** 		seg_temp = temp_seg_cur - seg_temp; // delta
 123:calc.c        **** 	    }
 124:calc.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 125:calc.c        **** 		switch_temp(up);
 126:calc.c        **** 	    }
 127:calc.c        **** 	}
 128:calc.c        **** 	temp_seg_cur = seg_t;
 1922               		.loc 3 128 0
 1923 06a4 C093 0000 		sts temp_seg_cur,r28
 1924 06a8 00C0      		rjmp .L68
 1925               	.LVL168:
 1926               	.L72:
 1927               	.LBB111:
 118:calc.c        **** 		seg_temp = seg_temp - temp_seg_cur; // delta
 1928               		.loc 3 118 0
 1929 06aa 8091 0000 		lds r24,temp_seg_cur
 1930 06ae 082E      		mov __tmp_reg__,r24
 1931 06b0 000C      		lsl r0
 1932 06b2 990B      		sbc r25,r25
 1933 06b4 8217      		cp r24,r18
 1934 06b6 9307      		cpc r25,r19
 1935 06b8 04F4      		brge .L79
 119:calc.c        **** 		up = 1;
 1936               		.loc 3 119 0
 1937 06ba 8091 0000 		lds r24,temp_seg_cur
 1938 06be DC2F      		mov r29,r28
 1939               	.LVL169:
 1940 06c0 D81B      		sub r29,r24
 1941               	.LVL170:
 120:calc.c        **** 	    } else {
 1942               		.loc 3 120 0
 1943 06c2 01E0      		ldi r16,lo8(1)
 1944 06c4 00C0      		rjmp .L80
 1945               	.LVL171:
 1946               	.L79:
 122:calc.c        **** 	    }
 1947               		.loc 3 122 0
 1948 06c6 D091 0000 		lds r29,temp_seg_cur
 1949               	.LVL172:
 1950 06ca DC1B      		sub r29,r28
 1951               	.LVL173:
 117:calc.c        **** 	    if (seg_temp > temp_seg_cur) {
 1952               		.loc 3 117 0
 1953 06cc 00E0      		ldi r16,0
 1954               	.LVL174:
 1955               	.L80:
 1956               	.LBB112:
 124:calc.c        **** 		switch_temp(up);
 1957               		.loc 3 124 0
 1958 06ce 10E0      		ldi r17,0
 1959               	.LVL175:
 1960               	.L81:
 124:calc.c        **** 		switch_temp(up);
 1961               		.loc 3 124 0 is_stmt 0 discriminator 1
 1962 06d0 D117      		cp r29,r17
 1963 06d2 01F0      		breq .L83
 125:calc.c        **** 	    }
 1964               		.loc 3 125 0 is_stmt 1 discriminator 3
 1965 06d4 802F      		mov r24,r16
 1966 06d6 0E94 0000 		call switch_temp
 1967               	.LVL176:
 124:calc.c        **** 		switch_temp(up);
 1968               		.loc 3 124 0 discriminator 3
 1969 06da 1F5F      		subi r17,lo8(-(1))
 1970               	.LVL177:
 1971 06dc 00C0      		rjmp .L81
 1972               	.LVL178:
 1973               	.L68:
 1974               	/* epilogue start */
 1975               	.LBE112:
 1976               	.LBE111:
 1977               	.LBE113:
 129:calc.c        ****     }
 130:calc.c        **** }
 1978               		.loc 3 130 0
 1979 06de DF91      		pop r29
 1980 06e0 CF91      		pop r28
 1981 06e2 1F91      		pop r17
 1982 06e4 0F91      		pop r16
 1983 06e6 0895      		ret
 1984               		.cfi_endproc
 1985               	.LFE36:
 1987               	.global	__floatsisf
 1988               	.global	__ltsf2
 1989               		.section	.rodata.str1.1
 1990               	.LC2:
 1991 0005 4D68 00   		.string	"Mh"
 1992               	.LC3:
 1993 0008 4D66 00   		.string	"Mf"
 1994               	.LC4:
 1995 000b 4D63 00   		.string	"Mc"
 1996               		.text
 1997               	.global	calcCond
 1999               	calcCond:
 2000               	.LFB37:
 131:calc.c        **** //****************************************************************************************
 132:calc.c        **** 
 133:calc.c        **** uint8_t cond_cicle = 0; // Время работы кондея в циклах (сейчас ци
 134:calc.c        **** 
 135:calc.c        **** void calcCond(void)
 136:calc.c        **** {
 2001               		.loc 3 136 0
 2002               		.cfi_startproc
 2003 06e8 CF92      		push r12
 2004               	.LCFI85:
 2005               		.cfi_def_cfa_offset 3
 2006               		.cfi_offset 12, -2
 2007 06ea DF92      		push r13
 2008               	.LCFI86:
 2009               		.cfi_def_cfa_offset 4
 2010               		.cfi_offset 13, -3
 2011 06ec EF92      		push r14
 2012               	.LCFI87:
 2013               		.cfi_def_cfa_offset 5
 2014               		.cfi_offset 14, -4
 2015 06ee FF92      		push r15
 2016               	.LCFI88:
 2017               		.cfi_def_cfa_offset 6
 2018               		.cfi_offset 15, -5
 2019 06f0 CF93      		push r28
 2020               	.LCFI89:
 2021               		.cfi_def_cfa_offset 7
 2022               		.cfi_offset 28, -6
 2023               	/* prologue: function */
 2024               	/* frame size = 0 */
 2025               	/* stack size = 5 */
 2026               	.L__stack_usage = 5
 137:calc.c        **** 
 138:calc.c        ****     //if (Ti > vars.setup_temp) {
 139:calc.c        **** //    if (Ti > (vars.setup_temp - COND_WORK_DELTA_T1)/* && Ts > (float) vars.setup_temp*/) {
 140:calc.c        ****     /*	CLR_FLAG(f_mode_hot);
 141:calc.c        ****      } else if (downHeadFlag > 0) {
 142:calc.c        ****      if (upHeadFlag == 0) {
 143:calc.c        ****      SET_FLAG(f_mode_hot);
 144:calc.c        ****      }
 145:calc.c        ****      } else if (upHeadFlag > 0) {
 146:calc.c        ****      CLR_FLAG(f_mode_hot);
 147:calc.c        ****      }
 148:calc.c        ****      */
 149:calc.c        ****     if (Ti > (vars.setup_temp + COND_UP_SETUP_T) || cond_needs_of_cool > 2) {
 2027               		.loc 3 149 0
 2028 06f2 6091 0000 		lds r22,vars+1
 2029 06f6 C090 0000 		lds r12,Ti
 2030 06fa D090 0000 		lds r13,Ti+1
 2031 06fe E090 0000 		lds r14,Ti+2
 2032 0702 F090 0000 		lds r15,Ti+3
 2033 0706 062E      		mov __tmp_reg__,r22
 2034 0708 000C      		lsl r0
 2035 070a 770B      		sbc r23,r23
 2036 070c 880B      		sbc r24,r24
 2037 070e 990B      		sbc r25,r25
 2038 0710 0E94 0000 		call __floatsisf
 2039               	.LVL179:
 2040 0714 20E0      		ldi r18,0
 2041 0716 30E0      		ldi r19,0
 2042 0718 40E0      		ldi r20,0
 2043 071a 50E4      		ldi r21,lo8(64)
 2044 071c 0E94 0000 		call __addsf3
 2045               	.LVL180:
 2046 0720 A701      		movw r20,r14
 2047 0722 9601      		movw r18,r12
 2048 0724 0E94 0000 		call __ltsf2
 2049               	.LVL181:
 2050 0728 87FD      		sbrc r24,7
 2051 072a 00C0      		rjmp .L88
 2052               		.loc 3 149 0 is_stmt 0 discriminator 1
 2053 072c 8091 0000 		lds r24,cond_needs_of_cool
 2054 0730 8330      		cpi r24,lo8(3)
 2055 0732 04F0      		brlt .L89
 2056               	.L88:
 150:calc.c        **** 	CLR_FLAG(f_mode_hot);
 2057               		.loc 3 150 0 is_stmt 1
 2058 0734 8091 0000 		lds r24,flags
 2059 0738 8D7F      		andi r24,lo8(-3)
 2060 073a 00C0      		rjmp .L104
 2061               	.L89:
 151:calc.c        ****     } else {
 152:calc.c        **** 	SET_FLAG(f_mode_hot);
 2062               		.loc 3 152 0
 2063 073c 8091 0000 		lds r24,flags
 2064 0740 8260      		ori r24,lo8(2)
 2065               	.L104:
 2066 0742 8093 0000 		sts flags,r24
 2067               	.LVL182:
 153:calc.c        ****     }
 154:calc.c        **** 
 155:calc.c        ****     char c_on = 0;
 156:calc.c        ****     if (TST_FLAG(f_mode_frost_cicle_on)) {
 2068               		.loc 3 156 0
 2069 0746 8091 0000 		lds r24,flags
 157:calc.c        **** 	//if (Ti > (vars.setup_temp - COND_WORK_DELTA_T * 2) || cond_cicle < 5) {
 158:calc.c        **** 	if (Ts > vars.setup_temp || cond_cicle < 5 || temp_out_prc < 10) {
 2070               		.loc 3 158 0
 2071 074a 6091 0000 		lds r22,vars+1
 156:calc.c        **** 	//if (Ti > (vars.setup_temp - COND_WORK_DELTA_T * 2) || cond_cicle < 5) {
 2072               		.loc 3 156 0
 2073 074e 82FF      		sbrs r24,2
 2074 0750 00C0      		rjmp .L91
 2075               		.loc 3 158 0
 2076 0752 C090 0000 		lds r12,Ts
 2077 0756 D090 0000 		lds r13,Ts+1
 2078 075a E090 0000 		lds r14,Ts+2
 2079 075e F090 0000 		lds r15,Ts+3
 2080 0762 062E      		mov __tmp_reg__,r22
 2081 0764 000C      		lsl r0
 2082 0766 770B      		sbc r23,r23
 2083 0768 880B      		sbc r24,r24
 2084 076a 990B      		sbc r25,r25
 2085 076c 0E94 0000 		call __floatsisf
 2086               	.LVL183:
 2087 0770 A701      		movw r20,r14
 2088 0772 9601      		movw r18,r12
 2089 0774 0E94 0000 		call __ltsf2
 2090               	.LVL184:
 2091 0778 87FD      		sbrc r24,7
 2092 077a 00C0      		rjmp .L92
 2093               		.loc 3 158 0 is_stmt 0 discriminator 1
 2094 077c 8091 0000 		lds r24,cond_cicle
 2095 0780 8530      		cpi r24,lo8(5)
 2096 0782 00F4      		brsh .+2
 2097 0784 00C0      		rjmp .L92
 2098               		.loc 3 158 0 discriminator 2
 2099 0786 8091 0000 		lds r24,temp_out_prc
 2100 078a 8A30      		cpi r24,lo8(10)
 2101 078c 00F4      		brsh .+2
 2102 078e 00C0      		rjmp .L92
 2103 0790 00C0      		rjmp .L93
 2104               	.L91:
 159:calc.c        **** 	    c_on = 1;
 160:calc.c        **** 	}
 161:calc.c        ****     } else {
 162:calc.c        **** 	if (Ti > (vars.setup_temp - COND_WORK_DELTA_T) && Ts > (vars.setup_temp - COND_OVERCOOL_DELTA_T)) 
 2105               		.loc 3 162 0 is_stmt 1
 2106 0792 C090 0000 		lds r12,Ti
 2107 0796 D090 0000 		lds r13,Ti+1
 2108 079a E090 0000 		lds r14,Ti+2
 2109 079e F090 0000 		lds r15,Ti+3
 2110 07a2 062E      		mov __tmp_reg__,r22
 2111 07a4 000C      		lsl r0
 2112 07a6 770B      		sbc r23,r23
 2113 07a8 6550      		subi r22,5
 2114 07aa 7109      		sbc r23,__zero_reg__
 2115 07ac 072E      		mov __tmp_reg__,r23
 2116 07ae 000C      		lsl r0
 2117 07b0 880B      		sbc r24,r24
 2118 07b2 990B      		sbc r25,r25
 2119 07b4 0E94 0000 		call __floatsisf
 2120               	.LVL185:
 2121 07b8 A701      		movw r20,r14
 2122 07ba 9601      		movw r18,r12
 2123 07bc 0E94 0000 		call __ltsf2
 2124               	.LVL186:
 2125 07c0 87FF      		sbrs r24,7
 2126 07c2 00C0      		rjmp .L93
 2127               		.loc 3 162 0 is_stmt 0 discriminator 1
 2128 07c4 6091 0000 		lds r22,vars+1
 2129 07c8 C090 0000 		lds r12,Ts
 2130 07cc D090 0000 		lds r13,Ts+1
 2131 07d0 E090 0000 		lds r14,Ts+2
 2132 07d4 F090 0000 		lds r15,Ts+3
 2133 07d8 062E      		mov __tmp_reg__,r22
 2134 07da 000C      		lsl r0
 2135 07dc 770B      		sbc r23,r23
 2136 07de 880B      		sbc r24,r24
 2137 07e0 990B      		sbc r25,r25
 2138 07e2 0E94 0000 		call __floatsisf
 2139               	.LVL187:
 2140 07e6 A701      		movw r20,r14
 2141 07e8 9601      		movw r18,r12
 2142 07ea 0E94 0000 		call __ltsf2
 2143               	.LVL188:
 2144 07ee 87FD      		sbrc r24,7
 2145 07f0 00C0      		rjmp .L92
 2146               	.LVL189:
 2147               	.L93:
 163:calc.c        **** 	    c_on = 1;
 164:calc.c        **** 	}
 165:calc.c        ****     }
 166:calc.c        **** 
 167:calc.c        ****     if (c_on && Ti > vars.const_cnd_frost_t) {
 168:calc.c        **** 	SET_FLAG(f_mode_frost_cicle_on);
 169:calc.c        ****     } else {
 170:calc.c        **** 	CLR_FLAG(f_mode_frost_cicle_on);
 2148               		.loc 3 170 0 is_stmt 1
 2149 07f2 8091 0000 		lds r24,flags
 2150 07f6 8B7F      		andi r24,lo8(-5)
 2151               	.L105:
 2152 07f8 8093 0000 		sts flags,r24
 2153               	.LVL190:
 171:calc.c        ****     }
 172:calc.c        **** 
 173:calc.c        ****     char mode_cond_on = 0;
 174:calc.c        ****     if ((!TST_FLAG(f_mode_hot) || test_cond_ON()) && TST_FLAG(f_mode_frost_cicle_on)) {
 2154               		.loc 3 174 0
 2155 07fc 8091 0000 		lds r24,flags
 2156 0800 81FD      		sbrc r24,1
 2157 0802 00C0      		rjmp .L96
 2158               	.L99:
 2159 0804 8091 0000 		lds r24,flags
 2160 0808 82FD      		sbrc r24,2
 2161 080a 00C0      		rjmp .L97
 2162 080c 00C0      		rjmp .L98
 2163               	.L96:
 2164               		.loc 3 174 0 is_stmt 0 discriminator 2
 2165 080e 0E94 0000 		call test_cond_ON
 2166               	.LVL191:
 2167 0812 8111      		cpse r24,__zero_reg__
 2168 0814 00C0      		rjmp .L99
 2169 0816 00C0      		rjmp .L98
 2170               	.L97:
 2171               	.LVL192:
 175:calc.c        **** 	mode_cond_on = 1;
 176:calc.c        **** 	if (cond_cicle < 64)
 2172               		.loc 3 176 0 is_stmt 1
 2173 0818 8091 0000 		lds r24,cond_cicle
 2174 081c 8034      		cpi r24,lo8(64)
 2175 081e 00F4      		brsh .L102
 177:calc.c        **** 	    cond_cicle++;
 2176               		.loc 3 177 0
 2177 0820 8F5F      		subi r24,lo8(-(1))
 2178 0822 8093 0000 		sts cond_cicle,r24
 2179 0826 00C0      		rjmp .L102
 2180               	.LVL193:
 2181               	.L98:
 178:calc.c        ****     } else {
 179:calc.c        **** 	cond_cicle = 0;
 2182               		.loc 3 179 0
 2183 0828 1092 0000 		sts cond_cicle,__zero_reg__
 173:calc.c        ****     if ((!TST_FLAG(f_mode_hot) || test_cond_ON()) && TST_FLAG(f_mode_frost_cicle_on)) {
 2184               		.loc 3 173 0
 2185 082c C0E0      		ldi r28,0
 2186 082e 00C0      		rjmp .L100
 2187               	.LVL194:
 2188               	.L102:
 175:calc.c        **** 	if (cond_cicle < 64)
 2189               		.loc 3 175 0
 2190 0830 C1E0      		ldi r28,lo8(1)
 2191               	.LVL195:
 2192               	.L100:
 180:calc.c        ****     }
 181:calc.c        **** 
 182:calc.c        ****     switch_cond(mode_cond_on);
 2193               		.loc 3 182 0
 2194 0832 8C2F      		mov r24,r28
 2195 0834 0E94 0000 		call switch_cond
 2196               	.LVL196:
 183:calc.c        **** 
 184:calc.c        ****     int_to_uart("Mh", TST_FLAG(f_mode_hot));
 2197               		.loc 3 184 0
 2198 0838 6091 0000 		lds r22,flags
 2199 083c 6270      		andi r22,lo8(2)
 2200 083e 70E0      		ldi r23,0
 2201 0840 80E0      		ldi r24,lo8(.LC2)
 2202 0842 90E0      		ldi r25,hi8(.LC2)
 2203 0844 0E94 0000 		call int_to_uart
 2204               	.LVL197:
 185:calc.c        ****     int_to_uart("Mf", TST_FLAG(f_mode_frost_cicle_on));
 2205               		.loc 3 185 0
 2206 0848 6091 0000 		lds r22,flags
 2207 084c 6470      		andi r22,lo8(4)
 2208 084e 70E0      		ldi r23,0
 2209 0850 80E0      		ldi r24,lo8(.LC3)
 2210 0852 90E0      		ldi r25,hi8(.LC3)
 2211 0854 0E94 0000 		call int_to_uart
 2212               	.LVL198:
 186:calc.c        ****     int_to_uart("Mc", mode_cond_on);
 2213               		.loc 3 186 0
 2214 0858 6C2F      		mov r22,r28
 2215 085a 70E0      		ldi r23,0
 2216 085c 80E0      		ldi r24,lo8(.LC4)
 2217 085e 90E0      		ldi r25,hi8(.LC4)
 2218               	/* epilogue start */
 187:calc.c        **** }
 2219               		.loc 3 187 0
 2220 0860 CF91      		pop r28
 2221               	.LVL199:
 2222 0862 FF90      		pop r15
 2223 0864 EF90      		pop r14
 2224 0866 DF90      		pop r13
 2225 0868 CF90      		pop r12
 186:calc.c        ****     int_to_uart("Mc", mode_cond_on);
 2226               		.loc 3 186 0
 2227 086a 0C94 0000 		jmp int_to_uart
 2228               	.LVL200:
 2229               	.L92:
 167:calc.c        **** 	SET_FLAG(f_mode_frost_cicle_on);
 2230               		.loc 3 167 0
 2231 086e 6091 0000 		lds r22,vars+8
 2232 0872 C090 0000 		lds r12,Ti
 2233 0876 D090 0000 		lds r13,Ti+1
 2234 087a E090 0000 		lds r14,Ti+2
 2235 087e F090 0000 		lds r15,Ti+3
 2236 0882 062E      		mov __tmp_reg__,r22
 2237 0884 000C      		lsl r0
 2238 0886 770B      		sbc r23,r23
 2239 0888 880B      		sbc r24,r24
 2240 088a 990B      		sbc r25,r25
 2241 088c 0E94 0000 		call __floatsisf
 2242               	.LVL201:
 2243 0890 A701      		movw r20,r14
 2244 0892 9601      		movw r18,r12
 2245 0894 0E94 0000 		call __ltsf2
 2246               	.LVL202:
 2247 0898 87FF      		sbrs r24,7
 2248 089a 00C0      		rjmp .L93
 168:calc.c        ****     } else {
 2249               		.loc 3 168 0
 2250 089c 8091 0000 		lds r24,flags
 2251 08a0 8460      		ori r24,lo8(4)
 2252 08a2 00C0      		rjmp .L105
 2253               		.cfi_endproc
 2254               	.LFE37:
 2256               		.section	.rodata.str1.1
 2257               	.LC5:
 2258 000e 5661 00   		.string	"Va"
 2259               		.text
 2260               	.global	calcVent
 2262               	calcVent:
 2263               	.LFB38:
 188:calc.c        **** 
 189:calc.c        **** void calcVent(float id)
 190:calc.c        **** {
 2264               		.loc 3 190 0
 2265               		.cfi_startproc
 2266               	.LVL203:
 2267 08a4 4F92      		push r4
 2268               	.LCFI90:
 2269               		.cfi_def_cfa_offset 3
 2270               		.cfi_offset 4, -2
 2271 08a6 5F92      		push r5
 2272               	.LCFI91:
 2273               		.cfi_def_cfa_offset 4
 2274               		.cfi_offset 5, -3
 2275 08a8 6F92      		push r6
 2276               	.LCFI92:
 2277               		.cfi_def_cfa_offset 5
 2278               		.cfi_offset 6, -4
 2279 08aa 7F92      		push r7
 2280               	.LCFI93:
 2281               		.cfi_def_cfa_offset 6
 2282               		.cfi_offset 7, -5
 2283 08ac 8F92      		push r8
 2284               	.LCFI94:
 2285               		.cfi_def_cfa_offset 7
 2286               		.cfi_offset 8, -6
 2287 08ae 9F92      		push r9
 2288               	.LCFI95:
 2289               		.cfi_def_cfa_offset 8
 2290               		.cfi_offset 9, -7
 2291 08b0 AF92      		push r10
 2292               	.LCFI96:
 2293               		.cfi_def_cfa_offset 9
 2294               		.cfi_offset 10, -8
 2295 08b2 BF92      		push r11
 2296               	.LCFI97:
 2297               		.cfi_def_cfa_offset 10
 2298               		.cfi_offset 11, -9
 2299 08b4 CF92      		push r12
 2300               	.LCFI98:
 2301               		.cfi_def_cfa_offset 11
 2302               		.cfi_offset 12, -10
 2303 08b6 DF92      		push r13
 2304               	.LCFI99:
 2305               		.cfi_def_cfa_offset 12
 2306               		.cfi_offset 13, -11
 2307 08b8 EF92      		push r14
 2308               	.LCFI100:
 2309               		.cfi_def_cfa_offset 13
 2310               		.cfi_offset 14, -12
 2311 08ba FF92      		push r15
 2312               	.LCFI101:
 2313               		.cfi_def_cfa_offset 14
 2314               		.cfi_offset 15, -13
 2315 08bc 0F93      		push r16
 2316               	.LCFI102:
 2317               		.cfi_def_cfa_offset 15
 2318               		.cfi_offset 16, -14
 2319 08be 1F93      		push r17
 2320               	.LCFI103:
 2321               		.cfi_def_cfa_offset 16
 2322               		.cfi_offset 17, -15
 2323               	/* prologue: function */
 2324               	/* frame size = 0 */
 2325               	/* stack size = 14 */
 2326               	.L__stack_usage = 14
 2327 08c0 6B01      		movw r12,r22
 2328 08c2 7C01      		movw r14,r24
 191:calc.c        ****     float vent_nom_prc = seg2Prc(VENT_SEGs, vars.vent_nom_seg);
 2329               		.loc 3 191 0
 2330 08c4 6091 0000 		lds r22,vars+2
 2331               	.LVL204:
 2332 08c8 84E6      		ldi r24,lo8(100)
 2333 08ca 689F      		mul r22,r24
 2334 08cc B001      		movw r22,r0
 2335 08ce 1124      		clr __zero_reg__
 2336               	.LVL205:
 2337 08d0 93E0      		ldi r25,3
 2338               		1:
 2339 08d2 7595      		asr r23
 2340 08d4 6795      		ror r22
 2341 08d6 9A95      		dec r25
 2342 08d8 01F4      		brne 1b
 2343 08da 70E0      		ldi r23,0
 2344 08dc 80E0      		ldi r24,0
 2345 08de 90E0      		ldi r25,0
 2346 08e0 0E94 0000 		call __floatunsisf
 2347               	.LVL206:
 2348 08e4 2B01      		movw r4,r22
 2349 08e6 3C01      		movw r6,r24
 2350               	.LVL207:
 192:calc.c        ****     //delta = (delta / (float) vars.setup_temp) * (float) VENT_ADD_CTRL_CFC;
 193:calc.c        **** 
 194:calc.c        ****     float p = last_delta * (float) vars.vent_var_kfc/* * (float) vars.pid_P_kfc*/;
 2351               		.loc 3 194 0
 2352 08e8 6091 0000 		lds r22,vars+6
 2353 08ec 8090 0000 		lds r8,last_delta
 2354 08f0 9090 0000 		lds r9,last_delta+1
 2355 08f4 A090 0000 		lds r10,last_delta+2
 2356 08f8 B090 0000 		lds r11,last_delta+3
 2357 08fc 062E      		mov __tmp_reg__,r22
 2358 08fe 000C      		lsl r0
 2359 0900 770B      		sbc r23,r23
 2360 0902 880B      		sbc r24,r24
 2361 0904 990B      		sbc r25,r25
 2362 0906 0E94 0000 		call __floatsisf
 2363               	.LVL208:
 2364 090a A501      		movw r20,r10
 2365 090c 9401      		movw r18,r8
 2366 090e 0E94 0000 		call __mulsf3
 2367               	.LVL209:
 2368 0912 4B01      		movw r8,r22
 2369 0914 5C01      		movw r10,r24
 2370               	.LVL210:
 195:calc.c        ****     //float_to_uart("Vp", p);
 196:calc.c        **** 
 197:calc.c        ****     if (id < 0.0f) {
 2371               		.loc 3 197 0
 2372 0916 20E0      		ldi r18,0
 2373 0918 30E0      		ldi r19,0
 2374 091a A901      		movw r20,r18
 2375 091c C701      		movw r24,r14
 2376 091e B601      		movw r22,r12
 2377 0920 0E94 0000 		call __ltsf2
 2378               	.LVL211:
 2379 0924 87FF      		sbrs r24,7
 2380 0926 00C0      		rjmp .L107
 198:calc.c        **** 	p = -p;
 2381               		.loc 3 198 0
 2382 0928 B7FA      		bst r11,7
 2383 092a B094      		com r11
 2384 092c B7F8      		bld r11,7
 2385 092e B094      		com r11
 2386               	.LVL212:
 2387               	.L107:
 199:calc.c        ****     }
 200:calc.c        **** 
 201:calc.c        ****     float rng = vent_nom_prc / 2.0f;
 2388               		.loc 3 201 0
 2389 0930 20E0      		ldi r18,0
 2390 0932 30E0      		ldi r19,0
 2391 0934 40E0      		ldi r20,0
 2392 0936 5FE3      		ldi r21,lo8(63)
 2393 0938 C301      		movw r24,r6
 2394 093a B201      		movw r22,r4
 2395 093c 0E94 0000 		call __mulsf3
 2396               	.LVL213:
 2397 0940 7B01      		movw r14,r22
 2398 0942 8C01      		movw r16,r24
 2399               	.LVL214:
 202:calc.c        ****     p = check_rangef(-rng, p, rng);
 2400               		.loc 3 202 0
 2401 0944 9058      		subi r25,0x80
 2402 0946 A501      		movw r20,r10
 2403 0948 9401      		movw r18,r8
 2404 094a 0E94 0000 		call check_rangef
 2405               	.LVL215:
 2406 094e 9B01      		movw r18,r22
 2407 0950 AC01      		movw r20,r24
 2408               	.LVL216:
 203:calc.c        ****     //float_to_uart("Vn", p);
 204:calc.c        **** 
 205:calc.c        ****     vent_add_prc = check_rangef(0.0f, p + vent_nom_prc, 100.0f);
 2409               		.loc 3 205 0
 2410 0952 C301      		movw r24,r6
 2411 0954 B201      		movw r22,r4
 2412 0956 0E94 0000 		call __addsf3
 2413               	.LVL217:
 2414 095a 9B01      		movw r18,r22
 2415 095c AC01      		movw r20,r24
 2416 095e E12C      		mov r14,__zero_reg__
 2417 0960 F12C      		mov r15,__zero_reg__
 2418 0962 08EC      		ldi r16,lo8(-56)
 2419 0964 12E4      		ldi r17,lo8(66)
 2420               	.LVL218:
 2421 0966 60E0      		ldi r22,0
 2422 0968 70E0      		ldi r23,0
 2423 096a CB01      		movw r24,r22
 2424 096c 0E94 0000 		call check_rangef
 2425               	.LVL219:
 2426 0970 0E94 0000 		call __fixsfsi
 2427               	.LVL220:
 2428 0974 6093 0000 		sts vent_add_prc,r22
 206:calc.c        ****     int_to_uart("Va", vent_add_prc);
 2429               		.loc 3 206 0
 2430 0978 6091 0000 		lds r22,vent_add_prc
 2431 097c 062E      		mov __tmp_reg__,r22
 2432 097e 000C      		lsl r0
 2433 0980 770B      		sbc r23,r23
 2434 0982 80E0      		ldi r24,lo8(.LC5)
 2435 0984 90E0      		ldi r25,hi8(.LC5)
 2436               	/* epilogue start */
 207:calc.c        **** }
 2437               		.loc 3 207 0
 2438 0986 1F91      		pop r17
 2439 0988 0F91      		pop r16
 2440 098a FF90      		pop r15
 2441 098c EF90      		pop r14
 2442 098e DF90      		pop r13
 2443 0990 CF90      		pop r12
 2444               	.LVL221:
 2445 0992 BF90      		pop r11
 2446 0994 AF90      		pop r10
 2447 0996 9F90      		pop r9
 2448 0998 8F90      		pop r8
 2449 099a 7F90      		pop r7
 2450 099c 6F90      		pop r6
 2451 099e 5F90      		pop r5
 2452 09a0 4F90      		pop r4
 2453               	.LVL222:
 206:calc.c        ****     int_to_uart("Va", vent_add_prc);
 2454               		.loc 3 206 0
 2455 09a2 0C94 0000 		jmp int_to_uart
 2456               	.LVL223:
 2457               		.cfi_endproc
 2458               	.LFE38:
 2460               		.section	.rodata.str1.1
 2461               	.LC6:
 2462 0011 5469 00   		.string	"Ti"
 2463               	.LC7:
 2464 0014 5473 00   		.string	"Ts"
 2465               	.LC8:
 2466 0017 5374 00   		.string	"St"
 2467               	.LC9:
 2468 001a 6C44 00   		.string	"lD"
 2469               	.LC10:
 2470 001d 4474 00   		.string	"Dt"
 2471               	.LC11:
 2472 0020 4964 00   		.string	"Id"
 2473               	.global	__gtsf2
 2474               	.LC12:
 2475 0023 4970 00   		.string	"Ip"
 2476               	.LC13:
 2477 0026 7069 6400 		.string	"pid"
 2478               	.LC14:
 2479 002a 434F 00   		.string	"CO"
 2480               	.global	__fixunssfsi
 2481               	.LC15:
 2482 002d 6F75 7400 		.string	"out"
 2483               		.text
 2484               	.global	calcVal
 2486               	calcVal:
 2487               	.LFB39:
 208:calc.c        **** 
 209:calc.c        **** void calcVal(void)
 210:calc.c        **** {
 2488               		.loc 3 210 0
 2489               		.cfi_startproc
 2490 09a6 4F92      		push r4
 2491               	.LCFI104:
 2492               		.cfi_def_cfa_offset 3
 2493               		.cfi_offset 4, -2
 2494 09a8 5F92      		push r5
 2495               	.LCFI105:
 2496               		.cfi_def_cfa_offset 4
 2497               		.cfi_offset 5, -3
 2498 09aa 6F92      		push r6
 2499               	.LCFI106:
 2500               		.cfi_def_cfa_offset 5
 2501               		.cfi_offset 6, -4
 2502 09ac 7F92      		push r7
 2503               	.LCFI107:
 2504               		.cfi_def_cfa_offset 6
 2505               		.cfi_offset 7, -5
 2506 09ae 8F92      		push r8
 2507               	.LCFI108:
 2508               		.cfi_def_cfa_offset 7
 2509               		.cfi_offset 8, -6
 2510 09b0 9F92      		push r9
 2511               	.LCFI109:
 2512               		.cfi_def_cfa_offset 8
 2513               		.cfi_offset 9, -7
 2514 09b2 AF92      		push r10
 2515               	.LCFI110:
 2516               		.cfi_def_cfa_offset 9
 2517               		.cfi_offset 10, -8
 2518 09b4 BF92      		push r11
 2519               	.LCFI111:
 2520               		.cfi_def_cfa_offset 10
 2521               		.cfi_offset 11, -9
 2522 09b6 CF92      		push r12
 2523               	.LCFI112:
 2524               		.cfi_def_cfa_offset 11
 2525               		.cfi_offset 12, -10
 2526 09b8 DF92      		push r13
 2527               	.LCFI113:
 2528               		.cfi_def_cfa_offset 12
 2529               		.cfi_offset 13, -11
 2530 09ba EF92      		push r14
 2531               	.LCFI114:
 2532               		.cfi_def_cfa_offset 13
 2533               		.cfi_offset 14, -12
 2534 09bc FF92      		push r15
 2535               	.LCFI115:
 2536               		.cfi_def_cfa_offset 14
 2537               		.cfi_offset 15, -13
 2538 09be 0F93      		push r16
 2539               	.LCFI116:
 2540               		.cfi_def_cfa_offset 15
 2541               		.cfi_offset 16, -14
 2542 09c0 1F93      		push r17
 2543               	.LCFI117:
 2544               		.cfi_def_cfa_offset 16
 2545               		.cfi_offset 17, -15
 2546 09c2 CF93      		push r28
 2547               	.LCFI118:
 2548               		.cfi_def_cfa_offset 17
 2549               		.cfi_offset 28, -16
 2550 09c4 DF93      		push r29
 2551               	.LCFI119:
 2552               		.cfi_def_cfa_offset 18
 2553               		.cfi_offset 29, -17
 2554 09c6 00D0      		rcall .
 2555 09c8 00D0      		rcall .
 2556 09ca 1F92      		push __zero_reg__
 2557               	.LCFI120:
 2558               		.cfi_def_cfa_offset 23
 2559 09cc CDB7      		in r28,__SP_L__
 2560 09ce DEB7      		in r29,__SP_H__
 2561               	.LCFI121:
 2562               		.cfi_def_cfa_register 28
 2563               	/* prologue: function */
 2564               	/* frame size = 5 */
 2565               	/* stack size = 21 */
 2566               	.L__stack_usage = 21
 211:calc.c        ****     if (bootUp_delay < 4) {  // Инициализация некоторых значений пр
 2567               		.loc 3 211 0
 2568 09d0 8091 0000 		lds r24,bootUp_delay
 2569 09d4 8430      		cpi r24,lo8(4)
 2570 09d6 00F0      		brlo .+2
 2571 09d8 00C0      		rjmp .L111
 212:calc.c        **** 	if (bootUp_delay < 2) {
 2572               		.loc 3 212 0
 2573 09da 8091 0000 		lds r24,bootUp_delay
 2574 09de 8230      		cpi r24,lo8(2)
 2575 09e0 00F0      		brlo .+2
 2576 09e2 00C0      		rjmp .L112
 213:calc.c        **** 	    Ipid = (Ts - Ti);
 2577               		.loc 3 213 0
 2578 09e4 6091 0000 		lds r22,Ts
 2579 09e8 7091 0000 		lds r23,Ts+1
 2580 09ec 8091 0000 		lds r24,Ts+2
 2581 09f0 9091 0000 		lds r25,Ts+3
 2582 09f4 2091 0000 		lds r18,Ti
 2583 09f8 3091 0000 		lds r19,Ti+1
 2584 09fc 4091 0000 		lds r20,Ti+2
 2585 0a00 5091 0000 		lds r21,Ti+3
 2586 0a04 0E94 0000 		call __subsf3
 2587               	.LVL224:
 2588 0a08 6093 0000 		sts Ipid,r22
 2589 0a0c 7093 0000 		sts Ipid+1,r23
 2590 0a10 8093 0000 		sts Ipid+2,r24
 2591 0a14 9093 0000 		sts Ipid+3,r25
 214:calc.c        **** 	    if (Ipid < 0) {
 2592               		.loc 3 214 0
 2593 0a18 6091 0000 		lds r22,Ipid
 2594 0a1c 7091 0000 		lds r23,Ipid+1
 2595 0a20 8091 0000 		lds r24,Ipid+2
 2596 0a24 9091 0000 		lds r25,Ipid+3
 2597 0a28 20E0      		ldi r18,0
 2598 0a2a 30E0      		ldi r19,0
 2599 0a2c A901      		movw r20,r18
 2600 0a2e 0E94 0000 		call __ltsf2
 2601               	.LVL225:
 2602 0a32 87FF      		sbrs r24,7
 2603 0a34 00C0      		rjmp .L138
 215:calc.c        **** 		Ipid = 0;
 2604               		.loc 3 215 0
 2605 0a36 1092 0000 		sts Ipid,__zero_reg__
 2606 0a3a 1092 0000 		sts Ipid+1,__zero_reg__
 2607 0a3e 1092 0000 		sts Ipid+2,__zero_reg__
 2608 0a42 1092 0000 		sts Ipid+3,__zero_reg__
 2609 0a46 00C0      		rjmp .L112
 2610               	.L138:
 216:calc.c        **** 	    } else {
 217:calc.c        **** 		Ipid = Ipid * 2.0f;
 2611               		.loc 3 217 0
 2612 0a48 6091 0000 		lds r22,Ipid
 2613 0a4c 7091 0000 		lds r23,Ipid+1
 2614 0a50 8091 0000 		lds r24,Ipid+2
 2615 0a54 9091 0000 		lds r25,Ipid+3
 2616 0a58 9B01      		movw r18,r22
 2617 0a5a AC01      		movw r20,r24
 2618 0a5c 0E94 0000 		call __addsf3
 2619               	.LVL226:
 2620 0a60 6093 0000 		sts Ipid,r22
 2621 0a64 7093 0000 		sts Ipid+1,r23
 2622 0a68 8093 0000 		sts Ipid+2,r24
 2623 0a6c 9093 0000 		sts Ipid+3,r25
 2624               	.L112:
 218:calc.c        **** 	    }
 219:calc.c        **** 	}
 220:calc.c        **** 
 221:calc.c        **** 	//SET_FLAG(f_mode_hot);
 222:calc.c        **** 	switch_cond(0);
 2625               		.loc 3 222 0
 2626 0a70 80E0      		ldi r24,0
 2627 0a72 0E94 0000 		call switch_cond
 2628               	.LVL227:
 223:calc.c        **** 	bootUp_delay++;
 2629               		.loc 3 223 0
 2630 0a76 8091 0000 		lds r24,bootUp_delay
 2631 0a7a 8F5F      		subi r24,lo8(-(1))
 2632 0a7c 8093 0000 		sts bootUp_delay,r24
 2633 0a80 00C0      		rjmp .L115
 2634               	.L111:
 224:calc.c        ****     } else {
 225:calc.c        **** 	calcCond();
 2635               		.loc 3 225 0
 2636 0a82 0E94 0000 		call calcCond
 2637               	.LVL228:
 2638               	.L115:
 226:calc.c        ****     }
 227:calc.c        **** 
 228:calc.c        ****     float_to_uart("Ti", Ti);
 2639               		.loc 3 228 0
 2640 0a86 6091 0000 		lds r22,Ti
 2641 0a8a 7091 0000 		lds r23,Ti+1
 2642 0a8e 8091 0000 		lds r24,Ti+2
 2643 0a92 9091 0000 		lds r25,Ti+3
 2644               	.LVL229:
 2645               	.LBB114:
 2646               	.LBB115:
  43:main.c        ****     /*    USART_SendStr(id);
 2647               		.loc 1 43 0
 2648 0a96 0E94 0000 		call __fixsfsi
 2649               	.LVL230:
 2650 0a9a 80E0      		ldi r24,lo8(.LC6)
 2651 0a9c 90E0      		ldi r25,hi8(.LC6)
 2652 0a9e 0E94 0000 		call int_to_uart
 2653               	.LVL231:
 2654               	.LBE115:
 2655               	.LBE114:
 229:calc.c        ****     float_to_uart("Ts", Ts);
 2656               		.loc 3 229 0
 2657 0aa2 6091 0000 		lds r22,Ts
 2658 0aa6 7091 0000 		lds r23,Ts+1
 2659 0aaa 8091 0000 		lds r24,Ts+2
 2660 0aae 9091 0000 		lds r25,Ts+3
 2661               	.LVL232:
 2662               	.LBB116:
 2663               	.LBB117:
  43:main.c        ****     /*    USART_SendStr(id);
 2664               		.loc 1 43 0
 2665 0ab2 0E94 0000 		call __fixsfsi
 2666               	.LVL233:
 2667 0ab6 80E0      		ldi r24,lo8(.LC7)
 2668 0ab8 90E0      		ldi r25,hi8(.LC7)
 2669 0aba 0E94 0000 		call int_to_uart
 2670               	.LVL234:
 2671               	.LBE117:
 2672               	.LBE116:
 230:calc.c        **** 
 231:calc.c        ****     float delta = (float) vars.setup_temp;
 2673               		.loc 3 231 0
 2674 0abe 6091 0000 		lds r22,vars+1
 2675 0ac2 062E      		mov __tmp_reg__,r22
 2676 0ac4 000C      		lsl r0
 2677 0ac6 770B      		sbc r23,r23
 2678 0ac8 880B      		sbc r24,r24
 2679 0aca 990B      		sbc r25,r25
 2680 0acc 0E94 0000 		call __floatsisf
 2681               	.LVL235:
 2682 0ad0 6B01      		movw r12,r22
 2683 0ad2 7C01      		movw r14,r24
 2684               	.LVL236:
 232:calc.c        ****     if (vars.cond_enabled) {
 2685               		.loc 3 232 0
 2686 0ad4 8091 0000 		lds r24,vars+9
 2687 0ad8 8823      		tst r24
 2688 0ada 01F0      		breq .L116
 233:calc.c        **** 	delta += COND_UP_SETUP_T; // если активен кондей - сместим установ
 2689               		.loc 3 233 0
 2690 0adc 20E0      		ldi r18,0
 2691 0ade 30E0      		ldi r19,0
 2692 0ae0 40E0      		ldi r20,0
 2693 0ae2 50E4      		ldi r21,lo8(64)
 2694 0ae4 C701      		movw r24,r14
 2695 0ae6 B601      		movw r22,r12
 2696 0ae8 0E94 0000 		call __addsf3
 2697               	.LVL237:
 2698 0aec 6B01      		movw r12,r22
 2699 0aee 7C01      		movw r14,r24
 2700               	.LVL238:
 2701               	.L116:
 234:calc.c        ****     }
 235:calc.c        **** 
 236:calc.c        ****     int_to_uart("St", delta);
 2702               		.loc 3 236 0
 2703 0af0 C701      		movw r24,r14
 2704 0af2 B601      		movw r22,r12
 2705 0af4 0E94 0000 		call __fixsfsi
 2706               	.LVL239:
 2707 0af8 80E0      		ldi r24,lo8(.LC8)
 2708 0afa 90E0      		ldi r25,hi8(.LC8)
 2709 0afc 0E94 0000 		call int_to_uart
 2710               	.LVL240:
 237:calc.c        ****     float_to_uart("lD", last_delta);
 2711               		.loc 3 237 0
 2712 0b00 6091 0000 		lds r22,last_delta
 2713 0b04 7091 0000 		lds r23,last_delta+1
 2714 0b08 8091 0000 		lds r24,last_delta+2
 2715 0b0c 9091 0000 		lds r25,last_delta+3
 2716               	.LVL241:
 2717               	.LBB118:
 2718               	.LBB119:
  43:main.c        ****     /*    USART_SendStr(id);
 2719               		.loc 1 43 0
 2720 0b10 0E94 0000 		call __fixsfsi
 2721               	.LVL242:
 2722 0b14 80E0      		ldi r24,lo8(.LC9)
 2723 0b16 90E0      		ldi r25,hi8(.LC9)
 2724 0b18 0E94 0000 		call int_to_uart
 2725               	.LVL243:
 2726               	.LBE119:
 2727               	.LBE118:
 238:calc.c        **** 
 239:calc.c        ****     delta = check_rangef(-40.0f, delta - Ts, 40.0f);
 2728               		.loc 3 239 0
 2729 0b1c 2091 0000 		lds r18,Ts
 2730 0b20 3091 0000 		lds r19,Ts+1
 2731 0b24 4091 0000 		lds r20,Ts+2
 2732 0b28 5091 0000 		lds r21,Ts+3
 2733 0b2c C701      		movw r24,r14
 2734 0b2e B601      		movw r22,r12
 2735 0b30 0E94 0000 		call __subsf3
 2736               	.LVL244:
 2737 0b34 9B01      		movw r18,r22
 2738 0b36 AC01      		movw r20,r24
 2739 0b38 E12C      		mov r14,__zero_reg__
 2740 0b3a F12C      		mov r15,__zero_reg__
 2741 0b3c 00E2      		ldi r16,lo8(32)
 2742 0b3e 12E4      		ldi r17,lo8(66)
 2743 0b40 60E0      		ldi r22,0
 2744 0b42 70E0      		ldi r23,0
 2745 0b44 80E2      		ldi r24,lo8(32)
 2746 0b46 92EC      		ldi r25,lo8(-62)
 2747 0b48 0E94 0000 		call check_rangef
 2748               	.LVL245:
 2749 0b4c 6B01      		movw r12,r22
 2750 0b4e 7C01      		movw r14,r24
 2751               	.LVL246:
 240:calc.c        **** 
 241:calc.c        ****     float delta_v_cfc;
 242:calc.c        ****     float id;
 243:calc.c        ****     if (fabs(delta) < 0.2f) {
 2752               		.loc 3 243 0
 2753 0b50 9F77      		andi r25,0x7f
 2754 0b52 2DEC      		ldi r18,lo8(-51)
 2755 0b54 3CEC      		ldi r19,lo8(-52)
 2756 0b56 4CE4      		ldi r20,lo8(76)
 2757 0b58 5EE3      		ldi r21,lo8(62)
 2758 0b5a 0E94 0000 		call __ltsf2
 2759               	.LVL247:
 2760 0b5e 87FF      		sbrs r24,7
 2761 0b60 00C0      		rjmp .L139
 2762               	.LVL248:
 244:calc.c        **** 	delta = 0.0f;
 245:calc.c        **** 	id = -last_delta;
 2763               		.loc 3 245 0
 2764 0b62 8090 0000 		lds r8,last_delta
 2765 0b66 9090 0000 		lds r9,last_delta+1
 2766 0b6a A090 0000 		lds r10,last_delta+2
 2767 0b6e B090 0000 		lds r11,last_delta+3
 2768 0b72 B7FA      		bst r11,7
 2769 0b74 B094      		com r11
 2770 0b76 B7F8      		bld r11,7
 2771 0b78 B094      		com r11
 2772               	.LVL249:
 246:calc.c        **** 	delta_v_cfc = 0;
 2773               		.loc 3 246 0
 2774 0b7a 1982      		std Y+1,__zero_reg__
 2775 0b7c 1A82      		std Y+2,__zero_reg__
 2776 0b7e 1B82      		std Y+3,__zero_reg__
 2777 0b80 1C82      		std Y+4,__zero_reg__
 244:calc.c        **** 	delta = 0.0f;
 2778               		.loc 3 244 0
 2779 0b82 C12C      		mov r12,__zero_reg__
 2780 0b84 D12C      		mov r13,__zero_reg__
 2781 0b86 7601      		movw r14,r12
 2782 0b88 00C0      		rjmp .L119
 2783               	.LVL250:
 2784               	.L139:
 247:calc.c        ****     } else {
 248:calc.c        **** 	id = delta - last_delta;
 2785               		.loc 3 248 0
 2786 0b8a 2091 0000 		lds r18,last_delta
 2787 0b8e 3091 0000 		lds r19,last_delta+1
 2788 0b92 4091 0000 		lds r20,last_delta+2
 2789 0b96 5091 0000 		lds r21,last_delta+3
 2790 0b9a C701      		movw r24,r14
 2791 0b9c B601      		movw r22,r12
 2792 0b9e 0E94 0000 		call __subsf3
 2793               	.LVL251:
 2794 0ba2 4B01      		movw r8,r22
 2795 0ba4 5C01      		movw r10,r24
 2796               	.LVL252:
 249:calc.c        **** 	delta_v_cfc = fabs(id / delta);
 2797               		.loc 3 249 0
 2798 0ba6 A701      		movw r20,r14
 2799 0ba8 9601      		movw r18,r12
 2800 0baa 0E94 0000 		call __divsf3
 2801               	.LVL253:
 2802 0bae 9B01      		movw r18,r22
 2803 0bb0 AC01      		movw r20,r24
 2804 0bb2 5F77      		andi r21,0x7f
 2805 0bb4 2983      		std Y+1,r18
 2806 0bb6 3A83      		std Y+2,r19
 2807 0bb8 4B83      		std Y+3,r20
 2808 0bba 5C83      		std Y+4,r21
 2809               	.LVL254:
 2810               	.L119:
 2811               	.LBB120:
 2812               	.LBB121:
  43:main.c        ****     /*    USART_SendStr(id);
 2813               		.loc 1 43 0
 2814 0bbc C701      		movw r24,r14
 2815 0bbe B601      		movw r22,r12
 2816 0bc0 0E94 0000 		call __fixsfsi
 2817               	.LVL255:
 2818 0bc4 80E0      		ldi r24,lo8(.LC10)
 2819 0bc6 90E0      		ldi r25,hi8(.LC10)
 2820 0bc8 0E94 0000 		call int_to_uart
 2821               	.LVL256:
 2822               	.LBE121:
 2823               	.LBE120:
 2824               	.LBB122:
 2825               	.LBB123:
 2826 0bcc C501      		movw r24,r10
 2827 0bce B401      		movw r22,r8
 2828 0bd0 0E94 0000 		call __fixsfsi
 2829               	.LVL257:
 2830 0bd4 80E0      		ldi r24,lo8(.LC11)
 2831 0bd6 90E0      		ldi r25,hi8(.LC11)
 2832 0bd8 0E94 0000 		call int_to_uart
 2833               	.LVL258:
 2834               	.LBE123:
 2835               	.LBE122:
 250:calc.c        ****     }
 251:calc.c        **** 
 252:calc.c        ****     float_to_uart("Dt", delta);
 253:calc.c        ****     float_to_uart("Id", id);
 254:calc.c        **** 
 255:calc.c        ****     /*
 256:calc.c        ****      downHeadFlag <<= 1;
 257:calc.c        ****      upHeadFlag <<= 1;
 258:calc.c        ****      if (delta > 0.0f) {
 259:calc.c        ****      downHeadFlag |= 1;
 260:calc.c        ****      } else if (delta < 0.0f) {
 261:calc.c        ****      upHeadFlag |= 1;
 262:calc.c        ****      }
 263:calc.c        ****      */
 264:calc.c        **** 
 265:calc.c        ****     last_delta = delta;
 2836               		.loc 3 265 0
 2837 0bdc C092 0000 		sts last_delta,r12
 2838 0be0 D092 0000 		sts last_delta+1,r13
 2839 0be4 E092 0000 		sts last_delta+2,r14
 2840 0be8 F092 0000 		sts last_delta+3,r15
 266:calc.c        **** 
 267:calc.c        ****     float pid = (delta + (Ipid * (float) vars.pid_I_kfc) / 10.0f) * (float) vars.pid_P_kfc;
 2841               		.loc 3 267 0
 2842 0bec 6091 0000 		lds r22,vars+5
 2843 0bf0 4090 0000 		lds r4,Ipid
 2844 0bf4 5090 0000 		lds r5,Ipid+1
 2845 0bf8 6090 0000 		lds r6,Ipid+2
 2846 0bfc 7090 0000 		lds r7,Ipid+3
 2847 0c00 3091 0000 		lds r19,vars+4
 2848 0c04 3D83      		std Y+5,r19
 2849 0c06 062E      		mov __tmp_reg__,r22
 2850 0c08 000C      		lsl r0
 2851 0c0a 770B      		sbc r23,r23
 2852 0c0c 880B      		sbc r24,r24
 2853 0c0e 990B      		sbc r25,r25
 2854 0c10 0E94 0000 		call __floatsisf
 2855               	.LVL259:
 2856 0c14 A301      		movw r20,r6
 2857 0c16 9201      		movw r18,r4
 2858 0c18 0E94 0000 		call __mulsf3
 2859               	.LVL260:
 2860 0c1c 20E0      		ldi r18,0
 2861 0c1e 30E0      		ldi r19,0
 2862 0c20 40E2      		ldi r20,lo8(32)
 2863 0c22 51E4      		ldi r21,lo8(65)
 2864 0c24 0E94 0000 		call __divsf3
 2865               	.LVL261:
 2866 0c28 A701      		movw r20,r14
 2867 0c2a 9601      		movw r18,r12
 2868 0c2c 0E94 0000 		call __addsf3
 2869               	.LVL262:
 2870 0c30 2B01      		movw r4,r22
 2871 0c32 3C01      		movw r6,r24
 2872 0c34 4D81      		ldd r20,Y+5
 2873 0c36 642F      		mov r22,r20
 2874 0c38 440F      		lsl r20
 2875 0c3a 770B      		sbc r23,r23
 2876 0c3c 880B      		sbc r24,r24
 2877 0c3e 990B      		sbc r25,r25
 2878 0c40 0E94 0000 		call __floatsisf
 2879               	.LVL263:
 2880 0c44 9B01      		movw r18,r22
 2881 0c46 AC01      		movw r20,r24
 2882 0c48 C301      		movw r24,r6
 2883 0c4a B201      		movw r22,r4
 2884 0c4c 0E94 0000 		call __mulsf3
 2885               	.LVL264:
 2886 0c50 2B01      		movw r4,r22
 2887 0c52 3C01      		movw r6,r24
 2888               	.LVL265:
 268:calc.c        **** 
 269:calc.c        ****     //if (!(pid > 100.0f && delta > 0.0f) && !(pid < -100.0f && delta < 0.0f)) {
 270:calc.c        ****     //if ((pid > 100.0f && delta > 0.0f) || (pid < -100.0f && delta < 0.0f)) {
 271:calc.c        ****     if ((pid > 100.0f && delta > 0.0f) || (Ipid < 0.0f && delta < 0.0f)) {
 2889               		.loc 3 271 0
 2890 0c54 20E0      		ldi r18,0
 2891 0c56 30E0      		ldi r19,0
 2892 0c58 48EC      		ldi r20,lo8(-56)
 2893 0c5a 52E4      		ldi r21,lo8(66)
 2894 0c5c 0E94 0000 		call __gtsf2
 2895               	.LVL266:
 2896 0c60 1816      		cp __zero_reg__,r24
 2897 0c62 04F4      		brge .L120
 2898               		.loc 3 271 0 is_stmt 0 discriminator 1
 2899 0c64 20E0      		ldi r18,0
 2900 0c66 30E0      		ldi r19,0
 2901 0c68 A901      		movw r20,r18
 2902 0c6a C701      		movw r24,r14
 2903 0c6c B601      		movw r22,r12
 2904 0c6e 0E94 0000 		call __gtsf2
 2905               	.LVL267:
 2906 0c72 1816      		cp __zero_reg__,r24
 2907 0c74 04F0      		brlt .L122
 2908               	.L120:
 2909               		.loc 3 271 0 discriminator 3
 2910 0c76 6091 0000 		lds r22,Ipid
 2911 0c7a 7091 0000 		lds r23,Ipid+1
 2912 0c7e 8091 0000 		lds r24,Ipid+2
 2913 0c82 9091 0000 		lds r25,Ipid+3
 2914 0c86 20E0      		ldi r18,0
 2915 0c88 30E0      		ldi r19,0
 2916 0c8a A901      		movw r20,r18
 2917 0c8c 0E94 0000 		call __ltsf2
 2918               	.LVL268:
 2919 0c90 87FF      		sbrs r24,7
 2920 0c92 00C0      		rjmp .L123
 2921               		.loc 3 271 0 discriminator 4
 2922 0c94 20E0      		ldi r18,0
 2923 0c96 30E0      		ldi r19,0
 2924 0c98 A901      		movw r20,r18
 2925 0c9a C701      		movw r24,r14
 2926 0c9c B601      		movw r22,r12
 2927 0c9e 0E94 0000 		call __ltsf2
 2928               	.LVL269:
 2929 0ca2 87FD      		sbrc r24,7
 2930 0ca4 00C0      		rjmp .L122
 2931               	.L123:
 272:calc.c        ****     } else {
 273:calc.c        **** 	Ipid += delta;
 2932               		.loc 3 273 0 is_stmt 1
 2933 0ca6 2091 0000 		lds r18,Ipid
 2934 0caa 3091 0000 		lds r19,Ipid+1
 2935 0cae 4091 0000 		lds r20,Ipid+2
 2936 0cb2 5091 0000 		lds r21,Ipid+3
 2937 0cb6 C701      		movw r24,r14
 2938 0cb8 B601      		movw r22,r12
 2939 0cba 0E94 0000 		call __addsf3
 2940               	.LVL270:
 2941 0cbe 6093 0000 		sts Ipid,r22
 2942 0cc2 7093 0000 		sts Ipid+1,r23
 2943 0cc6 8093 0000 		sts Ipid+2,r24
 2944 0cca 9093 0000 		sts Ipid+3,r25
 2945               	.L122:
 274:calc.c        ****     }
 275:calc.c        **** 
 276:calc.c        ****     float_to_uart("Ip", Ipid);
 2946               		.loc 3 276 0
 2947 0cce 6091 0000 		lds r22,Ipid
 2948 0cd2 7091 0000 		lds r23,Ipid+1
 2949 0cd6 8091 0000 		lds r24,Ipid+2
 2950 0cda 9091 0000 		lds r25,Ipid+3
 2951               	.LVL271:
 2952               	.LBB124:
 2953               	.LBB125:
  43:main.c        ****     /*    USART_SendStr(id);
 2954               		.loc 1 43 0
 2955 0cde 0E94 0000 		call __fixsfsi
 2956               	.LVL272:
 2957 0ce2 80E0      		ldi r24,lo8(.LC12)
 2958 0ce4 90E0      		ldi r25,hi8(.LC12)
 2959 0ce6 0E94 0000 		call int_to_uart
 2960               	.LVL273:
 2961               	.LBE125:
 2962               	.LBE124:
 2963               	.LBB126:
 2964               	.LBB127:
 2965 0cea C301      		movw r24,r6
 2966 0cec B201      		movw r22,r4
 2967 0cee 0E94 0000 		call __fixsfsi
 2968               	.LVL274:
 2969 0cf2 80E0      		ldi r24,lo8(.LC13)
 2970 0cf4 90E0      		ldi r25,hi8(.LC13)
 2971 0cf6 0E94 0000 		call int_to_uart
 2972               	.LVL275:
 2973               	.LBE127:
 2974               	.LBE126:
 277:calc.c        ****     float_to_uart("pid", pid);
 278:calc.c        **** 
 279:calc.c        ****     if (delta < 0.0f && temp_seg_cur <= TEMP_SEGs) {
 2975               		.loc 3 279 0
 2976 0cfa 20E0      		ldi r18,0
 2977 0cfc 30E0      		ldi r19,0
 2978 0cfe A901      		movw r20,r18
 2979 0d00 C701      		movw r24,r14
 2980 0d02 B601      		movw r22,r12
 2981 0d04 0E94 0000 		call __ltsf2
 2982               	.LVL276:
 2983 0d08 87FF      		sbrs r24,7
 2984 0d0a 00C0      		rjmp .L125
 2985               		.loc 3 279 0 is_stmt 0 discriminator 1
 2986 0d0c 8091 0000 		lds r24,temp_seg_cur
 2987 0d10 8031      		cpi r24,lo8(16)
 2988 0d12 04F4      		brge .L125
 280:calc.c        **** 	if (delta_v_cfc < D_COND_KFC || id < 0.0) {
 2989               		.loc 3 280 0 is_stmt 1
 2990 0d14 2AE0      		ldi r18,lo8(10)
 2991 0d16 37ED      		ldi r19,lo8(-41)
 2992 0d18 43E2      		ldi r20,lo8(35)
 2993 0d1a 5CE3      		ldi r21,lo8(60)
 2994 0d1c 6981      		ldd r22,Y+1
 2995 0d1e 7A81      		ldd r23,Y+2
 2996 0d20 8B81      		ldd r24,Y+3
 2997 0d22 9C81      		ldd r25,Y+4
 2998 0d24 0E94 0000 		call __ltsf2
 2999               	.LVL277:
 3000 0d28 87FD      		sbrc r24,7
 3001 0d2a 00C0      		rjmp .L127
 3002               		.loc 3 280 0 is_stmt 0 discriminator 1
 3003 0d2c 20E0      		ldi r18,0
 3004 0d2e 30E0      		ldi r19,0
 3005 0d30 A901      		movw r20,r18
 3006 0d32 C501      		movw r24,r10
 3007 0d34 B401      		movw r22,r8
 3008 0d36 0E94 0000 		call __ltsf2
 3009               	.LVL278:
 3010 0d3a 87FF      		sbrs r24,7
 3011 0d3c 00C0      		rjmp .L128
 3012               	.L127:
 281:calc.c        **** 	    cond_needs_of_cool += fabs(delta);
 3013               		.loc 3 281 0 is_stmt 1
 3014 0d3e 6091 0000 		lds r22,cond_needs_of_cool
 3015 0d42 062E      		mov __tmp_reg__,r22
 3016 0d44 000C      		lsl r0
 3017 0d46 770B      		sbc r23,r23
 3018 0d48 880B      		sbc r24,r24
 3019 0d4a 990B      		sbc r25,r25
 3020 0d4c 0E94 0000 		call __floatsisf
 3021               	.LVL279:
 3022 0d50 A701      		movw r20,r14
 3023 0d52 9601      		movw r18,r12
 3024 0d54 5F77      		andi r21,0x7f
 3025 0d56 0E94 0000 		call __addsf3
 3026               	.LVL280:
 3027 0d5a 0E94 0000 		call __fixsfsi
 3028               	.LVL281:
 3029 0d5e 6093 0000 		sts cond_needs_of_cool,r22
 3030 0d62 00C0      		rjmp .L128
 3031               	.L125:
 282:calc.c        **** 	}
 283:calc.c        ****     } else {
 284:calc.c        **** 	cond_needs_of_cool = 0;
 3032               		.loc 3 284 0
 3033 0d64 1092 0000 		sts cond_needs_of_cool,__zero_reg__
 3034               	.L128:
 285:calc.c        ****     }
 286:calc.c        **** 
 287:calc.c        ****     int_to_uart("CO", cond_needs_of_cool);
 3035               		.loc 3 287 0
 3036 0d68 6091 0000 		lds r22,cond_needs_of_cool
 3037 0d6c 062E      		mov __tmp_reg__,r22
 3038 0d6e 000C      		lsl r0
 3039 0d70 770B      		sbc r23,r23
 3040 0d72 80E0      		ldi r24,lo8(.LC14)
 3041 0d74 90E0      		ldi r25,hi8(.LC14)
 3042 0d76 0E94 0000 		call int_to_uart
 3043               	.LVL282:
 288:calc.c        **** 
 289:calc.c        ****  /*   temp_out_delay++;
 290:calc.c        ****     if (temp_out_delay > vars.temp_seg_delay) {
 291:calc.c        **** 	temp_out_delay = 0;
 292:calc.c        **** 	*/
 293:calc.c        **** 	//temp_out_prc = (check_rangef(0, pid, 101) + temp_out_prc) / 2;
 294:calc.c        ****     temp_out_prc = check_rangef(0, pid, 101);
 3044               		.loc 3 294 0
 3045 0d7a E12C      		mov r14,__zero_reg__
 3046 0d7c F12C      		mov r15,__zero_reg__
 3047 0d7e 0AEC      		ldi r16,lo8(-54)
 3048 0d80 12E4      		ldi r17,lo8(66)
 3049 0d82 A301      		movw r20,r6
 3050 0d84 9201      		movw r18,r4
 3051 0d86 60E0      		ldi r22,0
 3052 0d88 70E0      		ldi r23,0
 3053 0d8a CB01      		movw r24,r22
 3054 0d8c 0E94 0000 		call check_rangef
 3055               	.LVL283:
 3056 0d90 0E94 0000 		call __fixunssfsi
 3057               	.LVL284:
 3058 0d94 6093 0000 		sts temp_out_prc,r22
 295:calc.c        ****     //}
 296:calc.c        ****     /*
 297:calc.c        ****      int_to_uart("UHF", upHeadFlag);
 298:calc.c        ****      int_to_uart("DHF", downHeadFlag);
 299:calc.c        ****      */
 300:calc.c        ****     int_to_uart("out", temp_out_prc);
 3059               		.loc 3 300 0
 3060 0d98 6091 0000 		lds r22,temp_out_prc
 3061 0d9c 70E0      		ldi r23,0
 3062 0d9e 80E0      		ldi r24,lo8(.LC15)
 3063 0da0 90E0      		ldi r25,hi8(.LC15)
 3064 0da2 0E94 0000 		call int_to_uart
 3065               	.LVL285:
 301:calc.c        **** 
 302:calc.c        ****     //calcVent(id);
 303:calc.c        ****     calcVent(pid);
 3066               		.loc 3 303 0
 3067 0da6 C301      		movw r24,r6
 3068 0da8 B201      		movw r22,r4
 3069 0daa 0E94 0000 		call calcVent
 3070               	.LVL286:
 3071               	/* epilogue start */
 304:calc.c        **** 
 305:calc.c        ****     uart_nl();
 306:calc.c        **** }
 3072               		.loc 3 306 0
 3073 0dae 0F90      		pop __tmp_reg__
 3074 0db0 0F90      		pop __tmp_reg__
 3075 0db2 0F90      		pop __tmp_reg__
 3076 0db4 0F90      		pop __tmp_reg__
 3077 0db6 0F90      		pop __tmp_reg__
 3078 0db8 DF91      		pop r29
 3079 0dba CF91      		pop r28
 3080               	.LVL287:
 3081 0dbc 1F91      		pop r17
 3082               	.LVL288:
 3083 0dbe 0F91      		pop r16
 3084               	.LVL289:
 3085 0dc0 FF90      		pop r15
 3086               	.LVL290:
 3087 0dc2 EF90      		pop r14
 3088               	.LVL291:
 3089 0dc4 DF90      		pop r13
 3090               	.LVL292:
 3091 0dc6 CF90      		pop r12
 3092               	.LVL293:
 3093 0dc8 BF90      		pop r11
 3094               	.LVL294:
 3095 0dca AF90      		pop r10
 3096               	.LVL295:
 3097 0dcc 9F90      		pop r9
 3098               	.LVL296:
 3099 0dce 8F90      		pop r8
 3100               	.LVL297:
 3101 0dd0 7F90      		pop r7
 3102               	.LVL298:
 3103 0dd2 6F90      		pop r6
 3104               	.LVL299:
 3105 0dd4 5F90      		pop r5
 3106               	.LVL300:
 3107 0dd6 4F90      		pop r4
 3108               	.LVL301:
 305:calc.c        **** }
 3109               		.loc 3 305 0
 3110 0dd8 0C94 0000 		jmp uart_nl
 3111               	.LVL302:
 3112               		.cfi_endproc
 3113               	.LFE39:
 3115               	.global	recycleSwitch
 3117               	recycleSwitch:
 3118               	.LFB40:
 311:main.c        **** 
 312:main.c        **** #include "calc.c"
 313:main.c        **** 
 314:main.c        **** void recycleSwitch(void) // эмуляция нажатия
 315:main.c        **** {
 3119               		.loc 1 315 0
 3120               		.cfi_startproc
 3121               	/* prologue: function */
 3122               	/* frame size = 0 */
 3123               	/* stack size = 0 */
 3124               	.L__stack_usage = 0
 316:main.c        ****     pin_low(OUT_BTN_Recycle);
 3125               		.loc 1 316 0
 3126 0ddc 5898      		cbi 0xb,0
 317:main.c        ****     set_dir_out(OUT_BTN_Recycle);
 3127               		.loc 1 317 0
 3128 0dde 509A      		sbi 0xa,0
 318:main.c        ****     delay_ms(50);
 3129               		.loc 1 318 0
 3130 0de0 82E3      		ldi r24,lo8(50)
 3131 0de2 90E0      		ldi r25,0
 3132 0de4 0E94 0000 		call delay_ms
 3133               	.LVL303:
 319:main.c        **** //    pin_high(OUT_BTN_Recycle);
 320:main.c        ****     set_dir_in(OUT_BTN_Recycle);
 3134               		.loc 1 320 0
 3135 0de8 5098      		cbi 0xa,0
 3136 0dea 0895      		ret
 3137               		.cfi_endproc
 3138               	.LFE40:
 3140               	.global	prefAirSwitch
 3142               	prefAirSwitch:
 3143               	.LFB41:
 321:main.c        **** }
 322:main.c        **** 
 323:main.c        **** void prefAirSwitch(void) // эмуляция нажатия
 324:main.c        **** {
 3144               		.loc 1 324 0
 3145               		.cfi_startproc
 3146               	/* prologue: function */
 3147               	/* frame size = 0 */
 3148               	/* stack size = 0 */
 3149               	.L__stack_usage = 0
 325:main.c        ****     pin_low(OUT_BTN_MODE_UP_DOWN);
 3150               		.loc 1 325 0
 3151 0dec 4098      		cbi 0x8,0
 326:main.c        ****     set_dir_out(OUT_BTN_MODE_UP_DOWN);
 3152               		.loc 1 326 0
 3153 0dee 389A      		sbi 0x7,0
 327:main.c        ****     delay_ms(50);
 3154               		.loc 1 327 0
 3155 0df0 82E3      		ldi r24,lo8(50)
 3156 0df2 90E0      		ldi r25,0
 3157 0df4 0E94 0000 		call delay_ms
 3158               	.LVL304:
 328:main.c        ****     set_dir_in(OUT_BTN_MODE_UP_DOWN);
 3159               		.loc 1 328 0
 3160 0df8 3898      		cbi 0x7,0
 3161 0dfa 0895      		ret
 3162               		.cfi_endproc
 3163               	.LFE41:
 3165               	.global	hiAirSwitch
 3167               	hiAirSwitch:
 3168               	.LFB42:
 329:main.c        **** }
 330:main.c        **** 
 331:main.c        **** void hiAirSwitch(void) // эмуляция нажатия
 332:main.c        **** {
 3169               		.loc 1 332 0
 3170               		.cfi_startproc
 3171               	/* prologue: function */
 3172               	/* frame size = 0 */
 3173               	/* stack size = 0 */
 3174               	.L__stack_usage = 0
 333:main.c        ****     pin_low(IN_BTN_HI_MODE);
 3175               		.loc 1 333 0
 3176 0dfc 4498      		cbi 0x8,4
 334:main.c        ****     set_dir_out(IN_BTN_HI_MODE);
 3177               		.loc 1 334 0
 3178 0dfe 3C9A      		sbi 0x7,4
 335:main.c        ****     delay_ms(50);
 3179               		.loc 1 335 0
 3180 0e00 82E3      		ldi r24,lo8(50)
 3181 0e02 90E0      		ldi r25,0
 3182 0e04 0E94 0000 		call delay_ms
 3183               	.LVL305:
 336:main.c        ****     set_dir_in(IN_BTN_HI_MODE);
 3184               		.loc 1 336 0
 3185 0e08 3C98      		cbi 0x7,4
 3186 0e0a 0895      		ret
 3187               		.cfi_endproc
 3188               	.LFE42:
 3190               	.global	setup_pins
 3192               	setup_pins:
 3193               	.LFB43:
 337:main.c        **** }
 338:main.c        **** 
 339:main.c        **** void setup_pins(void)
 340:main.c        **** {
 3194               		.loc 1 340 0
 3195               		.cfi_startproc
 3196               	/* prologue: function */
 3197               	/* frame size = 0 */
 3198               	/* stack size = 0 */
 3199               	.L__stack_usage = 0
 341:main.c        ****     PORTB = 0;
 3200               		.loc 1 341 0
 3201 0e0c 15B8      		out 0x5,__zero_reg__
 342:main.c        ****     PORTC = 0;
 3202               		.loc 1 342 0
 3203 0e0e 18B8      		out 0x8,__zero_reg__
 343:main.c        ****     PORTD = 0;
 3204               		.loc 1 343 0
 3205 0e10 1BB8      		out 0xb,__zero_reg__
 344:main.c        ****     DDRB = 0; //dir to in
 3206               		.loc 1 344 0
 3207 0e12 14B8      		out 0x4,__zero_reg__
 345:main.c        ****     DDRC = 0; //dir to in
 3208               		.loc 1 345 0
 3209 0e14 17B8      		out 0x7,__zero_reg__
 346:main.c        ****     DDRD = 0; //dir to in
 3210               		.loc 1 346 0
 3211 0e16 1AB8      		out 0xa,__zero_reg__
 347:main.c        ****     /*    set_dir_in(IN_BTN_HI_MODE);
 348:main.c        ****      set_dir_in(IN_BTN_SETUP);
 349:main.c        ****      set_dir_in(IN_BTN_T_UP);
 350:main.c        ****      set_dir_in(IN_BTN_T_DWN);
 351:main.c        ****      set_dir_in(IN_BTN_V_UP);
 352:main.c        ****      set_dir_in(IN_BTN_V_DWN);
 353:main.c        ****      set_dir_in(IN_ACC);
 354:main.c        ****      IN_NIGHT_BR
 355:main.c        ****      set_dir_in(IN_FROST_BTN);*/
 356:main.c        **** 
 357:main.c        ****     pin_low(OUT_FROST_SW);
 3212               		.loc 1 357 0
 3213 0e18 4598      		cbi 0x8,5
 358:main.c        ****     set_dir_out(OUT_FROST_SW);
 3214               		.loc 1 358 0
 3215 0e1a 3D9A      		sbi 0x7,5
 359:main.c        ****     pin_low(OUT_FROST_IND);
 3216               		.loc 1 359 0
 3217 0e1c 4198      		cbi 0x8,1
 360:main.c        ****     set_dir_out(OUT_FROST_IND);
 3218               		.loc 1 360 0
 3219 0e1e 399A      		sbi 0x7,1
 361:main.c        ****     set_dir_out(OUT_BTN_T_UP);
 3220               		.loc 1 361 0
 3221 0e20 559A      		sbi 0xa,5
 362:main.c        ****     set_dir_out(OUT_BTN_T_DWN);
 3222               		.loc 1 362 0
 3223 0e22 549A      		sbi 0xa,4
 363:main.c        ****     set_dir_out(OUT_BTN_V_UP);
 3224               		.loc 1 363 0
 3225 0e24 569A      		sbi 0xa,6
 364:main.c        ****     set_dir_out(OUT_BTN_V_DWN);
 3226               		.loc 1 364 0
 3227 0e26 219A      		sbi 0x4,1
 3228 0e28 0895      		ret
 3229               		.cfi_endproc
 3230               	.LFE43:
 3232               	.global	setup_display
 3234               	setup_display:
 3235               	.LFB44:
 365:main.c        **** }
 366:main.c        **** 
 367:main.c        **** void setup_display(void)
 368:main.c        **** {
 3236               		.loc 1 368 0
 3237               		.cfi_startproc
 3238               	/* prologue: function */
 3239               	/* frame size = 0 */
 3240               	/* stack size = 0 */
 3241               	.L__stack_usage = 0
 369:main.c        ****     Send_7219(0x09, 0x00); //режим декодирования
 3242               		.loc 1 369 0
 3243 0e2a 60E0      		ldi r22,0
 3244 0e2c 89E0      		ldi r24,lo8(9)
 3245 0e2e 0E94 0000 		call Send_7219
 3246               	.LVL306:
 370:main.c        ****     int8_t br_dsp = DISP_BRG_MIN;
 371:main.c        ****     if (!get_input(IN_NIGHT_BR)) {
 3247               		.loc 1 371 0
 3248 0e32 3299      		sbic 0x6,2
 3249 0e34 00C0      		rjmp .L146
 372:main.c        **** 	br_dsp = DISP_BRG_MAX;
 3250               		.loc 1 372 0
 3251 0e36 67E0      		ldi r22,lo8(7)
 3252 0e38 00C0      		rjmp .L145
 3253               	.L146:
 370:main.c        ****     int8_t br_dsp = DISP_BRG_MIN;
 3254               		.loc 1 370 0
 3255 0e3a 61E0      		ldi r22,lo8(1)
 3256               	.L145:
 3257               	.LVL307:
 373:main.c        ****     }
 374:main.c        ****     Send_7219(0x0A, br_dsp); //яркость
 3258               		.loc 1 374 0
 3259 0e3c 8AE0      		ldi r24,lo8(10)
 3260 0e3e 0E94 0000 		call Send_7219
 3261               	.LVL308:
 375:main.c        ****     Send_7219(0x0B, DISP_LEN - 1); //сколько разрядов используем
 3262               		.loc 1 375 0
 3263 0e42 63E0      		ldi r22,lo8(3)
 3264 0e44 8BE0      		ldi r24,lo8(11)
 3265 0e46 0E94 0000 		call Send_7219
 3266               	.LVL309:
 376:main.c        ****     Send_7219(0x0C, 1); //включим индикатор
 3267               		.loc 1 376 0
 3268 0e4a 61E0      		ldi r22,lo8(1)
 3269 0e4c 8CE0      		ldi r24,lo8(12)
 3270 0e4e 0E94 0000 		call Send_7219
 3271               	.LVL310:
 377:main.c        ****     Send_7219(0x0F, 0x00);
 3272               		.loc 1 377 0
 3273 0e52 60E0      		ldi r22,0
 3274 0e54 8FE0      		ldi r24,lo8(15)
 3275 0e56 0C94 0000 		jmp Send_7219
 3276               	.LVL311:
 3277               		.cfi_endproc
 3278               	.LFE44:
 3280               	.global	display_off
 3282               	display_off:
 3283               	.LFB45:
 378:main.c        **** }
 379:main.c        **** 
 380:main.c        **** void display_off(void)
 381:main.c        **** {
 3284               		.loc 1 381 0
 3285               		.cfi_startproc
 3286               	/* prologue: function */
 3287               	/* frame size = 0 */
 3288               	/* stack size = 0 */
 3289               	.L__stack_usage = 0
 382:main.c        ****     Send_7219(0, 0);
 3290               		.loc 1 382 0
 3291 0e5a 60E0      		ldi r22,0
 3292 0e5c 80E0      		ldi r24,0
 3293 0e5e 0E94 0000 		call Send_7219
 3294               	.LVL312:
 383:main.c        ****     Send_7219(0x0C, 0); //выключим индикатор
 3295               		.loc 1 383 0
 3296 0e62 60E0      		ldi r22,0
 3297 0e64 8CE0      		ldi r24,lo8(12)
 3298 0e66 0C94 0000 		jmp Send_7219
 3299               	.LVL313:
 3300               		.cfi_endproc
 3301               	.LFE45:
 3303               		.section	.text.startup,"ax",@progbits
 3304               	.global	main
 3306               	main:
 3307               	.LFB46:
 384:main.c        **** }
 385:main.c        **** 
 386:main.c        **** int main(void)
 387:main.c        **** {
 3308               		.loc 1 387 0
 3309               		.cfi_startproc
 3310 0000 CF93      		push r28
 3311               	.LCFI122:
 3312               		.cfi_def_cfa_offset 3
 3313               		.cfi_offset 28, -2
 3314 0002 DF93      		push r29
 3315               	.LCFI123:
 3316               		.cfi_def_cfa_offset 4
 3317               		.cfi_offset 29, -3
 3318 0004 1F92      		push __zero_reg__
 3319               	.LCFI124:
 3320               		.cfi_def_cfa_offset 5
 3321 0006 CDB7      		in r28,__SP_L__
 3322 0008 DEB7      		in r29,__SP_H__
 3323               	.LCFI125:
 3324               		.cfi_def_cfa_register 28
 3325               	/* prologue: function */
 3326               	/* frame size = 1 */
 3327               	/* stack size = 3 */
 3328               	.L__stack_usage = 3
 388:main.c        ****     wdt_reset();
 3329               		.loc 1 388 0
 3330               	/* #APP */
 3331               	 ;  388 "main.c" 1
 3332 000a A895      		wdr
 3333               	 ;  0 "" 2
 389:main.c        ****     cli();
 3334               		.loc 1 389 0
 3335               	 ;  389 "main.c" 1
 3336 000c F894      		cli
 3337               	 ;  0 "" 2
 3338               	.LVL314:
 3339               	/* #NOAPP */
 3340               	.LBB128:
 3341               	.LBB129:
 3342               		.file 4 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 3343               		.loc 4 473 0
 3344 000e 98E2      		ldi r25,lo8(40)
 3345 0010 88E1      		ldi r24,lo8(24)
 3346               	/* #APP */
 3347               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 3348 0012 0FB6      		in __tmp_reg__,__SREG__
 3349 0014 F894      		cli
 3350 0016 A895      		wdr
 3351 0018 8093 6000 		sts 96, r24
 3352 001c 0FBE      		out __SREG__,__tmp_reg__
 3353 001e 9093 6000 		sts 96, r25
 3354               	 	
 3355               	 ;  0 "" 2
 3356               	.LVL315:
 3357               	/* #NOAPP */
 3358               	.LBE129:
 3359               	.LBE128:
 390:main.c        ****     wdt_enable(WDTO_4S);
 391:main.c        ****     wdt_reset();
 3360               		.loc 1 391 0
 3361               	/* #APP */
 3362               	 ;  391 "main.c" 1
 3363 0022 A895      		wdr
 3364               	 ;  0 "" 2
 3365               	.LVL316:
 392:main.c        ****     int8_t disp_num = 0;
 393:main.c        ****     uint8_t disp_bar = 0;
 394:main.c        ****     int8_t tmp;
 395:main.c        ****     uint8_t time_cnt;
 396:main.c        ****     int8_t smode = 0;
 397:main.c        ****     int8_t bdelay = 0;
 3366               		.loc 1 397 0
 3367               	/* #NOAPP */
 3368 0024 1982      		std Y+1,__zero_reg__
 398:main.c        **** 
 399:main.c        ****     bootVarsInit();
 3369               		.loc 1 399 0
 3370 0026 0E94 0000 		call bootVarsInit
 3371               	.LVL317:
 400:main.c        **** 
 401:main.c        ****     setup_pins();
 3372               		.loc 1 401 0
 3373 002a 0E94 0000 		call setup_pins
 3374               	.LVL318:
 3375               	.L149:
 402:main.c        **** 
 403:main.c        ****     while (!get_input(IN_ACC)) { //ACC off
 3376               		.loc 1 403 0
 3377 002e 3399      		sbic 0x6,3
 3378 0030 00C0      		rjmp .L275
 404:main.c        **** 	wdt_reset();
 3379               		.loc 1 404 0
 3380               	/* #APP */
 3381               	 ;  404 "main.c" 1
 3382 0032 A895      		wdr
 3383               	 ;  0 "" 2
 405:main.c        **** 	delay_s(1); // wait for ACC
 3384               		.loc 1 405 0
 3385               	/* #NOAPP */
 3386 0034 81E0      		ldi r24,lo8(1)
 3387 0036 0E94 0000 		call delay_s
 3388               	.LVL319:
 406:main.c        **** 	display_off();
 3389               		.loc 1 406 0
 3390 003a 0E94 0000 		call display_off
 3391               	.LVL320:
 3392 003e 00C0      		rjmp .L149
 3393               	.L275:
 407:main.c        ****     }
 408:main.c        **** 
 409:main.c        ****     delay_ms(10);
 3394               		.loc 1 409 0
 3395 0040 8AE0      		ldi r24,lo8(10)
 3396 0042 90E0      		ldi r25,0
 3397 0044 0E94 0000 		call delay_ms
 3398               	.LVL321:
 410:main.c        ****     myread_eeprom();
 3399               		.loc 1 410 0
 3400 0048 0E94 0000 		call myread_eeprom
 3401               	.LVL322:
 411:main.c        **** 
 412:main.c        ****     //TODO sei();
 413:main.c        **** 
 414:main.c        ****     ADC_Init();
 3402               		.loc 1 414 0
 3403 004c 0E94 0000 		call ADC_Init
 3404               	.LVL323:
 415:main.c        ****     USART_Init();
 3405               		.loc 1 415 0
 3406 0050 0E94 0000 		call USART_Init
 3407               	.LVL324:
 416:main.c        ****     //int_to_uart("T", 0);
 417:main.c        **** 
 418:main.c        ****     SPI_init();
 3408               		.loc 1 418 0
 3409 0054 0E94 0000 		call SPI_init
 3410               	.LVL325:
 419:main.c        ****     delay_ms(1);
 3411               		.loc 1 419 0
 3412 0058 81E0      		ldi r24,lo8(1)
 3413 005a 90E0      		ldi r25,0
 3414 005c 0E94 0000 		call delay_ms
 3415               	.LVL326:
 420:main.c        **** 
 421:main.c        ****     //int_to_uart("T", 1);
 422:main.c        ****     Send_7219(0, 0);
 3416               		.loc 1 422 0
 3417 0060 60E0      		ldi r22,0
 3418 0062 80E0      		ldi r24,0
 3419 0064 0E94 0000 		call Send_7219
 3420               	.LVL327:
 423:main.c        ****     delay_ms(1);
 3421               		.loc 1 423 0
 3422 0068 81E0      		ldi r24,lo8(1)
 3423 006a 90E0      		ldi r25,0
 3424 006c 0E94 0000 		call delay_ms
 3425               	.LVL328:
 424:main.c        ****     Clear_7219();
 3426               		.loc 1 424 0
 3427 0070 0E94 0000 		call Clear_7219
 3428               	.LVL329:
 425:main.c        ****     Send_7219(0x09, 0x00); //режим декодирования
 3429               		.loc 1 425 0
 3430 0074 60E0      		ldi r22,0
 3431 0076 89E0      		ldi r24,lo8(9)
 3432 0078 0E94 0000 		call Send_7219
 3433               	.LVL330:
 426:main.c        ****     Send_7219(0x0A, 0x01); //яркость
 3434               		.loc 1 426 0
 3435 007c 61E0      		ldi r22,lo8(1)
 3436 007e 8AE0      		ldi r24,lo8(10)
 3437 0080 0E94 0000 		call Send_7219
 3438               	.LVL331:
 427:main.c        ****     Send_7219(0x0B, DISP_LEN - 1); //сколько разрядов используем
 3439               		.loc 1 427 0
 3440 0084 63E0      		ldi r22,lo8(3)
 3441 0086 8BE0      		ldi r24,lo8(11)
 3442 0088 0E94 0000 		call Send_7219
 3443               	.LVL332:
 428:main.c        ****     Send_7219(0x0D, 0x00);
 3444               		.loc 1 428 0
 3445 008c 60E0      		ldi r22,0
 3446 008e 8DE0      		ldi r24,lo8(13)
 3447 0090 0E94 0000 		call Send_7219
 3448               	.LVL333:
 429:main.c        ****     Send_7219(0x0E, 0x00);
 3449               		.loc 1 429 0
 3450 0094 60E0      		ldi r22,0
 3451 0096 8EE0      		ldi r24,lo8(14)
 3452 0098 0E94 0000 		call Send_7219
 3453               	.LVL334:
 430:main.c        ****     Send_7219(0x0F, 0x00);
 3454               		.loc 1 430 0
 3455 009c 60E0      		ldi r22,0
 3456 009e 8FE0      		ldi r24,lo8(15)
 3457 00a0 0E94 0000 		call Send_7219
 3458               	.LVL335:
 431:main.c        ****     delay_ms(1);
 3459               		.loc 1 431 0
 3460 00a4 81E0      		ldi r24,lo8(1)
 3461 00a6 90E0      		ldi r25,0
 3462 00a8 0E94 0000 		call delay_ms
 3463               	.LVL336:
 432:main.c        **** 
 433:main.c        ****     //int_to_uart("T", 2);
 434:main.c        ****     wdt_reset();
 3464               		.loc 1 434 0
 3465               	/* #APP */
 3466               	 ;  434 "main.c" 1
 3467 00ac A895      		wdr
 3468               	 ;  0 "" 2
 435:main.c        **** 
 436:main.c        ****     disp_num = vars.setup_temp;
 3469               		.loc 1 436 0
 3470               	/* #NOAPP */
 3471 00ae F090 0000 		lds r15,vars+1
 3472               	.LVL337:
 437:main.c        ****     Disp_Num(disp_num, 0);
 3473               		.loc 1 437 0
 3474 00b2 60E0      		ldi r22,0
 3475 00b4 8F2D      		mov r24,r15
 3476 00b6 0E94 0000 		call Disp_Num
 3477               	.LVL338:
 438:main.c        ****     Send_7219(0x0C, 1); //включим индикатор
 3478               		.loc 1 438 0
 3479 00ba 61E0      		ldi r22,lo8(1)
 3480 00bc 8CE0      		ldi r24,lo8(12)
 3481 00be 0E94 0000 		call Send_7219
 3482               	.LVL339:
 439:main.c        ****     disp_bar = vars.vent_nom_seg;
 3483               		.loc 1 439 0
 3484 00c2 B090 0000 		lds r11,vars+2
 3485               	.LVL340:
 440:main.c        ****     Disp_Bars(disp_bar);
 3486               		.loc 1 440 0
 3487 00c6 8B2D      		mov r24,r11
 3488 00c8 0E94 0000 		call Disp_Bars
 3489               	.LVL341:
 441:main.c        **** 
 442:main.c        ****     cli();
 3490               		.loc 1 442 0
 3491               	/* #APP */
 3492               	 ;  442 "main.c" 1
 3493 00cc F894      		cli
 3494               	 ;  0 "" 2
 443:main.c        ****     //int_to_uart("T", 3);
 444:main.c        **** //timer init
 445:main.c        ****     TCCR1A = 0;  	//Т/С1 отсоединен от вывода ОС1, режим ШИМ откл
 3495               		.loc 1 445 0
 3496               	/* #NOAPP */
 3497 00ce 1092 8000 		sts 128,__zero_reg__
 446:main.c        ****     TCCR1B = 4;  	//Коэффициент деления частоты системной	син
 3498               		.loc 1 446 0
 3499 00d2 84E0      		ldi r24,lo8(4)
 3500 00d4 8093 8100 		sts 129,r24
 447:main.c        ****     TCNT1 = 0x10000 - (F_CPU / 512); //Инициализируем счетный регистр
 3501               		.loc 1 447 0
 3502 00d8 87EF      		ldi r24,lo8(-9)
 3503 00da 92EC      		ldi r25,lo8(-62)
 3504 00dc 9093 8500 		sts 132+1,r25
 3505 00e0 8093 8400 		sts 132,r24
 448:main.c        **** 
 449:main.c        ****     TIFR1 = 0;       //Сбрасываем все флаги прерываний от Т/С1
 3506               		.loc 1 449 0
 3507 00e4 16BA      		out 0x16,__zero_reg__
 450:main.c        ****     TIMSK1 = 1 << TOIE1;  	//Разрешаем прерывание при переполнени
 3508               		.loc 1 450 0
 3509 00e6 91E0      		ldi r25,lo8(1)
 3510 00e8 9093 6F00 		sts 111,r25
 451:main.c        **** 
 452:main.c        ****     //interrupt setup
 453:main.c        ****     EICRA = 0; // External Interrupt Control Register A
 3511               		.loc 1 453 0
 3512 00ec 1092 6900 		sts 105,__zero_reg__
 454:main.c        ****     EIMSK = 0; //External Interrupt Mask Register
 3513               		.loc 1 454 0
 3514 00f0 1DBA      		out 0x1d,__zero_reg__
 455:main.c        ****     EIMSK = (1 << INT0) | (1 << INT1);
 3515               		.loc 1 455 0
 3516 00f2 83E0      		ldi r24,lo8(3)
 3517 00f4 8DBB      		out 0x1d,r24
 456:main.c        ****     EICRA = (1 << ISC00) | (1 << ISC10); // set INT0 + INT1 to trigger on ANY logic change
 3518               		.loc 1 456 0
 3519 00f6 85E0      		ldi r24,lo8(5)
 3520 00f8 8093 6900 		sts 105,r24
 457:main.c        **** 
 458:main.c        ****     //int_to_uart("T", 4);
 459:main.c        **** 
 460:main.c        ****     //set by IN_BTN_V_DWN  + IN_BTN_V_UP
 461:main.c        ****     PCMSK0 = (1 << PCINT0);  // set PCINT0 to trigger an interrupt on state change
 3521               		.loc 1 461 0
 3522 00fc 9093 6B00 		sts 107,r25
 462:main.c        ****     PCMSK2 = (1 << PCINT23);  // set PCINT23 to trigger an interrupt on state change
 3523               		.loc 1 462 0
 3524 0100 90E8      		ldi r25,lo8(-128)
 3525 0102 9093 6D00 		sts 109,r25
 463:main.c        ****     PCICR = (1 << PCIE0) | (1 << PCIE2);    // Pin Change Interrupt Control Register
 3526               		.loc 1 463 0
 3527 0106 8093 6800 		sts 104,r24
 464:main.c        **** 
 465:main.c        **** //todo	GIMSK = 0;     	//Запрет внешних прерываний
 466:main.c        ****     //int_to_uart("T", 5);
 467:main.c        ****     delay_ms(10);
 3528               		.loc 1 467 0
 3529 010a 8AE0      		ldi r24,lo8(10)
 3530 010c 90E0      		ldi r25,0
 3531 010e 0E94 0000 		call delay_ms
 3532               	.LVL342:
 468:main.c        ****     sei();
 3533               		.loc 1 468 0
 3534               	/* #APP */
 3535               	 ;  468 "main.c" 1
 3536 0112 7894      		sei
 3537               	 ;  0 "" 2
 469:main.c        **** 
 470:main.c        ****     vent_enc = 0;
 3538               		.loc 1 470 0
 3539               	/* #NOAPP */
 3540 0114 1092 0000 		sts vent_enc,__zero_reg__
 471:main.c        ****     temp_enc = 0;
 3541               		.loc 1 471 0
 3542 0118 1092 0000 		sts temp_enc,__zero_reg__
 3543               	.LVL343:
 472:main.c        ****     time_cnt = 0;
 473:main.c        **** 
 474:main.c        ****     wdt_reset();
 3544               		.loc 1 474 0
 3545               	/* #APP */
 3546               	 ;  474 "main.c" 1
 3547 011c A895      		wdr
 3548               	 ;  0 "" 2
 475:main.c        ****     /*    vent_seg_cur = VENT_SEGs;
 476:main.c        ****      temp_seg_cur = TEMP_SEGs;
 477:main.c        ****      */
 478:main.c        ****     vent_seg_cur = -1;
 3549               		.loc 1 478 0
 3550               	/* #NOAPP */
 3551 011e 8FEF      		ldi r24,lo8(-1)
 3552 0120 8093 0000 		sts vent_seg_cur,r24
 479:main.c        ****     temp_seg_cur = -1;
 3553               		.loc 1 479 0
 3554 0124 8093 0000 		sts temp_seg_cur,r24
 480:main.c        ****     set_vent_seg(0, 1);
 3555               		.loc 1 480 0
 3556 0128 61E0      		ldi r22,lo8(1)
 3557 012a 80E0      		ldi r24,0
 3558 012c 0E94 0000 		call set_vent_seg
 3559               	.LVL344:
 481:main.c        ****     set_temp(0, 1);
 3560               		.loc 1 481 0
 3561 0130 61E0      		ldi r22,lo8(1)
 3562 0132 80E0      		ldi r24,0
 3563 0134 0E94 0000 		call set_temp
 3564               	.LVL345:
 3565               	.LBB130:
 3566               	.LBB131:
 3567               		.loc 4 473 0
 3568 0138 98E2      		ldi r25,lo8(40)
 3569 013a 88E1      		ldi r24,lo8(24)
 3570               	/* #APP */
 3571               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 3572 013c 0FB6      		in __tmp_reg__,__SREG__
 3573 013e F894      		cli
 3574 0140 A895      		wdr
 3575 0142 8093 6000 		sts 96, r24
 3576 0146 0FBE      		out __SREG__,__tmp_reg__
 3577 0148 9093 6000 		sts 96, r25
 3578               	 	
 3579               	 ;  0 "" 2
 3580               	.LVL346:
 3581               	/* #NOAPP */
 3582               	.LBE131:
 3583               	.LBE130:
 482:main.c        **** 
 483:main.c        ****     wdt_enable(WDTO_4S);
 484:main.c        ****     //int_to_uart("T", 10);
 485:main.c        **** 
 486:main.c        ****     tmp = 5;
 487:main.c        ****     while (tmp--) {
 3584               		.loc 1 487 0
 3585 014c 16E0      		ldi r17,lo8(6)
 3586               	.LVL347:
 3587               	.L151:
 3588 014e 1150      		subi r17,lo8(-(-1))
 3589               	.LVL348:
 3590 0150 01F0      		breq .L276
 3591               	.LVL349:
 488:main.c        **** 	wdt_reset();
 3592               		.loc 1 488 0
 3593               	/* #APP */
 3594               	 ;  488 "main.c" 1
 3595 0152 A895      		wdr
 3596               	 ;  0 "" 2
 489:main.c        **** 	Ts = getTempSalon();
 3597               		.loc 1 489 0
 3598               	/* #NOAPP */
 3599 0154 0E94 0000 		call getTempSalon
 3600               	.LVL350:
 3601 0158 6093 0000 		sts Ts,r22
 3602 015c 7093 0000 		sts Ts+1,r23
 3603 0160 8093 0000 		sts Ts+2,r24
 3604 0164 9093 0000 		sts Ts+3,r25
 490:main.c        **** 	delay_ms(1);
 3605               		.loc 1 490 0
 3606 0168 81E0      		ldi r24,lo8(1)
 3607 016a 90E0      		ldi r25,0
 3608 016c 0E94 0000 		call delay_ms
 3609               	.LVL351:
 491:main.c        **** 	Ti = getTempIsparit();
 3610               		.loc 1 491 0
 3611 0170 0E94 0000 		call getTempIsparit
 3612               	.LVL352:
 3613 0174 6093 0000 		sts Ti,r22
 3614 0178 7093 0000 		sts Ti+1,r23
 3615 017c 8093 0000 		sts Ti+2,r24
 3616 0180 9093 0000 		sts Ti+3,r25
 492:main.c        **** 	delay_ms(100);
 3617               		.loc 1 492 0
 3618 0184 84E6      		ldi r24,lo8(100)
 3619 0186 90E0      		ldi r25,0
 3620 0188 0E94 0000 		call delay_ms
 3621               	.LVL353:
 3622 018c 00C0      		rjmp .L151
 3623               	.LVL354:
 3624               	.L276:
 493:main.c        ****     }
 494:main.c        **** 
 495:main.c        ****     if (vars.auto_defrost) {
 3625               		.loc 1 495 0
 3626 018e 8091 0000 		lds r24,vars+10
 3627 0192 8823      		tst r24
 3628 0194 01F0      		breq .L218
 496:main.c        **** 	tmp = vars.auto_defrost - 3;
 3629               		.loc 1 496 0
 3630 0196 0091 0000 		lds r16,vars+10
 3631 019a 0350      		subi r16,lo8(-(-3))
 3632               	.LVL355:
 497:main.c        **** 	if (Ts < tmp) {
 3633               		.loc 1 497 0
 3634 019c 4090 0000 		lds r4,Ts
 3635 01a0 5090 0000 		lds r5,Ts+1
 3636 01a4 6090 0000 		lds r6,Ts+2
 3637 01a8 7090 0000 		lds r7,Ts+3
 3638 01ac 602F      		mov r22,r16
 3639 01ae 002E      		mov __tmp_reg__,r16
 3640 01b0 000C      		lsl r0
 3641 01b2 770B      		sbc r23,r23
 3642 01b4 880B      		sbc r24,r24
 3643 01b6 990B      		sbc r25,r25
 3644 01b8 0E94 0000 		call __floatsisf
 3645               	.LVL356:
 3646 01bc A301      		movw r20,r6
 3647 01be 9201      		movw r18,r4
 3648 01c0 0E94 0000 		call __gtsf2
 3649               	.LVL357:
 3650 01c4 1816      		cp __zero_reg__,r24
 3651 01c6 04F4      		brge .L270
 498:main.c        **** 	    smode = smode_hi_mode;
 3652               		.loc 1 498 0
 3653 01c8 64E6      		ldi r22,lo8(100)
 3654 01ca E62E      		mov r14,r22
 3655 01cc 00C0      		rjmp .L153
 3656               	.LVL358:
 3657               	.L218:
 396:main.c        ****     int8_t bdelay = 0;
 3658               		.loc 1 396 0
 3659 01ce E12C      		mov r14,__zero_reg__
 487:main.c        **** 	wdt_reset();
 3660               		.loc 1 487 0
 3661 01d0 0FEF      		ldi r16,lo8(-1)
 3662 01d2 00C0      		rjmp .L153
 3663               	.LVL359:
 3664               	.L270:
 396:main.c        ****     int8_t bdelay = 0;
 3665               		.loc 1 396 0
 3666 01d4 E12C      		mov r14,__zero_reg__
 3667               	.LVL360:
 3668               	.L153:
 499:main.c        **** 	}
 500:main.c        ****     }
 501:main.c        **** 
 502:main.c        ****     //Ipid = (float) vars.setup_temp;
 503:main.c        ****     //Ipid = check_rangef(-(100 / PID_I_KFC), Ipid - Ts, 100 / PID_I_KFC);
 504:main.c        **** 
 505:main.c        ****     setup_display();
 3669               		.loc 1 505 0
 3670 01d6 0E94 0000 		call setup_display
 3671               	.LVL361:
 506:main.c        ****     wdt_reset();
 3672               		.loc 1 506 0
 3673               	/* #APP */
 3674               	 ;  506 "main.c" 1
 3675 01da A895      		wdr
 3676               	 ;  0 "" 2
 507:main.c        ****     /*
 508:main.c        ****      if (!get_input(IN_FROST_BTN)) { // Если при включении нажата Setup ср
 509:main.c        ****      smode = 1;
 510:main.c        ****      tmp = 'c';
 511:main.c        ****      }
 512:main.c        ****      */
 513:main.c        ****     vent_enc = 0;
 3677               		.loc 1 513 0
 3678               	/* #NOAPP */
 3679 01dc 1092 0000 		sts vent_enc,__zero_reg__
 514:main.c        ****     temp_enc = 0;
 3680               		.loc 1 514 0
 3681 01e0 1092 0000 		sts temp_enc,__zero_reg__
 472:main.c        **** 
 3682               		.loc 1 472 0
 3683 01e4 10E0      		ldi r17,0
 515:main.c        **** 
 516:main.c        ****     while (1) {
 517:main.c        **** 	if (get_input(IN_ACC)) { //ACC on
 518:main.c        **** 
 519:main.c        **** 	    if (smode == smode_hi_mode) {	//HI_MODE
 520:main.c        **** 		time_cnt = 0;
 521:main.c        **** 		tmp = 10;
 522:main.c        **** 		if (get_input(IN_BTN_HI_MODE)) { // не нажата
 523:main.c        **** 		    recycleSwitch(); //recycle mode on
 524:main.c        **** 		    hiAirSwitch(); // обдув на лобовое
 525:main.c        **** 		    smode = smode_hi_mode_work;
 526:main.c        **** 		}
 527:main.c        **** 
 528:main.c        **** 		set_temp(100, 1);
 529:main.c        **** 		set_vent_seg(tmp, 1);
 530:main.c        **** 
 531:main.c        **** 		Disp_Num_Seg(NUM0_SEG, 'H', 0);
 532:main.c        **** 		Disp_Num_Seg(NUM1_SEG, 'I', 0);
 533:main.c        **** 
 534:main.c        **** 	    } else if (smode == smode_hi_mode_work) {		//HI_MODE WORK
 535:main.c        **** 		//if (time_cnt > 2)
 536:main.c        **** 		{
 537:main.c        **** 		    uint8_t ti = get_input(IN_BTN_HI_MODE);
 538:main.c        **** 		    uint8_t tp1 = get_input(OUT_BTN_MODE_UP_DOWN);
 539:main.c        **** 		    if ((time_cnt > HI_HOT_TMO_S && (int) getTempSalon() > HI_HOT_T_c) || !ti || !tp1) {
 540:main.c        **** 			smode = 0;
 541:main.c        **** 			time_cnt = 0;
 542:main.c        **** 			recycleSwitch(); //recycle mode off
 543:main.c        **** 			if (ti) { // Если не нажата HI переходим в выбранный рабочи
 544:main.c        **** 			    prefAirSwitch(); // переключаем в любимый режим обдува
 545:main.c        **** 			}
 546:main.c        **** 		    }
 547:main.c        **** 		}
 548:main.c        **** 
 549:main.c        **** 		if (vent_enc) {
 550:main.c        **** 		    tmp = check_range(0, tmp + vent_enc, VENT_SEGs);
 551:main.c        **** 		    time_cnt = 0;
 552:main.c        **** 		    vent_enc = 0;
 553:main.c        **** 		}
 554:main.c        **** 
 555:main.c        **** 		set_temp(100, 1); // Синхронизация Т к 100%
 556:main.c        **** 		set_vent_seg(tmp, 1);
 557:main.c        **** 
 558:main.c        **** 		//Disp_Num_Seg(NUM0_SEG, 'H', 0);
 559:main.c        **** 		//Disp_Num_Seg(NUM1_SEG, 'I', 0);
 560:main.c        **** 		Disp_Bars(tmp);
 561:main.c        **** 
 562:main.c        **** 	    } else if (smode) {		//Setup mode
 563:main.c        **** 
 564:main.c        **** 		if (time_cnt > SETUP_TMO_S) {
 565:main.c        **** 		    smode = 0;
 566:main.c        **** 		    time_cnt = 0;
 567:main.c        **** 		    disp_num = vars.setup_temp;
 568:main.c        **** 		    //cbtn = 0;
 569:main.c        **** 		    if (vars.wmode == wmode_auto) {
 570:main.c        **** 			set_vent_seg(1, 1);
 571:main.c        **** 			set_temp(0, 1);
 572:main.c        **** 		    }
 573:main.c        **** 		    continue;
 574:main.c        **** 		}
 575:main.c        **** 
 576:main.c        **** 		if (vent_enc) { // переключаем пункты настройки
 577:main.c        **** 		    smode = check_range(1, smode + vent_enc, smode_SETUP_LAST - 1);
 578:main.c        **** 		    time_cnt = 0;
 579:main.c        **** 		    vent_enc = 0;
 580:main.c        **** 		    disp_num = smode - 1;
 581:main.c        **** 		    tmp = 'c';
 582:main.c        **** 		}
 583:main.c        **** 
 584:main.c        **** 		int8_t lf = 0;
 585:main.c        **** 		if (time_cnt > 0) {
 586:main.c        **** 		    lf = 1;
 587:main.c        **** 		}
 588:main.c        **** 
 589:main.c        **** 		if (temp_enc) { //изменение параметра
 590:main.c        **** 		    lf = 1;
 591:main.c        **** 		    time_cnt = 0;
 592:main.c        **** 		}
 593:main.c        **** 
 594:main.c        **** 		if (lf) {
 595:main.c        **** 		    tmp = 0;
 596:main.c        **** 		    switch (smode) {
 597:main.c        **** 		    case smode_manual: // в ручной режим
 598:main.c        **** 			tmp = 'r';
 599:main.c        **** 			vars.wmode = check_range(0, vars.wmode + temp_enc, 1);
 600:main.c        **** 			if (vars.wmode == wmode_auto) {
 601:main.c        **** 			    disp_num = 'A';
 602:main.c        **** 			} else {
 603:main.c        **** 			    disp_num = 'P';
 604:main.c        **** 			}
 605:main.c        **** 			break;
 606:main.c        **** 		    case smode_auto_defrost: // авто подогрев лобового при включен
 607:main.c        **** 			tmp = 'H';
 608:main.c        **** 			vars.auto_defrost = check_range(0, vars.auto_defrost + temp_enc, 5);
 609:main.c        **** 			disp_num = vars.auto_defrost;
 610:main.c        **** 			break;
 611:main.c        **** 		    case smode_cnd_frost: //температура обмерзания кондиционера
 612:main.c        **** 			tmp = 'C';
 613:main.c        **** 			vars.const_cnd_frost_t = check_range(0, vars.const_cnd_frost_t + temp_enc, 9);
 614:main.c        **** 			disp_num = vars.const_cnd_frost_t;
 615:main.c        **** 			break;
 616:main.c        **** 		    case smode_seg_delay: // пропуск изменений заслонки
 617:main.c        **** 			tmp = 'd';
 618:main.c        **** 			vars.temp_seg_delay = check_range(0, vars.temp_seg_delay + temp_enc, 5);
 619:main.c        **** 			disp_num = vars.temp_seg_delay;
 620:main.c        **** 			break;
 621:main.c        **** 		    case smode_vent_kfc: //кфц отклонения вентилятора на изменен
 622:main.c        **** 			tmp = 'u';
 623:main.c        **** 			vars.vent_var_kfc = check_range(0, vars.vent_var_kfc + temp_enc, 20);
 624:main.c        **** 			disp_num = vars.vent_var_kfc;
 625:main.c        **** 			break;
 626:main.c        **** 		    case smode_pid_P_kfc: //P кфц
 627:main.c        **** 			//tmp = 'P';
 628:main.c        **** 			vars.pid_P_kfc = check_range(1, vars.pid_P_kfc + temp_enc, 20);
 629:main.c        **** 			disp_num = vars.pid_P_kfc;
 630:main.c        **** 			break;
 631:main.c        **** 		    case smode_pid_I_kfc: //I кфц
 632:main.c        **** 			//tmp = 'I';
 633:main.c        **** 			vars.pid_I_kfc = check_range(1, vars.pid_I_kfc + temp_enc, 30);
 634:main.c        **** 			disp_num = vars.pid_I_kfc;
 635:main.c        **** 			break;
 636:main.c        **** 		    case smode_load_def: // загрузить данные по умолчанию
 637:main.c        **** 			tmp = 'L';
 638:main.c        **** 			disp_num = '?';
 639:main.c        **** 			if (!get_input(IN_FROST_BTN)) { // press setup mode
 640:main.c        **** 			    set_def_vals();
 641:main.c        **** 			    smode = 1;
 642:main.c        **** 			    disp_num = 0;
 643:main.c        **** 			    tmp = 'c';
 644:main.c        **** 			    time_cnt = 0;
 645:main.c        **** 			}
 646:main.c        **** 			break;
 647:main.c        **** 		    case smode_disp_T_isp: //просмотр датчиков
 648:main.c        **** 			disp_num = getTempIsparit();
 649:main.c        **** 			break;
 650:main.c        **** 		    case smode_disp_T_salon:
 651:main.c        **** 			disp_num = getTempSalon();
 652:main.c        **** 			break;
 653:main.c        **** 		    }
 654:main.c        **** 		    temp_enc = 0;
 655:main.c        **** 		}
 656:main.c        **** 
 657:main.c        **** 		if (tmp) {
 658:main.c        **** 		    Disp_Num_Seg(NUM0_SEG, tmp, 0);
 659:main.c        **** 		    Disp_Num_Seg(NUM1_SEG, disp_num, 0);
 660:main.c        **** 		} else {
 661:main.c        **** 		    Disp_Num(disp_num, 0);
 662:main.c        **** 		}
 663:main.c        **** 		Disp_Bars(smode);
 664:main.c        **** 
 665:main.c        **** 	    } else { // work mode
 666:main.c        **** 
 667:main.c        **** 		if (vars.wmode == wmode_auto) {
 668:main.c        **** 		    switch (time_cnt) {
 669:main.c        **** 		    case 0:
 670:main.c        **** 			setup_display();
 671:main.c        **** 			time_cnt++;
 672:main.c        **** 			break;
 673:main.c        **** 		    case 1 ... 6:
 674:main.c        **** 			break;
 675:main.c        **** 		    case 7:
 676:main.c        **** 			Ti = getTempIsparit();
 677:main.c        **** 			time_cnt = 8;
 678:main.c        **** 			break;
 679:main.c        **** 		    case 8:
 680:main.c        **** 			break;
 681:main.c        **** 		    case 9:
 682:main.c        **** 			Ts = getTempSalon();
 683:main.c        **** 			float t = Ts + 0.4;
 684:main.c        **** 			disp_num = t;
 685:main.c        **** 			time_cnt++;
 686:main.c        **** 			break;
 687:main.c        **** 		    case 10:
 688:main.c        **** 			break;
 689:main.c        **** 		    case 11: //calc
 690:main.c        **** 			calcVal();
 691:main.c        **** 			time_cnt++;
 692:main.c        **** 			break;
 693:main.c        **** 		    case 12:
 694:main.c        **** 			break;
 695:main.c        **** 		    case 13:
 696:main.c        **** 			set_temp(temp_out_prc, 1);
 697:main.c        **** 			time_cnt++;
 698:main.c        **** 			break;
 699:main.c        **** 		    case 14:
 700:main.c        **** 			break;
 701:main.c        **** 		    case 15:
 702:main.c        **** 			set_vent_prc(vent_add_prc, 1);
 703:main.c        **** 			disp_bar = vent_seg_cur;
 704:main.c        **** 			SET_FLAG(f_num_dot)
 705:main.c        **** 			time_cnt++;
 706:main.c        **** 			break;
 707:main.c        **** 		    default: //  цикл
 708:main.c        **** 			time_cnt = 0;
 709:main.c        **** 			CLR_FLAG(f_num_dot)
 710:main.c        **** 		    }
 711:main.c        **** 
 712:main.c        **** 		    if (vent_enc) {
 713:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEGs + 2);
 714:main.c        **** 			disp_bar = vars.vent_nom_seg;
 715:main.c        **** 			time_cnt = 10;
 716:main.c        **** 			vent_enc = 0;
 717:main.c        **** 		    }
 718:main.c        **** 
 719:main.c        **** 		    if (temp_enc) {
 720:main.c        **** 			vars.setup_temp = check_range(15, vars.setup_temp + temp_enc, 30);
 721:main.c        **** 			disp_num = vars.setup_temp;
 722:main.c        **** 			time_cnt = 0;
 723:main.c        **** 			temp_enc = 0;
 724:main.c        **** 		    }
 725:main.c        **** 
 726:main.c        **** 		} else { // manual
 727:main.c        **** 
 728:main.c        **** 		    if (time_cnt > 10) {
 729:main.c        **** 			setup_display();
 730:main.c        **** 			time_cnt = 0;
 731:main.c        **** 		    }
 732:main.c        **** 
 733:main.c        **** 		    if (vent_enc) {
 734:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEGs);
 735:main.c        **** 			vent_enc = 0;
 736:main.c        **** 		    }
 737:main.c        **** 
 738:main.c        **** 		    if (temp_enc) {
 739:main.c        **** 			vars.temp_seg = check_range(0, vars.temp_seg + temp_enc, TEMP_SEGs);
 740:main.c        **** 			temp_enc = 0;
 741:main.c        **** 		    }
 742:main.c        **** 		    disp_bar = vars.vent_nom_seg;
 743:main.c        **** 		    disp_num = seg2Prc(TEMP_SEGs, vars.temp_seg);
 744:main.c        **** 		    set_vent_seg(vars.vent_nom_seg, 0);
 745:main.c        **** 		    set_temp(disp_num, 0);
 746:main.c        **** 		    switch_cond(1);
 747:main.c        **** 		}
 748:main.c        **** // логика
 749:main.c        **** // кнопки
 750:main.c        **** 		if (!get_input(IN_BTN_HI_MODE)) { // to hi hot mode
 751:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 752:main.c        **** 			smode = smode_hi_mode;
 753:main.c        **** 		    }
 754:main.c        **** 		    time_cnt = 0;
 755:main.c        **** 		} else if (!get_input(IN_FROST_BTN)) { // to setup mode
 756:main.c        **** 		    SET_FLAG(f_cond_btn_press);
 757:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 758:main.c        **** 			smode = 1;
 759:main.c        **** 			disp_num = 0;
 760:main.c        **** 			tmp = 'c';
 761:main.c        **** 			CLR_FLAG(f_cond_btn_press);
 762:main.c        **** 			vent_enc = 0;
 763:main.c        **** 			temp_enc = 0;
 764:main.c        **** 		    }
 765:main.c        **** 		    time_cnt = 0;
 766:main.c        **** 		} else {
 767:main.c        **** 		    if (TST_FLAG(f_cond_btn_press)) {
 768:main.c        **** 			if (vars.cond_enabled) {
 769:main.c        **** 			    vars.cond_enabled = 0;
 770:main.c        **** 			} else {
 771:main.c        **** 			    vars.cond_enabled = 1;
 3684               		.loc 1 771 0
 3685 01e6 AA24      		clr r10
 3686 01e8 A394      		inc r10
 3687               	.LBB132:
 3688               	.LBB133:
  44:calc.c        ****     return tmp;
 3689               		.loc 3 44 0
 3690 01ea 5FE0      		ldi r21,lo8(15)
 3691 01ec C52E      		mov r12,r21
 3692 01ee D12C      		mov r13,__zero_reg__
 3693               	.LVL362:
 3694               	.L155:
 3695               	.LBE133:
 3696               	.LBE132:
 517:main.c        **** 
 3697               		.loc 1 517 0
 3698 01f0 339B      		sbis 0x6,3
 3699 01f2 00C0      		rjmp .L156
 519:main.c        **** 		time_cnt = 0;
 3700               		.loc 1 519 0
 3701 01f4 24E6      		ldi r18,lo8(100)
 3702 01f6 E212      		cpse r14,r18
 3703 01f8 00C0      		rjmp .L157
 3704               	.LVL363:
 522:main.c        **** 		    recycleSwitch(); //recycle mode on
 3705               		.loc 1 522 0
 3706 01fa 349B      		sbis 0x6,4
 3707 01fc 00C0      		rjmp .L158
 523:main.c        **** 		    hiAirSwitch(); // обдув на лобовое
 3708               		.loc 1 523 0
 3709 01fe 0E94 0000 		call recycleSwitch
 3710               	.LVL364:
 524:main.c        **** 		    smode = smode_hi_mode_work;
 3711               		.loc 1 524 0
 3712 0202 0E94 0000 		call hiAirSwitch
 3713               	.LVL365:
 525:main.c        **** 		}
 3714               		.loc 1 525 0
 3715 0206 45E6      		ldi r20,lo8(101)
 3716 0208 E42E      		mov r14,r20
 3717               	.LVL366:
 3718               	.L158:
 528:main.c        **** 		set_vent_seg(tmp, 1);
 3719               		.loc 1 528 0
 3720 020a 61E0      		ldi r22,lo8(1)
 3721 020c 84E6      		ldi r24,lo8(100)
 3722 020e 0E94 0000 		call set_temp
 3723               	.LVL367:
 529:main.c        **** 
 3724               		.loc 1 529 0
 3725 0212 61E0      		ldi r22,lo8(1)
 3726 0214 8AE0      		ldi r24,lo8(10)
 3727 0216 0E94 0000 		call set_vent_seg
 3728               	.LVL368:
 531:main.c        **** 		Disp_Num_Seg(NUM1_SEG, 'I', 0);
 3729               		.loc 1 531 0
 3730 021a 40E0      		ldi r20,0
 3731 021c 68E4      		ldi r22,lo8(72)
 3732 021e 83E0      		ldi r24,lo8(3)
 3733 0220 0E94 0000 		call Disp_Num_Seg
 3734               	.LVL369:
 532:main.c        **** 
 3735               		.loc 1 532 0
 3736 0224 40E0      		ldi r20,0
 3737 0226 69E4      		ldi r22,lo8(73)
 3738 0228 84E0      		ldi r24,lo8(4)
 3739 022a 0E94 0000 		call Disp_Num_Seg
 3740               	.LVL370:
 520:main.c        **** 		tmp = 10;
 3741               		.loc 1 520 0
 3742 022e 10E0      		ldi r17,0
 521:main.c        **** 		if (get_input(IN_BTN_HI_MODE)) { // не нажата
 3743               		.loc 1 521 0
 3744 0230 0AE0      		ldi r16,lo8(10)
 3745 0232 00C0      		rjmp .L159
 3746               	.LVL371:
 3747               	.L157:
 534:main.c        **** 		//if (time_cnt > 2)
 3748               		.loc 1 534 0
 3749 0234 85E6      		ldi r24,lo8(101)
 3750 0236 E812      		cpse r14,r24
 3751 0238 00C0      		rjmp .L160
 3752               	.LBB135:
 537:main.c        **** 		    uint8_t tp1 = get_input(OUT_BTN_MODE_UP_DOWN);
 3753               		.loc 1 537 0
 3754 023a 86B1      		in r24,0x6
 3755 023c 8071      		andi r24,lo8(16)
 3756 023e 982E      		mov r9,r24
 3757               	.LVL372:
 538:main.c        **** 		    if ((time_cnt > HI_HOT_TMO_S && (int) getTempSalon() > HI_HOT_T_c) || !ti || !tp1) {
 3758               		.loc 1 538 0
 3759 0240 86B0      		in r8,0x6
 3760               	.LVL373:
 539:main.c        **** 			smode = 0;
 3761               		.loc 1 539 0
 3762 0242 113F      		cpi r17,lo8(-15)
 3763 0244 00F4      		brsh .L161
 3764               	.L164:
 3765 0246 9920      		tst r9
 3766 0248 01F0      		breq .L162
 3767 024a 00C0      		rjmp .L277
 3768               	.L161:
 539:main.c        **** 			smode = 0;
 3769               		.loc 1 539 0 is_stmt 0 discriminator 1
 3770 024c 0E94 0000 		call getTempSalon
 3771               	.LVL374:
 3772 0250 0E94 0000 		call __fixsfsi
 3773               	.LVL375:
 3774 0254 6B30      		cpi r22,11
 3775 0256 7105      		cpc r23,__zero_reg__
 3776 0258 04F0      		brlt .L164
 3777               	.L162:
 3778               	.LVL376:
 542:main.c        **** 			if (ti) { // Если не нажата HI переходим в выбранный рабочи
 3779               		.loc 1 542 0 is_stmt 1
 3780 025a 0E94 0000 		call recycleSwitch
 3781               	.LVL377:
 543:main.c        **** 			    prefAirSwitch(); // переключаем в любимый режим обдува
 3782               		.loc 1 543 0
 3783 025e 9920      		tst r9
 3784 0260 01F0      		breq .L272
 544:main.c        **** 			}
 3785               		.loc 1 544 0
 3786 0262 0E94 0000 		call prefAirSwitch
 3787               	.LVL378:
 3788 0266 00C0      		rjmp .L272
 3789               	.LVL379:
 3790               	.L277:
 539:main.c        **** 			smode = 0;
 3791               		.loc 1 539 0 discriminator 4
 3792 0268 80FE      		sbrs r8,0
 3793 026a 00C0      		rjmp .L162
 3794 026c 00C0      		rjmp .L166
 3795               	.LVL380:
 3796               	.L272:
 540:main.c        **** 			time_cnt = 0;
 3797               		.loc 1 540 0
 3798 026e E12C      		mov r14,__zero_reg__
 541:main.c        **** 			recycleSwitch(); //recycle mode off
 3799               		.loc 1 541 0
 3800 0270 10E0      		ldi r17,0
 3801               	.LVL381:
 3802               	.L166:
 3803               	.LBE135:
 549:main.c        **** 		    tmp = check_range(0, tmp + vent_enc, VENT_SEGs);
 3804               		.loc 1 549 0
 3805 0272 8091 0000 		lds r24,vent_enc
 3806 0276 8823      		tst r24
 3807 0278 01F0      		breq .L167
 550:main.c        **** 		    time_cnt = 0;
 3808               		.loc 1 550 0
 3809 027a 6091 0000 		lds r22,vent_enc
 3810 027e 062E      		mov __tmp_reg__,r22
 3811 0280 000C      		lsl r0
 3812 0282 770B      		sbc r23,r23
 3813 0284 600F      		add r22,r16
 3814 0286 711D      		adc r23,__zero_reg__
 3815 0288 07FD      		sbrc r16,7
 3816 028a 7A95      		dec r23
 3817 028c 48E0      		ldi r20,lo8(8)
 3818 028e 50E0      		ldi r21,0
 3819 0290 80E0      		ldi r24,0
 3820 0292 90E0      		ldi r25,0
 3821 0294 0E94 0000 		call check_range
 3822               	.LVL382:
 3823 0298 082F      		mov r16,r24
 3824               	.LVL383:
 552:main.c        **** 		}
 3825               		.loc 1 552 0
 3826 029a 1092 0000 		sts vent_enc,__zero_reg__
 551:main.c        **** 		    vent_enc = 0;
 3827               		.loc 1 551 0
 3828 029e 10E0      		ldi r17,0
 3829               	.LVL384:
 3830               	.L167:
 555:main.c        **** 		set_vent_seg(tmp, 1);
 3831               		.loc 1 555 0
 3832 02a0 61E0      		ldi r22,lo8(1)
 3833 02a2 84E6      		ldi r24,lo8(100)
 3834 02a4 0E94 0000 		call set_temp
 3835               	.LVL385:
 556:main.c        **** 
 3836               		.loc 1 556 0
 3837 02a8 61E0      		ldi r22,lo8(1)
 3838 02aa 802F      		mov r24,r16
 3839 02ac 0E94 0000 		call set_vent_seg
 3840               	.LVL386:
 560:main.c        **** 
 3841               		.loc 1 560 0
 3842 02b0 802F      		mov r24,r16
 3843 02b2 00C0      		rjmp .L273
 3844               	.LVL387:
 3845               	.L160:
 562:main.c        **** 
 3846               		.loc 1 562 0
 3847 02b4 EE20      		tst r14
 3848 02b6 01F4      		brne .+2
 3849 02b8 00C0      		rjmp .L168
 3850               	.LBB136:
 564:main.c        **** 		    smode = 0;
 3851               		.loc 1 564 0
 3852 02ba 1630      		cpi r17,lo8(6)
 3853 02bc 00F0      		brlo .L169
 3854               	.LVL388:
 567:main.c        **** 		    //cbtn = 0;
 3855               		.loc 1 567 0
 3856 02be F090 0000 		lds r15,vars+1
 3857               	.LVL389:
 569:main.c        **** 			set_vent_seg(1, 1);
 3858               		.loc 1 569 0
 3859 02c2 8091 0000 		lds r24,vars
 3860 02c6 8823      		tst r24
 3861 02c8 01F0      		breq .L278
 3862               	.L220:
 565:main.c        **** 		    time_cnt = 0;
 3863               		.loc 1 565 0
 3864 02ca E12C      		mov r14,__zero_reg__
 566:main.c        **** 		    disp_num = vars.setup_temp;
 3865               		.loc 1 566 0
 3866 02cc 10E0      		ldi r17,0
 3867 02ce 00C0      		rjmp .L155
 3868               	.L278:
 570:main.c        **** 			set_temp(0, 1);
 3869               		.loc 1 570 0
 3870 02d0 61E0      		ldi r22,lo8(1)
 3871 02d2 81E0      		ldi r24,lo8(1)
 3872 02d4 0E94 0000 		call set_vent_seg
 3873               	.LVL390:
 571:main.c        **** 		    }
 3874               		.loc 1 571 0
 3875 02d8 61E0      		ldi r22,lo8(1)
 3876 02da 80E0      		ldi r24,0
 3877 02dc 0E94 0000 		call set_temp
 3878               	.LVL391:
 3879 02e0 00C0      		rjmp .L220
 3880               	.LVL392:
 3881               	.L169:
 576:main.c        **** 		    smode = check_range(1, smode + vent_enc, smode_SETUP_LAST - 1);
 3882               		.loc 1 576 0
 3883 02e2 8091 0000 		lds r24,vent_enc
 3884 02e6 8823      		tst r24
 3885 02e8 01F0      		breq .L171
 577:main.c        **** 		    time_cnt = 0;
 3886               		.loc 1 577 0
 3887 02ea 6091 0000 		lds r22,vent_enc
 3888 02ee 062E      		mov __tmp_reg__,r22
 3889 02f0 000C      		lsl r0
 3890 02f2 770B      		sbc r23,r23
 3891 02f4 6E0D      		add r22,r14
 3892 02f6 711D      		adc r23,__zero_reg__
 3893 02f8 E7FC      		sbrc r14,7
 3894 02fa 7A95      		dec r23
 3895 02fc 4AE0      		ldi r20,lo8(10)
 3896 02fe 50E0      		ldi r21,0
 3897 0300 81E0      		ldi r24,lo8(1)
 3898 0302 90E0      		ldi r25,0
 3899 0304 0E94 0000 		call check_range
 3900               	.LVL393:
 3901 0308 E82E      		mov r14,r24
 3902               	.LVL394:
 579:main.c        **** 		    disp_num = smode - 1;
 3903               		.loc 1 579 0
 3904 030a 1092 0000 		sts vent_enc,__zero_reg__
 580:main.c        **** 		    tmp = 'c';
 3905               		.loc 1 580 0
 3906 030e FF24      		clr r15
 3907 0310 FA94      		dec r15
 3908               	.LVL395:
 3909 0312 F80E      		add r15,r24
 3910               	.LVL396:
 581:main.c        **** 		}
 3911               		.loc 1 581 0
 3912 0314 03E6      		ldi r16,lo8(99)
 3913 0316 00C0      		rjmp .L172
 3914               	.LVL397:
 3915               	.L171:
 585:main.c        **** 		    lf = 1;
 3916               		.loc 1 585 0
 3917 0318 1111      		cpse r17,__zero_reg__
 3918 031a 00C0      		rjmp .L221
 3919               	.LVL398:
 3920               	.L172:
 581:main.c        **** 		}
 3921               		.loc 1 581 0
 3922 031c 10E0      		ldi r17,0
 584:main.c        **** 		if (time_cnt > 0) {
 3923               		.loc 1 584 0
 3924 031e 80E0      		ldi r24,0
 3925 0320 00C0      		rjmp .L173
 3926               	.LVL399:
 3927               	.L221:
 586:main.c        **** 		}
 3928               		.loc 1 586 0
 3929 0322 81E0      		ldi r24,lo8(1)
 3930               	.LVL400:
 3931               	.L173:
 589:main.c        **** 		    lf = 1;
 3932               		.loc 1 589 0
 3933 0324 9091 0000 		lds r25,temp_enc
 3934 0328 9111      		cpse r25,__zero_reg__
 3935 032a 00C0      		rjmp .L222
 3936               	.LVL401:
 594:main.c        **** 		    tmp = 0;
 3937               		.loc 1 594 0
 3938 032c 8823      		tst r24
 3939 032e 01F4      		brne .+2
 3940 0330 00C0      		rjmp .L175
 3941 0332 00C0      		rjmp .L174
 3942               	.LVL402:
 3943               	.L222:
 591:main.c        **** 		}
 3944               		.loc 1 591 0
 3945 0334 10E0      		ldi r17,0
 3946               	.L174:
 3947               	.LVL403:
 596:main.c        **** 		    case smode_manual: // в ручной режим
 3948               		.loc 1 596 0
 3949 0336 8E2D      		mov r24,r14
 3950 0338 0E2C      		mov __tmp_reg__,r14
 3951 033a 000C      		lsl r0
 3952 033c 990B      		sbc r25,r25
 3953 033e AA0B      		sbc r26,r26
 3954 0340 BB0B      		sbc r27,r27
 3955 0342 FC01      		movw r30,r24
 3956 0344 3197      		sbiw r30,1
 3957 0346 EA30      		cpi r30,10
 3958 0348 F105      		cpc r31,__zero_reg__
 3959 034a 00F0      		brlo .+2
 3960 034c 00C0      		rjmp .L223
 3961 034e E050      		subi r30,lo8(-(gs(.L178)))
 3962 0350 F040      		sbci r31,hi8(-(gs(.L178)))
 3963 0352 0C94 0000 		jmp __tablejump2__
 3964               		.section	.progmem.gcc_sw_table,"a",@progbits
 3965               		.p2align	1
 3966               	.L178:
 3967 0000 0000      		.word gs(.L177)
 3968 0002 0000      		.word gs(.L179)
 3969 0004 0000      		.word gs(.L180)
 3970 0006 0000      		.word gs(.L181)
 3971 0008 0000      		.word gs(.L182)
 3972 000a 0000      		.word gs(.L183)
 3973 000c 0000      		.word gs(.L184)
 3974 000e 0000      		.word gs(.L185)
 3975 0010 0000      		.word gs(.L186)
 3976 0012 0000      		.word gs(.L187)
 3977               		.section	.text.startup
 3978               	.L177:
 3979               	.LVL404:
 599:main.c        **** 			if (vars.wmode == wmode_auto) {
 3980               		.loc 1 599 0
 3981 0356 8091 0000 		lds r24,vars
 3982 035a 6091 0000 		lds r22,temp_enc
 3983 035e 062E      		mov __tmp_reg__,r22
 3984 0360 000C      		lsl r0
 3985 0362 770B      		sbc r23,r23
 3986 0364 680F      		add r22,r24
 3987 0366 711D      		adc r23,__zero_reg__
 3988 0368 41E0      		ldi r20,lo8(1)
 3989 036a 50E0      		ldi r21,0
 3990 036c 80E0      		ldi r24,0
 3991 036e 90E0      		ldi r25,0
 3992 0370 0E94 0000 		call check_range
 3993               	.LVL405:
 3994 0374 8093 0000 		sts vars,r24
 600:main.c        **** 			    disp_num = 'A';
 3995               		.loc 1 600 0
 3996 0378 8091 0000 		lds r24,vars
 598:main.c        **** 			vars.wmode = check_range(0, vars.wmode + temp_enc, 1);
 3997               		.loc 1 598 0
 3998 037c 02E7      		ldi r16,lo8(114)
 600:main.c        **** 			    disp_num = 'A';
 3999               		.loc 1 600 0
 4000 037e 8823      		tst r24
 4001 0380 01F4      		brne .+2
 4002 0382 00C0      		rjmp .L224
 603:main.c        **** 			}
 4003               		.loc 1 603 0
 4004 0384 30E5      		ldi r19,lo8(80)
 4005 0386 F32E      		mov r15,r19
 4006               	.LVL406:
 4007 0388 00C0      		rjmp .L176
 4008               	.LVL407:
 4009               	.L179:
 608:main.c        **** 			disp_num = vars.auto_defrost;
 4010               		.loc 1 608 0
 4011 038a 8091 0000 		lds r24,vars+10
 4012 038e 6091 0000 		lds r22,temp_enc
 4013 0392 062E      		mov __tmp_reg__,r22
 4014 0394 000C      		lsl r0
 4015 0396 770B      		sbc r23,r23
 4016 0398 680F      		add r22,r24
 4017 039a 711D      		adc r23,__zero_reg__
 4018 039c 87FD      		sbrc r24,7
 4019 039e 7A95      		dec r23
 4020 03a0 45E0      		ldi r20,lo8(5)
 4021 03a2 50E0      		ldi r21,0
 4022 03a4 80E0      		ldi r24,0
 4023 03a6 90E0      		ldi r25,0
 4024 03a8 0E94 0000 		call check_range
 4025               	.LVL408:
 4026 03ac 8093 0000 		sts vars+10,r24
 609:main.c        **** 			break;
 4027               		.loc 1 609 0
 4028 03b0 F090 0000 		lds r15,vars+10
 4029               	.LVL409:
 607:main.c        **** 			vars.auto_defrost = check_range(0, vars.auto_defrost + temp_enc, 5);
 4030               		.loc 1 607 0
 4031 03b4 08E4      		ldi r16,lo8(72)
 610:main.c        **** 		    case smode_cnd_frost: //температура обмерзания кондиционера
 4032               		.loc 1 610 0
 4033 03b6 00C0      		rjmp .L176
 4034               	.LVL410:
 4035               	.L180:
 613:main.c        **** 			disp_num = vars.const_cnd_frost_t;
 4036               		.loc 1 613 0
 4037 03b8 8091 0000 		lds r24,vars+8
 4038 03bc 6091 0000 		lds r22,temp_enc
 4039 03c0 062E      		mov __tmp_reg__,r22
 4040 03c2 000C      		lsl r0
 4041 03c4 770B      		sbc r23,r23
 4042 03c6 680F      		add r22,r24
 4043 03c8 711D      		adc r23,__zero_reg__
 4044 03ca 87FD      		sbrc r24,7
 4045 03cc 7A95      		dec r23
 4046 03ce 49E0      		ldi r20,lo8(9)
 4047 03d0 50E0      		ldi r21,0
 4048 03d2 80E0      		ldi r24,0
 4049 03d4 90E0      		ldi r25,0
 4050 03d6 0E94 0000 		call check_range
 4051               	.LVL411:
 4052 03da 8093 0000 		sts vars+8,r24
 614:main.c        **** 			break;
 4053               		.loc 1 614 0
 4054 03de F090 0000 		lds r15,vars+8
 4055               	.LVL412:
 612:main.c        **** 			vars.const_cnd_frost_t = check_range(0, vars.const_cnd_frost_t + temp_enc, 9);
 4056               		.loc 1 612 0
 4057 03e2 03E4      		ldi r16,lo8(67)
 615:main.c        **** 		    case smode_seg_delay: // пропуск изменений заслонки
 4058               		.loc 1 615 0
 4059 03e4 00C0      		rjmp .L176
 4060               	.LVL413:
 4061               	.L181:
 618:main.c        **** 			disp_num = vars.temp_seg_delay;
 4062               		.loc 1 618 0
 4063 03e6 8091 0000 		lds r24,vars+7
 4064 03ea 6091 0000 		lds r22,temp_enc
 4065 03ee 062E      		mov __tmp_reg__,r22
 4066 03f0 000C      		lsl r0
 4067 03f2 770B      		sbc r23,r23
 4068 03f4 680F      		add r22,r24
 4069 03f6 711D      		adc r23,__zero_reg__
 4070 03f8 87FD      		sbrc r24,7
 4071 03fa 7A95      		dec r23
 4072 03fc 45E0      		ldi r20,lo8(5)
 4073 03fe 50E0      		ldi r21,0
 4074 0400 80E0      		ldi r24,0
 4075 0402 90E0      		ldi r25,0
 4076 0404 0E94 0000 		call check_range
 4077               	.LVL414:
 4078 0408 8093 0000 		sts vars+7,r24
 619:main.c        **** 			break;
 4079               		.loc 1 619 0
 4080 040c F090 0000 		lds r15,vars+7
 4081               	.LVL415:
 617:main.c        **** 			vars.temp_seg_delay = check_range(0, vars.temp_seg_delay + temp_enc, 5);
 4082               		.loc 1 617 0
 4083 0410 04E6      		ldi r16,lo8(100)
 620:main.c        **** 		    case smode_vent_kfc: //кфц отклонения вентилятора на изменен
 4084               		.loc 1 620 0
 4085 0412 00C0      		rjmp .L176
 4086               	.LVL416:
 4087               	.L182:
 623:main.c        **** 			disp_num = vars.vent_var_kfc;
 4088               		.loc 1 623 0
 4089 0414 8091 0000 		lds r24,vars+6
 4090 0418 6091 0000 		lds r22,temp_enc
 4091 041c 062E      		mov __tmp_reg__,r22
 4092 041e 000C      		lsl r0
 4093 0420 770B      		sbc r23,r23
 4094 0422 680F      		add r22,r24
 4095 0424 711D      		adc r23,__zero_reg__
 4096 0426 87FD      		sbrc r24,7
 4097 0428 7A95      		dec r23
 4098 042a 44E1      		ldi r20,lo8(20)
 4099 042c 50E0      		ldi r21,0
 4100 042e 80E0      		ldi r24,0
 4101 0430 90E0      		ldi r25,0
 4102 0432 0E94 0000 		call check_range
 4103               	.LVL417:
 4104 0436 8093 0000 		sts vars+6,r24
 624:main.c        **** 			break;
 4105               		.loc 1 624 0
 4106 043a F090 0000 		lds r15,vars+6
 4107               	.LVL418:
 622:main.c        **** 			vars.vent_var_kfc = check_range(0, vars.vent_var_kfc + temp_enc, 20);
 4108               		.loc 1 622 0
 4109 043e 05E7      		ldi r16,lo8(117)
 625:main.c        **** 		    case smode_pid_P_kfc: //P кфц
 4110               		.loc 1 625 0
 4111 0440 00C0      		rjmp .L176
 4112               	.LVL419:
 4113               	.L183:
 628:main.c        **** 			disp_num = vars.pid_P_kfc;
 4114               		.loc 1 628 0
 4115 0442 8091 0000 		lds r24,vars+4
 4116 0446 6091 0000 		lds r22,temp_enc
 4117 044a 062E      		mov __tmp_reg__,r22
 4118 044c 000C      		lsl r0
 4119 044e 770B      		sbc r23,r23
 4120 0450 680F      		add r22,r24
 4121 0452 711D      		adc r23,__zero_reg__
 4122 0454 87FD      		sbrc r24,7
 4123 0456 7A95      		dec r23
 4124 0458 44E1      		ldi r20,lo8(20)
 4125 045a 50E0      		ldi r21,0
 4126 045c 81E0      		ldi r24,lo8(1)
 4127 045e 90E0      		ldi r25,0
 4128 0460 0E94 0000 		call check_range
 4129               	.LVL420:
 4130 0464 8093 0000 		sts vars+4,r24
 629:main.c        **** 			break;
 4131               		.loc 1 629 0
 4132 0468 F090 0000 		lds r15,vars+4
 4133               	.LVL421:
 4134 046c 00C0      		rjmp .L223
 4135               	.L184:
 633:main.c        **** 			disp_num = vars.pid_I_kfc;
 4136               		.loc 1 633 0
 4137 046e 8091 0000 		lds r24,vars+5
 4138 0472 6091 0000 		lds r22,temp_enc
 4139 0476 062E      		mov __tmp_reg__,r22
 4140 0478 000C      		lsl r0
 4141 047a 770B      		sbc r23,r23
 4142 047c 680F      		add r22,r24
 4143 047e 711D      		adc r23,__zero_reg__
 4144 0480 87FD      		sbrc r24,7
 4145 0482 7A95      		dec r23
 4146 0484 4EE1      		ldi r20,lo8(30)
 4147 0486 50E0      		ldi r21,0
 4148 0488 81E0      		ldi r24,lo8(1)
 4149 048a 90E0      		ldi r25,0
 4150 048c 0E94 0000 		call check_range
 4151               	.LVL422:
 4152 0490 8093 0000 		sts vars+5,r24
 634:main.c        **** 			break;
 4153               		.loc 1 634 0
 4154 0494 F090 0000 		lds r15,vars+5
 4155               	.LVL423:
 4156 0498 00C0      		rjmp .L223
 4157               	.L185:
 4158               	.LVL424:
 639:main.c        **** 			    set_def_vals();
 4159               		.loc 1 639 0
 4160 049a 1C99      		sbic 0x3,4
 4161 049c 00C0      		rjmp .L225
 640:main.c        **** 			    smode = 1;
 4162               		.loc 1 640 0
 4163 049e 0E94 0000 		call set_def_vals
 4164               	.LVL425:
 641:main.c        **** 			    disp_num = 0;
 4165               		.loc 1 641 0
 4166 04a2 EE24      		clr r14
 4167 04a4 E394      		inc r14
 644:main.c        **** 			}
 4168               		.loc 1 644 0
 4169 04a6 10E0      		ldi r17,0
 643:main.c        **** 			    time_cnt = 0;
 4170               		.loc 1 643 0
 4171 04a8 03E6      		ldi r16,lo8(99)
 642:main.c        **** 			    tmp = 'c';
 4172               		.loc 1 642 0
 4173 04aa F12C      		mov r15,__zero_reg__
 4174 04ac 00C0      		rjmp .L176
 4175               	.LVL426:
 4176               	.L186:
 648:main.c        **** 			break;
 4177               		.loc 1 648 0
 4178 04ae 0E94 0000 		call getTempIsparit
 4179               	.LVL427:
 4180 04b2 00C0      		rjmp .L274
 4181               	.L187:
 651:main.c        **** 			break;
 4182               		.loc 1 651 0
 4183 04b4 0E94 0000 		call getTempSalon
 4184               	.LVL428:
 4185               	.L274:
 4186 04b8 0E94 0000 		call __fixsfsi
 4187               	.LVL429:
 4188 04bc F62E      		mov r15,r22
 4189               	.LVL430:
 4190               	.L223:
 595:main.c        **** 		    switch (smode) {
 4191               		.loc 1 595 0
 4192 04be 00E0      		ldi r16,0
 4193 04c0 00C0      		rjmp .L176
 4194               	.LVL431:
 4195               	.L224:
 601:main.c        **** 			} else {
 4196               		.loc 1 601 0
 4197 04c2 21E4      		ldi r18,lo8(65)
 4198 04c4 F22E      		mov r15,r18
 4199               	.LVL432:
 4200 04c6 00C0      		rjmp .L176
 4201               	.LVL433:
 4202               	.L225:
 637:main.c        **** 			disp_num = '?';
 4203               		.loc 1 637 0
 4204 04c8 0CE4      		ldi r16,lo8(76)
 638:main.c        **** 			if (!get_input(IN_FROST_BTN)) { // press setup mode
 4205               		.loc 1 638 0
 4206 04ca 9FE3      		ldi r25,lo8(63)
 4207 04cc F92E      		mov r15,r25
 4208               	.LVL434:
 4209               	.L176:
 654:main.c        **** 		}
 4210               		.loc 1 654 0
 4211 04ce 1092 0000 		sts temp_enc,__zero_reg__
 4212               	.L175:
 657:main.c        **** 		    Disp_Num_Seg(NUM0_SEG, tmp, 0);
 4213               		.loc 1 657 0
 4214 04d2 0023      		tst r16
 4215 04d4 01F0      		breq .L188
 658:main.c        **** 		    Disp_Num_Seg(NUM1_SEG, disp_num, 0);
 4216               		.loc 1 658 0
 4217 04d6 40E0      		ldi r20,0
 4218 04d8 602F      		mov r22,r16
 4219 04da 83E0      		ldi r24,lo8(3)
 4220 04dc 0E94 0000 		call Disp_Num_Seg
 4221               	.LVL435:
 659:main.c        **** 		} else {
 4222               		.loc 1 659 0
 4223 04e0 40E0      		ldi r20,0
 4224 04e2 6F2D      		mov r22,r15
 4225 04e4 84E0      		ldi r24,lo8(4)
 4226 04e6 0E94 0000 		call Disp_Num_Seg
 4227               	.LVL436:
 4228 04ea 00C0      		rjmp .L189
 4229               	.L188:
 661:main.c        **** 		}
 4230               		.loc 1 661 0
 4231 04ec 60E0      		ldi r22,0
 4232 04ee 8F2D      		mov r24,r15
 4233 04f0 0E94 0000 		call Disp_Num
 4234               	.LVL437:
 4235               	.L189:
 663:main.c        **** 
 4236               		.loc 1 663 0
 4237 04f4 8E2D      		mov r24,r14
 4238 04f6 00C0      		rjmp .L273
 4239               	.L168:
 4240               	.LBE136:
 667:main.c        **** 		    switch (time_cnt) {
 4241               		.loc 1 667 0
 4242 04f8 8091 0000 		lds r24,vars
 4243 04fc 8111      		cpse r24,__zero_reg__
 4244 04fe 00C0      		rjmp .L190
 668:main.c        **** 		    case 0:
 4245               		.loc 1 668 0
 4246 0500 812F      		mov r24,r17
 4247 0502 90E0      		ldi r25,0
 4248 0504 8031      		cpi r24,16
 4249 0506 9105      		cpc r25,__zero_reg__
 4250 0508 00F0      		brlo .+2
 4251 050a 00C0      		rjmp .L191
 4252 050c FC01      		movw r30,r24
 4253 050e E050      		subi r30,lo8(-(gs(.L193)))
 4254 0510 F040      		sbci r31,hi8(-(gs(.L193)))
 4255 0512 0C94 0000 		jmp __tablejump2__
 4256               	.LVL438:
 4257               		.section	.progmem.gcc_sw_table,"a",@progbits
 4258               		.p2align	1
 4259               	.L193:
 4260 0014 0000      		.word gs(.L192)
 4261 0016 0000      		.word gs(.L194)
 4262 0018 0000      		.word gs(.L194)
 4263 001a 0000      		.word gs(.L194)
 4264 001c 0000      		.word gs(.L194)
 4265 001e 0000      		.word gs(.L194)
 4266 0020 0000      		.word gs(.L194)
 4267 0022 0000      		.word gs(.L195)
 4268 0024 0000      		.word gs(.L194)
 4269 0026 0000      		.word gs(.L196)
 4270 0028 0000      		.word gs(.L194)
 4271 002a 0000      		.word gs(.L197)
 4272 002c 0000      		.word gs(.L194)
 4273 002e 0000      		.word gs(.L198)
 4274 0030 0000      		.word gs(.L194)
 4275 0032 0000      		.word gs(.L199)
 4276               		.section	.text.startup
 4277               	.L192:
 4278               	.LBB137:
 670:main.c        **** 			time_cnt++;
 4279               		.loc 1 670 0
 4280 0516 0E94 0000 		call setup_display
 4281               	.LVL439:
 671:main.c        **** 			break;
 4282               		.loc 1 671 0
 4283 051a 11E0      		ldi r17,lo8(1)
 672:main.c        **** 		    case 1 ... 6:
 4284               		.loc 1 672 0
 4285 051c 00C0      		rjmp .L194
 4286               	.LVL440:
 4287               	.L195:
 676:main.c        **** 			time_cnt = 8;
 4288               		.loc 1 676 0
 4289 051e 0E94 0000 		call getTempIsparit
 4290               	.LVL441:
 4291 0522 6093 0000 		sts Ti,r22
 4292 0526 7093 0000 		sts Ti+1,r23
 4293 052a 8093 0000 		sts Ti+2,r24
 4294 052e 9093 0000 		sts Ti+3,r25
 4295               	.LVL442:
 677:main.c        **** 			break;
 4296               		.loc 1 677 0
 4297 0532 18E0      		ldi r17,lo8(8)
 678:main.c        **** 		    case 8:
 4298               		.loc 1 678 0
 4299 0534 00C0      		rjmp .L194
 4300               	.LVL443:
 4301               	.L196:
 682:main.c        **** 			float t = Ts + 0.4;
 4302               		.loc 1 682 0
 4303 0536 0E94 0000 		call getTempSalon
 4304               	.LVL444:
 4305 053a 6093 0000 		sts Ts,r22
 4306 053e 7093 0000 		sts Ts+1,r23
 4307 0542 8093 0000 		sts Ts+2,r24
 4308 0546 9093 0000 		sts Ts+3,r25
 683:main.c        **** 			disp_num = t;
 4309               		.loc 1 683 0
 4310 054a 6091 0000 		lds r22,Ts
 4311 054e 7091 0000 		lds r23,Ts+1
 4312 0552 8091 0000 		lds r24,Ts+2
 4313 0556 9091 0000 		lds r25,Ts+3
 4314               	.LVL445:
 684:main.c        **** 			time_cnt++;
 4315               		.loc 1 684 0
 4316 055a 2DEC      		ldi r18,lo8(-51)
 4317 055c 3CEC      		ldi r19,lo8(-52)
 4318 055e 4CEC      		ldi r20,lo8(-52)
 4319 0560 5EE3      		ldi r21,lo8(62)
 4320 0562 0E94 0000 		call __addsf3
 4321               	.LVL446:
 4322 0566 0E94 0000 		call __fixsfsi
 4323               	.LVL447:
 4324 056a F62E      		mov r15,r22
 4325               	.LVL448:
 685:main.c        **** 			break;
 4326               		.loc 1 685 0
 4327 056c 1AE0      		ldi r17,lo8(10)
 686:main.c        **** 		    case 10:
 4328               		.loc 1 686 0
 4329 056e 00C0      		rjmp .L194
 4330               	.LVL449:
 4331               	.L197:
 690:main.c        **** 			time_cnt++;
 4332               		.loc 1 690 0
 4333 0570 0E94 0000 		call calcVal
 4334               	.LVL450:
 691:main.c        **** 			break;
 4335               		.loc 1 691 0
 4336 0574 1CE0      		ldi r17,lo8(12)
 692:main.c        **** 		    case 12:
 4337               		.loc 1 692 0
 4338 0576 00C0      		rjmp .L194
 4339               	.LVL451:
 4340               	.L198:
 696:main.c        **** 			time_cnt++;
 4341               		.loc 1 696 0
 4342 0578 8091 0000 		lds r24,temp_out_prc
 4343 057c 61E0      		ldi r22,lo8(1)
 4344 057e 0E94 0000 		call set_temp
 4345               	.LVL452:
 697:main.c        **** 			break;
 4346               		.loc 1 697 0
 4347 0582 1EE0      		ldi r17,lo8(14)
 698:main.c        **** 		    case 14:
 4348               		.loc 1 698 0
 4349 0584 00C0      		rjmp .L194
 4350               	.LVL453:
 4351               	.L199:
 702:main.c        **** 			disp_bar = vent_seg_cur;
 4352               		.loc 1 702 0
 4353 0586 8091 0000 		lds r24,vent_add_prc
 4354 058a 61E0      		ldi r22,lo8(1)
 4355 058c 0E94 0000 		call set_vent_prc
 4356               	.LVL454:
 703:main.c        **** 			SET_FLAG(f_num_dot)
 4357               		.loc 1 703 0
 4358 0590 B090 0000 		lds r11,vent_seg_cur
 4359               	.LVL455:
 704:main.c        **** 			time_cnt++;
 4360               		.loc 1 704 0
 4361 0594 8091 0000 		lds r24,flags
 4362 0598 8860      		ori r24,lo8(8)
 4363 059a 8093 0000 		sts flags,r24
 4364               	.LVL456:
 705:main.c        **** 			break;
 4365               		.loc 1 705 0
 4366 059e 10E1      		ldi r17,lo8(16)
 706:main.c        **** 		    default: //  цикл
 4367               		.loc 1 706 0
 4368 05a0 00C0      		rjmp .L194
 4369               	.LVL457:
 4370               	.L191:
 709:main.c        **** 		    }
 4371               		.loc 1 709 0
 4372 05a2 8091 0000 		lds r24,flags
 4373 05a6 877F      		andi r24,lo8(-9)
 4374 05a8 8093 0000 		sts flags,r24
 708:main.c        **** 			CLR_FLAG(f_num_dot)
 4375               		.loc 1 708 0
 4376 05ac 10E0      		ldi r17,0
 4377               	.LVL458:
 4378               	.L194:
 4379               	.LBE137:
 712:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEGs + 2);
 4380               		.loc 1 712 0
 4381 05ae 8091 0000 		lds r24,vent_enc
 4382 05b2 8823      		tst r24
 4383 05b4 01F0      		breq .L200
 713:main.c        **** 			disp_bar = vars.vent_nom_seg;
 4384               		.loc 1 713 0
 4385 05b6 8091 0000 		lds r24,vars+2
 4386 05ba 6091 0000 		lds r22,vent_enc
 4387 05be 062E      		mov __tmp_reg__,r22
 4388 05c0 000C      		lsl r0
 4389 05c2 770B      		sbc r23,r23
 4390 05c4 680F      		add r22,r24
 4391 05c6 711D      		adc r23,__zero_reg__
 4392 05c8 87FD      		sbrc r24,7
 4393 05ca 7A95      		dec r23
 4394 05cc 4AE0      		ldi r20,lo8(10)
 4395 05ce 50E0      		ldi r21,0
 4396 05d0 80E0      		ldi r24,0
 4397 05d2 90E0      		ldi r25,0
 4398 05d4 0E94 0000 		call check_range
 4399               	.LVL459:
 4400 05d8 8093 0000 		sts vars+2,r24
 714:main.c        **** 			time_cnt = 10;
 4401               		.loc 1 714 0
 4402 05dc B090 0000 		lds r11,vars+2
 4403               	.LVL460:
 716:main.c        **** 		    }
 4404               		.loc 1 716 0
 4405 05e0 1092 0000 		sts vent_enc,__zero_reg__
 715:main.c        **** 			vent_enc = 0;
 4406               		.loc 1 715 0
 4407 05e4 1AE0      		ldi r17,lo8(10)
 4408               	.LVL461:
 4409               	.L200:
 719:main.c        **** 			vars.setup_temp = check_range(15, vars.setup_temp + temp_enc, 30);
 4410               		.loc 1 719 0
 4411 05e6 8091 0000 		lds r24,temp_enc
 4412 05ea 8823      		tst r24
 4413 05ec 01F4      		brne .+2
 4414 05ee 00C0      		rjmp .L201
 720:main.c        **** 			disp_num = vars.setup_temp;
 4415               		.loc 1 720 0
 4416 05f0 8091 0000 		lds r24,vars+1
 4417 05f4 6091 0000 		lds r22,temp_enc
 4418 05f8 062E      		mov __tmp_reg__,r22
 4419 05fa 000C      		lsl r0
 4420 05fc 770B      		sbc r23,r23
 4421 05fe 680F      		add r22,r24
 4422 0600 711D      		adc r23,__zero_reg__
 4423 0602 87FD      		sbrc r24,7
 4424 0604 7A95      		dec r23
 4425 0606 4EE1      		ldi r20,lo8(30)
 4426 0608 50E0      		ldi r21,0
 4427 060a 8FE0      		ldi r24,lo8(15)
 4428 060c 90E0      		ldi r25,0
 4429 060e 0E94 0000 		call check_range
 4430               	.LVL462:
 4431 0612 8093 0000 		sts vars+1,r24
 721:main.c        **** 			time_cnt = 0;
 4432               		.loc 1 721 0
 4433 0616 F090 0000 		lds r15,vars+1
 4434               	.LVL463:
 723:main.c        **** 		    }
 4435               		.loc 1 723 0
 4436 061a 1092 0000 		sts temp_enc,__zero_reg__
 722:main.c        **** 			temp_enc = 0;
 4437               		.loc 1 722 0
 4438 061e 10E0      		ldi r17,0
 4439 0620 00C0      		rjmp .L201
 4440               	.LVL464:
 4441               	.L190:
 728:main.c        **** 			setup_display();
 4442               		.loc 1 728 0
 4443 0622 1B30      		cpi r17,lo8(11)
 4444 0624 00F0      		brlo .L202
 729:main.c        **** 			time_cnt = 0;
 4445               		.loc 1 729 0
 4446 0626 0E94 0000 		call setup_display
 4447               	.LVL465:
 730:main.c        **** 		    }
 4448               		.loc 1 730 0
 4449 062a 10E0      		ldi r17,0
 4450               	.LVL466:
 4451               	.L202:
 733:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEGs);
 4452               		.loc 1 733 0
 4453 062c 8091 0000 		lds r24,vent_enc
 4454 0630 8823      		tst r24
 4455 0632 01F0      		breq .L203
 734:main.c        **** 			vent_enc = 0;
 4456               		.loc 1 734 0
 4457 0634 8091 0000 		lds r24,vars+2
 4458 0638 6091 0000 		lds r22,vent_enc
 4459 063c 062E      		mov __tmp_reg__,r22
 4460 063e 000C      		lsl r0
 4461 0640 770B      		sbc r23,r23
 4462 0642 680F      		add r22,r24
 4463 0644 711D      		adc r23,__zero_reg__
 4464 0646 87FD      		sbrc r24,7
 4465 0648 7A95      		dec r23
 4466 064a 48E0      		ldi r20,lo8(8)
 4467 064c 50E0      		ldi r21,0
 4468 064e 80E0      		ldi r24,0
 4469 0650 90E0      		ldi r25,0
 4470 0652 0E94 0000 		call check_range
 4471               	.LVL467:
 4472 0656 8093 0000 		sts vars+2,r24
 735:main.c        **** 		    }
 4473               		.loc 1 735 0
 4474 065a 1092 0000 		sts vent_enc,__zero_reg__
 4475               	.L203:
 738:main.c        **** 			vars.temp_seg = check_range(0, vars.temp_seg + temp_enc, TEMP_SEGs);
 4476               		.loc 1 738 0
 4477 065e 8091 0000 		lds r24,temp_enc
 4478 0662 8823      		tst r24
 4479 0664 01F0      		breq .L204
 739:main.c        **** 			temp_enc = 0;
 4480               		.loc 1 739 0
 4481 0666 8091 0000 		lds r24,vars+3
 4482 066a 6091 0000 		lds r22,temp_enc
 4483 066e 062E      		mov __tmp_reg__,r22
 4484 0670 000C      		lsl r0
 4485 0672 770B      		sbc r23,r23
 4486 0674 680F      		add r22,r24
 4487 0676 711D      		adc r23,__zero_reg__
 4488 0678 87FD      		sbrc r24,7
 4489 067a 7A95      		dec r23
 4490 067c 4FE0      		ldi r20,lo8(15)
 4491 067e 50E0      		ldi r21,0
 4492 0680 80E0      		ldi r24,0
 4493 0682 90E0      		ldi r25,0
 4494 0684 0E94 0000 		call check_range
 4495               	.LVL468:
 4496 0688 8093 0000 		sts vars+3,r24
 740:main.c        **** 		    }
 4497               		.loc 1 740 0
 4498 068c 1092 0000 		sts temp_enc,__zero_reg__
 4499               	.L204:
 742:main.c        **** 		    disp_num = seg2Prc(TEMP_SEGs, vars.temp_seg);
 4500               		.loc 1 742 0
 4501 0690 B090 0000 		lds r11,vars+2
 4502               	.LVL469:
 743:main.c        **** 		    set_vent_seg(vars.vent_nom_seg, 0);
 4503               		.loc 1 743 0
 4504 0694 8091 0000 		lds r24,vars+3
 4505               	.LVL470:
 4506               	.LBB138:
 4507               	.LBB134:
  44:calc.c        ****     return tmp;
 4508               		.loc 3 44 0
 4509 0698 24E6      		ldi r18,lo8(100)
 4510 069a 829F      		mul r24,r18
 4511 069c C001      		movw r24,r0
 4512 069e 1124      		clr __zero_reg__
 4513               	.LVL471:
 4514 06a0 B601      		movw r22,r12
 4515 06a2 0E94 0000 		call __divmodhi4
 4516 06a6 962E      		mov r9,r22
 4517               	.LVL472:
 4518               	.LBE134:
 4519               	.LBE138:
 743:main.c        **** 		    set_vent_seg(vars.vent_nom_seg, 0);
 4520               		.loc 1 743 0
 4521 06a8 F62E      		mov r15,r22
 4522               	.LVL473:
 744:main.c        **** 		    set_temp(disp_num, 0);
 4523               		.loc 1 744 0
 4524 06aa 8091 0000 		lds r24,vars+2
 4525 06ae 60E0      		ldi r22,0
 4526 06b0 0E94 0000 		call set_vent_seg
 4527               	.LVL474:
 745:main.c        **** 		    switch_cond(1);
 4528               		.loc 1 745 0
 4529 06b4 60E0      		ldi r22,0
 4530 06b6 892D      		mov r24,r9
 4531 06b8 0E94 0000 		call set_temp
 4532               	.LVL475:
 746:main.c        **** 		}
 4533               		.loc 1 746 0
 4534 06bc 81E0      		ldi r24,lo8(1)
 4535 06be 0E94 0000 		call switch_cond
 4536               	.LVL476:
 4537               	.L201:
 750:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 4538               		.loc 1 750 0
 4539 06c2 3499      		sbic 0x6,4
 4540 06c4 00C0      		rjmp .L205
 751:main.c        **** 			smode = smode_hi_mode;
 4541               		.loc 1 751 0
 4542 06c6 CE01      		movw r24,r28
 4543 06c8 0196      		adiw r24,1
 4544 06ca 0E94 0000 		call delay_btn_check
 4545               	.LVL477:
 4546 06ce 8823      		tst r24
 4547 06d0 01F0      		breq .L227
 752:main.c        **** 		    }
 4548               		.loc 1 752 0
 4549 06d2 84E6      		ldi r24,lo8(100)
 4550 06d4 E82E      		mov r14,r24
 4551               	.LVL478:
 4552 06d6 00C0      		rjmp .L227
 4553               	.LVL479:
 4554               	.L205:
 755:main.c        **** 		    SET_FLAG(f_cond_btn_press);
 4555               		.loc 1 755 0
 4556 06d8 1C99      		sbic 0x3,4
 4557 06da 00C0      		rjmp .L207
 756:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 4558               		.loc 1 756 0
 4559 06dc 8091 0000 		lds r24,flags
 4560 06e0 8061      		ori r24,lo8(16)
 4561 06e2 8093 0000 		sts flags,r24
 757:main.c        **** 			smode = 1;
 4562               		.loc 1 757 0
 4563 06e6 CE01      		movw r24,r28
 4564 06e8 0196      		adiw r24,1
 4565 06ea 0E94 0000 		call delay_btn_check
 4566               	.LVL480:
 4567 06ee 8823      		tst r24
 4568 06f0 01F0      		breq .L227
 4569               	.LVL481:
 761:main.c        **** 			vent_enc = 0;
 4570               		.loc 1 761 0
 4571 06f2 8091 0000 		lds r24,flags
 4572 06f6 8F7E      		andi r24,lo8(-17)
 4573 06f8 8093 0000 		sts flags,r24
 762:main.c        **** 			temp_enc = 0;
 4574               		.loc 1 762 0
 4575 06fc 1092 0000 		sts vent_enc,__zero_reg__
 763:main.c        **** 		    }
 4576               		.loc 1 763 0
 4577 0700 1092 0000 		sts temp_enc,__zero_reg__
 758:main.c        **** 			disp_num = 0;
 4578               		.loc 1 758 0
 4579 0704 EE24      		clr r14
 4580 0706 E394      		inc r14
 765:main.c        **** 		} else {
 4581               		.loc 1 765 0
 4582 0708 10E0      		ldi r17,0
 4583               	.LVL482:
 760:main.c        **** 			CLR_FLAG(f_cond_btn_press);
 4584               		.loc 1 760 0
 4585 070a 03E6      		ldi r16,lo8(99)
 759:main.c        **** 			tmp = 'c';
 4586               		.loc 1 759 0
 4587 070c F12C      		mov r15,__zero_reg__
 4588 070e 00C0      		rjmp .L206
 4589               	.LVL483:
 4590               	.L207:
 767:main.c        **** 			if (vars.cond_enabled) {
 4591               		.loc 1 767 0
 4592 0710 8091 0000 		lds r24,flags
 4593 0714 84FF      		sbrs r24,4
 4594 0716 00C0      		rjmp .L208
 768:main.c        **** 			    vars.cond_enabled = 0;
 4595               		.loc 1 768 0
 4596 0718 8091 0000 		lds r24,vars+9
 4597 071c 8823      		tst r24
 4598 071e 01F0      		breq .L209
 769:main.c        **** 			} else {
 4599               		.loc 1 769 0
 4600 0720 1092 0000 		sts vars+9,__zero_reg__
 4601 0724 00C0      		rjmp .L210
 4602               	.L209:
 4603               		.loc 1 771 0
 4604 0726 A092 0000 		sts vars+9,r10
 4605               	.L210:
 772:main.c        **** 			}
 773:main.c        **** 			CLR_FLAG(f_cond_btn_press);
 4606               		.loc 1 773 0
 4607 072a 8091 0000 		lds r24,flags
 4608 072e 8F7E      		andi r24,lo8(-17)
 4609 0730 8093 0000 		sts flags,r24
 4610               	.L208:
 774:main.c        **** 		    }
 775:main.c        **** 		    bdelay = 0;
 4611               		.loc 1 775 0
 4612 0734 1982      		std Y+1,__zero_reg__
 4613 0736 00C0      		rjmp .L206
 4614               	.LVL484:
 4615               	.L227:
 765:main.c        **** 		} else {
 4616               		.loc 1 765 0
 4617 0738 10E0      		ldi r17,0
 4618               	.LVL485:
 4619               	.L206:
 776:main.c        **** 		}
 777:main.c        **** 
 778:main.c        **** //дисплей
 779:main.c        **** 		Disp_Num(disp_num, TST_FLAG(f_num_dot));
 4620               		.loc 1 779 0
 4621 073a 6091 0000 		lds r22,flags
 4622 073e 6870      		andi r22,lo8(8)
 4623 0740 8F2D      		mov r24,r15
 4624 0742 0E94 0000 		call Disp_Num
 4625               	.LVL486:
 780:main.c        **** 		Disp_Bars(disp_bar);
 4626               		.loc 1 780 0
 4627 0746 8B2D      		mov r24,r11
 4628               	.L273:
 4629 0748 0E94 0000 		call Disp_Bars
 4630               	.LVL487:
 4631               	.L159:
 781:main.c        **** 	    }
 782:main.c        **** 
 783:main.c        **** 	    if (TST_FLAG(f_e1sec)) {
 4632               		.loc 1 783 0
 4633 074c 8091 0000 		lds r24,flags
 4634 0750 80FF      		sbrs r24,0
 4635 0752 00C0      		rjmp .L211
 784:main.c        **** 		time_cnt++;
 4636               		.loc 1 784 0
 4637 0754 1F5F      		subi r17,lo8(-(1))
 4638               	.LVL488:
 785:main.c        **** 		if (bdelay) {
 4639               		.loc 1 785 0
 4640 0756 8981      		ldd r24,Y+1
 4641 0758 8823      		tst r24
 4642 075a 01F0      		breq .L212
 786:main.c        **** 		    bdelay++;
 4643               		.loc 1 786 0
 4644 075c 8F5F      		subi r24,lo8(-(1))
 4645 075e 8983      		std Y+1,r24
 4646               	.L212:
 787:main.c        **** 		}
 788:main.c        **** 		CLR_FLAG(f_e1sec);
 4647               		.loc 1 788 0
 4648 0760 8091 0000 		lds r24,flags
 4649 0764 8E7F      		andi r24,lo8(-2)
 4650 0766 8093 0000 		sts flags,r24
 789:main.c        **** 
 790:main.c        **** 		if (TST_FLAG(f_cond_ind_flash)) {
 4651               		.loc 1 790 0
 4652 076a 8091 0000 		lds r24,flags
 4653 076e 85FF      		sbrs r24,5
 4654 0770 00C0      		rjmp .L211
 791:main.c        **** 		    pin_low(OUT_FROST_IND);
 4655               		.loc 1 791 0
 4656 0772 4198      		cbi 0x8,1
 4657 0774 00C0      		rjmp .L211
 4658               	.L156:
 4659               	.LVL489:
 792:main.c        **** 		}
 793:main.c        **** 	    }
 794:main.c        **** 
 795:main.c        **** 	} else { //poweroff prepare
 796:main.c        **** 	    time_cnt = 0;
 797:main.c        **** 	    wdt_reset();
 4660               		.loc 1 797 0
 4661               	/* #APP */
 4662               	 ;  797 "main.c" 1
 4663 0776 A895      		wdr
 4664               	 ;  0 "" 2
 798:main.c        **** 	    myupdate_eeprom();
 4665               		.loc 1 798 0
 4666               	/* #NOAPP */
 4667 0778 0E94 0000 		call myupdate_eeprom
 4668               	.LVL490:
 4669 077c 1AE0      		ldi r17,lo8(10)
 4670               	.LVL491:
 4671               	.L213:
 4672               	.LBB139:
 799:main.c        **** 	    for (uint8_t i = 0; i < VENT_SEGs + 2; i++) {
 800:main.c        **** 		switch_vent(0);
 4673               		.loc 1 800 0 discriminator 3
 4674 077e 80E0      		ldi r24,0
 4675 0780 0E94 0000 		call switch_vent
 4676               	.LVL492:
 4677 0784 1150      		subi r17,lo8(-(-1))
 4678               	.LVL493:
 799:main.c        **** 	    for (uint8_t i = 0; i < VENT_SEGs + 2; i++) {
 4679               		.loc 1 799 0 discriminator 3
 4680 0786 01F4      		brne .L213
 4681 0788 1FE0      		ldi r17,lo8(15)
 4682               	.LVL494:
 4683               	.L214:
 4684               	.LBE139:
 4685               	.LBB140:
 801:main.c        **** 	    }
 802:main.c        **** 	    for (uint8_t i = 0; i < TEMP_SEGs; i++) {
 803:main.c        **** 		switch_temp(0);
 4686               		.loc 1 803 0 discriminator 3
 4687 078a 80E0      		ldi r24,0
 4688 078c 0E94 0000 		call switch_temp
 4689               	.LVL495:
 4690 0790 1150      		subi r17,lo8(-(-1))
 4691               	.LVL496:
 802:main.c        **** 		switch_temp(0);
 4692               		.loc 1 802 0 discriminator 3
 4693 0792 01F4      		brne .L214
 4694               	.LBE140:
 804:main.c        **** 	    }
 805:main.c        **** 	    display_off();
 4695               		.loc 1 805 0
 4696 0794 0E94 0000 		call display_off
 4697               	.LVL497:
 806:main.c        **** 	    delay_ms(10);
 4698               		.loc 1 806 0
 4699 0798 8AE0      		ldi r24,lo8(10)
 4700 079a 90E0      		ldi r25,0
 4701 079c 0E94 0000 		call delay_ms
 4702               	.LVL498:
 4703               	.LBB141:
 4704               	.LBB142:
 4705               		.loc 4 473 0
 4706 07a0 98E0      		ldi r25,lo8(8)
 4707 07a2 88E1      		ldi r24,lo8(24)
 4708               	/* #APP */
 4709               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 4710 07a4 0FB6      		in __tmp_reg__,__SREG__
 4711 07a6 F894      		cli
 4712 07a8 A895      		wdr
 4713 07aa 8093 6000 		sts 96, r24
 4714 07ae 0FBE      		out __SREG__,__tmp_reg__
 4715 07b0 9093 6000 		sts 96, r25
 4716               	 	
 4717               	 ;  0 "" 2
 4718               	/* #NOAPP */
 4719               	.L215:
 4720               	.LBE142:
 4721               	.LBE141:
 807:main.c        **** 
 808:main.c        **** 	    wdt_enable(WDTO_15MS); // reboot
 809:main.c        **** 	    while (1) {
 810:main.c        **** 		delay_s(1);
 4722               		.loc 1 810 0 discriminator 1
 4723 07b4 81E0      		ldi r24,lo8(1)
 4724 07b6 0E94 0000 		call delay_s
 4725               	.LVL499:
 4726 07ba 00C0      		rjmp .L215
 4727               	.LVL500:
 4728               	.L211:
 811:main.c        **** 	    }
 812:main.c        **** 	}
 813:main.c        **** 
 814:main.c        **** 	delay_ms(100);
 4729               		.loc 1 814 0
 4730 07bc 84E6      		ldi r24,lo8(100)
 4731 07be 90E0      		ldi r25,0
 4732 07c0 0E94 0000 		call delay_ms
 4733               	.LVL501:
 815:main.c        **** 
 816:main.c        **** 	if (vars.cond_enabled) {
 4734               		.loc 1 816 0
 4735 07c4 8091 0000 		lds r24,vars+9
 4736 07c8 8823      		tst r24
 4737 07ca 01F0      		breq .L216
 817:main.c        **** 	    pin_high(OUT_FROST_IND);
 4738               		.loc 1 817 0
 4739 07cc 419A      		sbi 0x8,1
 4740 07ce 00C0      		rjmp .L217
 4741               	.L216:
 818:main.c        **** 	} else {
 819:main.c        **** 	    pin_low(OUT_FROST_IND);
 4742               		.loc 1 819 0
 4743 07d0 4198      		cbi 0x8,1
 820:main.c        **** 	    switch_cond(0);
 4744               		.loc 1 820 0
 4745 07d2 80E0      		ldi r24,0
 4746 07d4 0E94 0000 		call switch_cond
 4747               	.LVL502:
 4748               	.L217:
 821:main.c        **** 	}
 822:main.c        **** 
 823:main.c        **** 	wdt_reset();
 4749               		.loc 1 823 0
 4750               	/* #APP */
 4751               	 ;  823 "main.c" 1
 4752 07d8 A895      		wdr
 4753               	 ;  0 "" 2
 4754               	/* #NOAPP */
 4755 07da 00C0      		rjmp .L155
 4756               		.cfi_endproc
 4757               	.LFE46:
 4759               	.global	cond_cicle
 4760               		.section .bss
 4763               	cond_cicle:
 4764 0000 00        		.zero	1
 4765               		.comm	vars,11,1
 4766               	.global	Ts
 4769               	Ts:
 4770 0001 0000 0000 		.zero	4
 4771               	.global	Ti
 4774               	Ti:
 4775 0005 0000 0000 		.zero	4
 4776               		.comm	flags,1,1
 4777               		.comm	cond_needs_of_cool,1,1
 4778               		.comm	bootUp_delay,1,1
 4779               		.comm	temp_out_delay,1,1
 4780               		.comm	temp_out_prc,1,1
 4781               		.comm	vent_add_prc,1,1
 4782               		.comm	last_delta,4,1
 4783               		.comm	Ipid,4,1
 4784               		.comm	temp_enc,1,1
 4785               		.comm	vent_enc,1,1
 4786               		.comm	temp_seg_cur,1,1
 4787               		.comm	vent_seg_cur,1,1
 4788               		.text
 4789               	.Letext0:
 4790               		.file 5 "/usr/lib/avr/include/stdint.h"
 4791               		.file 6 "vars.h"
 4792               		.file 7 "usart.h"
 4793               		.file 8 "/usr/lib/avr/include/stdio.h"
 4794               		.file 9 "disp.h"
 4795               		.file 10 "/usr/lib/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccOUBO6s.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccOUBO6s.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccOUBO6s.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccOUBO6s.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOUBO6s.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOUBO6s.s:18     .text:0000000000000000 int_to_uart
     /tmp/ccOUBO6s.s:115    .text:0000000000000074 float_to_uart
     /tmp/ccOUBO6s.s:152    .text:000000000000008c uart_nl
     /tmp/ccOUBO6s.s:173    .text:0000000000000098 __vector_13
                            *COM*:0000000000000001 flags
     /tmp/ccOUBO6s.s:235    .text:00000000000000ce test_vent_enc
                            *COM*:0000000000000001 vent_enc
     /tmp/ccOUBO6s.s:282    .text:00000000000000f8 __vector_3
     /tmp/ccOUBO6s.s:389    .text:0000000000000146 __vector_5
     /tmp/ccOUBO6s.s:496    .text:0000000000000194 test_temp_enc
                            *COM*:0000000000000001 temp_enc
     /tmp/ccOUBO6s.s:561    .text:00000000000001cc __vector_1
     /tmp/ccOUBO6s.s:668    .text:000000000000021a __vector_2
     /tmp/ccOUBO6s.s:775    .text:0000000000000268 set_def_vals
                            *COM*:000000000000000b vars
     /tmp/ccOUBO6s.s:819    .text:0000000000000290 myread_eeprom
     /tmp/ccOUBO6s.s:860    .text:00000000000002b4 myupdate_eeprom
     /tmp/ccOUBO6s.s:907    .text:00000000000002de switch_temp
     /tmp/ccOUBO6s.s:1025   .text:0000000000000328 switch_vent
     /tmp/ccOUBO6s.s:1143   .text:0000000000000372 switch_cond
                            *COM*:0000000000000001 vent_seg_cur
     /tmp/ccOUBO6s.s:1198   .text:00000000000003aa test_cond_ON
     /tmp/ccOUBO6s.s:1223   .text:00000000000003b4 calcTempFromADC
     /tmp/ccOUBO6s.s:1386   .text:0000000000000492 bootVarsInit
                            *COM*:0000000000000001 vent_add_prc
                            *COM*:0000000000000001 temp_out_prc
                            *COM*:0000000000000001 temp_out_delay
                            *COM*:0000000000000001 bootUp_delay
                            *COM*:0000000000000004 Ipid
                            *COM*:0000000000000004 last_delta
                            *COM*:0000000000000001 cond_needs_of_cool
     /tmp/ccOUBO6s.s:1432   .text:00000000000004e2 getTempSalon
     /tmp/ccOUBO6s.s:1449   .text:00000000000004e8 getTempIsparit
     /tmp/ccOUBO6s.s:1466   .text:00000000000004ee prc2Seg
     /tmp/ccOUBO6s.s:1515   .text:0000000000000520 seg2Prc
     /tmp/ccOUBO6s.s:1544   .text:0000000000000536 set_vent_seg
     /tmp/ccOUBO6s.s:1743   .text:000000000000060c set_vent_prc
     /tmp/ccOUBO6s.s:1778   .text:0000000000000620 set_temp
                            *COM*:0000000000000001 temp_seg_cur
     /tmp/ccOUBO6s.s:1999   .text:00000000000006e8 calcCond
     /tmp/ccOUBO6s.s:4774   .bss:0000000000000005 Ti
     /tmp/ccOUBO6s.s:4769   .bss:0000000000000001 Ts
     /tmp/ccOUBO6s.s:4763   .bss:0000000000000000 cond_cicle
     /tmp/ccOUBO6s.s:2262   .text:00000000000008a4 calcVent
     /tmp/ccOUBO6s.s:2486   .text:00000000000009a6 calcVal
     /tmp/ccOUBO6s.s:3117   .text:0000000000000ddc recycleSwitch
     /tmp/ccOUBO6s.s:3142   .text:0000000000000dec prefAirSwitch
     /tmp/ccOUBO6s.s:3167   .text:0000000000000dfc hiAirSwitch
     /tmp/ccOUBO6s.s:3192   .text:0000000000000e0c setup_pins
     /tmp/ccOUBO6s.s:3234   .text:0000000000000e2a setup_display
     /tmp/ccOUBO6s.s:3282   .text:0000000000000e5a display_off
     /tmp/ccOUBO6s.s:3306   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
USART_SendStr
snprintf
USART_PutChar
__fixsfsi
eeprom_read_buf
eeprom_read_byte1
eeprom_update_buf
eeprom_write_byte1
delay_ms
__floatunsisf
__addsf3
__divsf3
__subsf3
__mulsf3
ADC_Mux
ADC_Start
ADC_GetData
log
check_range
__divmodhi4
__floatsisf
__ltsf2
check_rangef
__gtsf2
__fixunssfsi
Send_7219
delay_s
ADC_Init
USART_Init
SPI_init
Clear_7219
Disp_Num
Disp_Bars
Disp_Num_Seg
__tablejump2__
delay_btn_check
__do_copy_data
__do_clear_bss
