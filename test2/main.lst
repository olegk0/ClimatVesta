   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 3A00      		.string	":"
  13               	.LC1:
  14 0002 2564 00   		.string	"%d"
  15               		.text
  16               	.global	int_to_uart
  18               	int_to_uart:
  19               	.LFB11:
  20               		.file 1 "main.c"
   1:main.c        **** #include <avr/interrupt.h>
   2:main.c        **** #include <avr/eeprom.h>
   3:main.c        **** #include <stdio.h>
   4:main.c        **** #include <stdlib.h>
   5:main.c        **** #include <avr/pgmspace.h>
   6:main.c        **** #include <ctype.h>
   7:main.c        **** #include <stdint.h>
   8:main.c        **** #include <avr/wdt.h>
   9:main.c        **** #include <math.h>
  10:main.c        **** 
  11:main.c        **** #include "io.h"
  12:main.c        **** #include "disp.h"
  13:main.c        **** #include "usart.h"
  14:main.c        **** //#include "temp_18b20.h"
  15:main.c        **** 
  16:main.c        **** #define F_CPU 8000000UL  // Частота MHz
  17:main.c        **** 
  18:main.c        **** #include "vars.h"
  19:main.c        **** #include "subs.h"
  20:main.c        **** 
  21:main.c        **** //----------------------------------------------
  22:main.c        **** 
  23:main.c        **** void int_to_uart(char *id, int16_t num)
  24:main.c        **** {
  21               		.loc 1 24 0
  22               		.cfi_startproc
  23               	.LVL0:
  24 0000 0F93      		push r16
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 16, -2
  28 0002 1F93      		push r17
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 17, -3
  32 0004 CF93      		push r28
  33               	.LCFI2:
  34               		.cfi_def_cfa_offset 5
  35               		.cfi_offset 28, -4
  36 0006 DF93      		push r29
  37               	.LCFI3:
  38               		.cfi_def_cfa_offset 6
  39               		.cfi_offset 29, -5
  40 0008 CDB7      		in r28,__SP_L__
  41 000a DEB7      		in r29,__SP_H__
  42               	.LCFI4:
  43               		.cfi_def_cfa_register 28
  44 000c 2A97      		sbiw r28,10
  45               	.LCFI5:
  46               		.cfi_def_cfa_offset 16
  47 000e 0FB6      		in __tmp_reg__,__SREG__
  48 0010 F894      		cli
  49 0012 DEBF      		out __SP_H__,r29
  50 0014 0FBE      		out __SREG__,__tmp_reg__
  51 0016 CDBF      		out __SP_L__,r28
  52               	/* prologue: function */
  53               	/* frame size = 10 */
  54               	/* stack size = 14 */
  55               	.L__stack_usage = 14
  56 0018 162F      		mov r17,r22
  57 001a 072F      		mov r16,r23
  25:main.c        **** //    struct m2bytes nbuf;
  26:main.c        ****     //USART_PutChar('\x0d');
  27:main.c        ****     USART_SendStr(id);
  58               		.loc 1 27 0
  59 001c 0E94 0000 		call USART_SendStr
  60               	.LVL1:
  28:main.c        ****     USART_SendStr(":");
  61               		.loc 1 28 0
  62 0020 80E0      		ldi r24,lo8(.LC0)
  63 0022 90E0      		ldi r25,hi8(.LC0)
  64 0024 0E94 0000 		call USART_SendStr
  65               	.LVL2:
  29:main.c        ****     /*    nbuf.one = num;
  30:main.c        ****      num_to_str(&nbuf);
  31:main.c        ****      USART_PutChar(nbuf.one);
  32:main.c        ****      USART_PutChar(nbuf.two);
  33:main.c        ****      */
  34:main.c        ****     char buf[10];
  35:main.c        ****     snprintf(buf, sizeof(buf), "%d", num);
  66               		.loc 1 35 0
  67 0028 0F93      		push r16
  68 002a 1F93      		push r17
  69 002c 80E0      		ldi r24,lo8(.LC1)
  70 002e 90E0      		ldi r25,hi8(.LC1)
  71 0030 9F93      		push r25
  72 0032 8F93      		push r24
  73 0034 1F92      		push __zero_reg__
  74 0036 8AE0      		ldi r24,lo8(10)
  75 0038 8F93      		push r24
  76 003a 8E01      		movw r16,r28
  77 003c 0F5F      		subi r16,-1
  78 003e 1F4F      		sbci r17,-1
  79 0040 1F93      		push r17
  80 0042 0F93      		push r16
  81 0044 0E94 0000 		call snprintf
  82               	.LVL3:
  36:main.c        ****     USART_SendStr(buf);
  83               		.loc 1 36 0
  84 0048 C801      		movw r24,r16
  85 004a 0E94 0000 		call USART_SendStr
  86               	.LVL4:
  37:main.c        ****     USART_PutChar(';');
  87               		.loc 1 37 0
  88 004e 8BE3      		ldi r24,lo8(59)
  89 0050 0E94 0000 		call USART_PutChar
  90               	.LVL5:
  38:main.c        **** //    buf[cnt];
  39:main.c        **** }
  91               		.loc 1 39 0
  92 0054 0FB6      		in __tmp_reg__,__SREG__
  93 0056 F894      		cli
  94 0058 DEBF      		out __SP_H__,r29
  95 005a 0FBE      		out __SREG__,__tmp_reg__
  96 005c CDBF      		out __SP_L__,r28
  97               	/* epilogue start */
  98 005e 2A96      		adiw r28,10
  99 0060 0FB6      		in __tmp_reg__,__SREG__
 100 0062 F894      		cli
 101 0064 DEBF      		out __SP_H__,r29
 102 0066 0FBE      		out __SREG__,__tmp_reg__
 103 0068 CDBF      		out __SP_L__,r28
 104 006a DF91      		pop r29
 105 006c CF91      		pop r28
 106 006e 1F91      		pop r17
 107 0070 0F91      		pop r16
 108 0072 0895      		ret
 109               		.cfi_endproc
 110               	.LFE11:
 112               	.global	__fixsfsi
 113               	.global	float_to_uart
 115               	float_to_uart:
 116               	.LFB12:
  40:main.c        **** 
  41:main.c        **** void float_to_uart(char *id, float num)
  42:main.c        **** {
 117               		.loc 1 42 0
 118               		.cfi_startproc
 119               	.LVL6:
 120 0074 CF93      		push r28
 121               	.LCFI6:
 122               		.cfi_def_cfa_offset 3
 123               		.cfi_offset 28, -2
 124 0076 DF93      		push r29
 125               	.LCFI7:
 126               		.cfi_def_cfa_offset 4
 127               		.cfi_offset 29, -3
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 2 */
 131               	.L__stack_usage = 2
 132 0078 EC01      		movw r28,r24
  43:main.c        ****     int_to_uart(id, num);
 133               		.loc 1 43 0
 134 007a CB01      		movw r24,r22
 135 007c BA01      		movw r22,r20
 136 007e 0E94 0000 		call __fixsfsi
 137               	.LVL7:
 138 0082 CE01      		movw r24,r28
 139               	/* epilogue start */
  44:main.c        ****     /*    USART_SendStr(id);
  45:main.c        ****      USART_SendStr(":");
  46:main.c        ****      int8_t buf[10];
  47:main.c        ****      int8_t cnt = snprintf(buf, sizeof(buf), "%g", num);
  48:main.c        ****      USART_SendStr(buf);
  49:main.c        ****      USART_Putint8_t(';');
  50:main.c        ****      */
  51:main.c        **** }
 140               		.loc 1 51 0
 141 0084 DF91      		pop r29
 142 0086 CF91      		pop r28
 143               	.LVL8:
  43:main.c        ****     int_to_uart(id, num);
 144               		.loc 1 43 0
 145 0088 0C94 0000 		jmp int_to_uart
 146               	.LVL9:
 147               		.cfi_endproc
 148               	.LFE12:
 150               	.global	uart_nl
 152               	uart_nl:
 153               	.LFB13:
  52:main.c        **** 
  53:main.c        **** void uart_nl(void)
  54:main.c        **** {
 154               		.loc 1 54 0
 155               		.cfi_startproc
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 0 */
 159               	.L__stack_usage = 0
  55:main.c        ****     USART_PutChar('\x0d');
 160               		.loc 1 55 0
 161 008c 8DE0      		ldi r24,lo8(13)
 162 008e 0E94 0000 		call USART_PutChar
 163               	.LVL10:
  56:main.c        ****     USART_PutChar('\n');
 164               		.loc 1 56 0
 165 0092 8AE0      		ldi r24,lo8(10)
 166 0094 0C94 0000 		jmp USART_PutChar
 167               	.LVL11:
 168               		.cfi_endproc
 169               	.LFE13:
 171               	.global	__vector_13
 173               	__vector_13:
 174               	.LFB14:
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** //-------------------- Timer on 0.5 sec -----------------------
  60:main.c        **** 
  61:main.c        **** ISR (TIMER1_OVF_vect)
  62:main.c        **** {
 175               		.loc 1 62 0
 176               		.cfi_startproc
 177 0098 1F92      		push r1
 178               	.LCFI8:
 179               		.cfi_def_cfa_offset 3
 180               		.cfi_offset 1, -2
 181 009a 0F92      		push r0
 182               	.LCFI9:
 183               		.cfi_def_cfa_offset 4
 184               		.cfi_offset 0, -3
 185 009c 0FB6      		in r0,__SREG__
 186 009e 0F92      		push r0
 187 00a0 1124      		clr __zero_reg__
 188 00a2 8F93      		push r24
 189               	.LCFI10:
 190               		.cfi_def_cfa_offset 5
 191               		.cfi_offset 24, -4
 192 00a4 9F93      		push r25
 193               	.LCFI11:
 194               		.cfi_def_cfa_offset 6
 195               		.cfi_offset 25, -5
 196               	/* prologue: Signal */
 197               	/* frame size = 0 */
 198               	/* stack size = 5 */
 199               	.L__stack_usage = 5
  63:main.c        ****     cli();
 200               		.loc 1 63 0
 201               	/* #APP */
 202               	 ;  63 "main.c" 1
 203 00a6 F894      		cli
 204               	 ;  0 "" 2
  64:main.c        ****     TCNT1 = 0x10000 - (F_CPU / 256);
 205               		.loc 1 64 0
 206               	/* #NOAPP */
 207 00a8 8EEE      		ldi r24,lo8(-18)
 208 00aa 95E8      		ldi r25,lo8(-123)
 209 00ac 9093 8500 		sts 132+1,r25
 210 00b0 8093 8400 		sts 132,r24
  65:main.c        **** 
  66:main.c        ****     SET_FLAG(f_e1sec);
 211               		.loc 1 66 0
 212 00b4 8091 0000 		lds r24,flags
 213 00b8 8160      		ori r24,lo8(1)
 214 00ba 8093 0000 		sts flags,r24
  67:main.c        **** 
  68:main.c        **** //    SET_BIT(time_flag, tf_dps_en);
  69:main.c        ****     sei();
 215               		.loc 1 69 0
 216               	/* #APP */
 217               	 ;  69 "main.c" 1
 218 00be 7894      		sei
 219               	 ;  0 "" 2
 220               	/* epilogue start */
  70:main.c        **** }
 221               		.loc 1 70 0
 222               	/* #NOAPP */
 223 00c0 9F91      		pop r25
 224 00c2 8F91      		pop r24
 225 00c4 0F90      		pop r0
 226 00c6 0FBE      		out __SREG__,r0
 227 00c8 0F90      		pop r0
 228 00ca 1F90      		pop r1
 229 00cc 1895      		reti
 230               		.cfi_endproc
 231               	.LFE14:
 233               	.global	test_vent_enc
 235               	test_vent_enc:
 236               	.LFB15:
  71:main.c        **** 
  72:main.c        **** //********************** Vent Enc INT**********************
  73:main.c        **** void test_vent_enc(int8_t up)
  74:main.c        **** {
 237               		.loc 1 74 0
 238               		.cfi_startproc
 239               	.LVL12:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
  75:main.c        ****     if (get_input(IN_BTN_V_UP) == get_input(IN_BTN_V_DWN)) {
 244               		.loc 1 75 0
 245 00ce 99B1      		in r25,0x9
 246 00d0 23B1      		in r18,0x3
 247 00d2 9095      		com r25
 248 00d4 991F      		rol r25
 249 00d6 9927      		clr r25
 250 00d8 991F      		rol r25
 251 00da 2170      		andi r18,lo8(1)
 252 00dc 9217      		cp r25,r18
 253 00de 01F0      		breq .L5
  76:main.c        **** 	if (up) {
 254               		.loc 1 76 0
 255 00e0 8823      		tst r24
 256 00e2 01F0      		breq .L7
 257               	.LVL13:
 258               	.LBB62:
 259               	.LBB63:
  77:main.c        **** 	    vent_enc++;
 260               		.loc 1 77 0
 261 00e4 8091 0000 		lds r24,vent_enc
 262               	.LVL14:
 263 00e8 8F5F      		subi r24,lo8(-(1))
 264 00ea 00C0      		rjmp .L8
 265               	.LVL15:
 266               	.L7:
 267               	.LBE63:
 268               	.LBE62:
  78:main.c        **** 	} else {
  79:main.c        **** 	    vent_enc--;
 269               		.loc 1 79 0
 270 00ec 8091 0000 		lds r24,vent_enc
 271               	.LVL16:
 272 00f0 8150      		subi r24,lo8(-(-1))
 273               	.L8:
 274 00f2 8093 0000 		sts vent_enc,r24
 275               	.L5:
 276 00f6 0895      		ret
 277               		.cfi_endproc
 278               	.LFE15:
 280               	.global	__vector_3
 282               	__vector_3:
 283               	.LFB16:
  80:main.c        **** 	}
  81:main.c        ****     }
  82:main.c        **** }
  83:main.c        **** 
  84:main.c        **** ISR (PCINT0_vect) // IN_BTN_V_DWN Vent
  85:main.c        **** {
 284               		.loc 1 85 0
 285               		.cfi_startproc
 286 00f8 1F92      		push r1
 287               	.LCFI12:
 288               		.cfi_def_cfa_offset 3
 289               		.cfi_offset 1, -2
 290 00fa 0F92      		push r0
 291               	.LCFI13:
 292               		.cfi_def_cfa_offset 4
 293               		.cfi_offset 0, -3
 294 00fc 0FB6      		in r0,__SREG__
 295 00fe 0F92      		push r0
 296 0100 1124      		clr __zero_reg__
 297 0102 2F93      		push r18
 298               	.LCFI14:
 299               		.cfi_def_cfa_offset 5
 300               		.cfi_offset 18, -4
 301 0104 3F93      		push r19
 302               	.LCFI15:
 303               		.cfi_def_cfa_offset 6
 304               		.cfi_offset 19, -5
 305 0106 4F93      		push r20
 306               	.LCFI16:
 307               		.cfi_def_cfa_offset 7
 308               		.cfi_offset 20, -6
 309 0108 5F93      		push r21
 310               	.LCFI17:
 311               		.cfi_def_cfa_offset 8
 312               		.cfi_offset 21, -7
 313 010a 6F93      		push r22
 314               	.LCFI18:
 315               		.cfi_def_cfa_offset 9
 316               		.cfi_offset 22, -8
 317 010c 7F93      		push r23
 318               	.LCFI19:
 319               		.cfi_def_cfa_offset 10
 320               		.cfi_offset 23, -9
 321 010e 8F93      		push r24
 322               	.LCFI20:
 323               		.cfi_def_cfa_offset 11
 324               		.cfi_offset 24, -10
 325 0110 9F93      		push r25
 326               	.LCFI21:
 327               		.cfi_def_cfa_offset 12
 328               		.cfi_offset 25, -11
 329 0112 AF93      		push r26
 330               	.LCFI22:
 331               		.cfi_def_cfa_offset 13
 332               		.cfi_offset 26, -12
 333 0114 BF93      		push r27
 334               	.LCFI23:
 335               		.cfi_def_cfa_offset 14
 336               		.cfi_offset 27, -13
 337 0116 EF93      		push r30
 338               	.LCFI24:
 339               		.cfi_def_cfa_offset 15
 340               		.cfi_offset 30, -14
 341 0118 FF93      		push r31
 342               	.LCFI25:
 343               		.cfi_def_cfa_offset 16
 344               		.cfi_offset 31, -15
 345               	/* prologue: Signal */
 346               	/* frame size = 0 */
 347               	/* stack size = 15 */
 348               	.L__stack_usage = 15
  86:main.c        ****     cli();
 349               		.loc 1 86 0
 350               	/* #APP */
 351               	 ;  86 "main.c" 1
 352 011a F894      		cli
 353               	 ;  0 "" 2
  87:main.c        ****     test_vent_enc(1);
 354               		.loc 1 87 0
 355               	/* #NOAPP */
 356 011c 81E0      		ldi r24,lo8(1)
 357 011e 0E94 0000 		call test_vent_enc
 358               	.LVL17:
  88:main.c        ****     sei();
 359               		.loc 1 88 0
 360               	/* #APP */
 361               	 ;  88 "main.c" 1
 362 0122 7894      		sei
 363               	 ;  0 "" 2
 364               	/* epilogue start */
  89:main.c        **** }
 365               		.loc 1 89 0
 366               	/* #NOAPP */
 367 0124 FF91      		pop r31
 368 0126 EF91      		pop r30
 369 0128 BF91      		pop r27
 370 012a AF91      		pop r26
 371 012c 9F91      		pop r25
 372 012e 8F91      		pop r24
 373 0130 7F91      		pop r23
 374 0132 6F91      		pop r22
 375 0134 5F91      		pop r21
 376 0136 4F91      		pop r20
 377 0138 3F91      		pop r19
 378 013a 2F91      		pop r18
 379 013c 0F90      		pop r0
 380 013e 0FBE      		out __SREG__,r0
 381 0140 0F90      		pop r0
 382 0142 1F90      		pop r1
 383 0144 1895      		reti
 384               		.cfi_endproc
 385               	.LFE16:
 387               	.global	__vector_5
 389               	__vector_5:
 390               	.LFB17:
  90:main.c        **** 
  91:main.c        **** ISR (PCINT2_vect) // IN_BTN_V_UP Vent
  92:main.c        **** {
 391               		.loc 1 92 0
 392               		.cfi_startproc
 393 0146 1F92      		push r1
 394               	.LCFI26:
 395               		.cfi_def_cfa_offset 3
 396               		.cfi_offset 1, -2
 397 0148 0F92      		push r0
 398               	.LCFI27:
 399               		.cfi_def_cfa_offset 4
 400               		.cfi_offset 0, -3
 401 014a 0FB6      		in r0,__SREG__
 402 014c 0F92      		push r0
 403 014e 1124      		clr __zero_reg__
 404 0150 2F93      		push r18
 405               	.LCFI28:
 406               		.cfi_def_cfa_offset 5
 407               		.cfi_offset 18, -4
 408 0152 3F93      		push r19
 409               	.LCFI29:
 410               		.cfi_def_cfa_offset 6
 411               		.cfi_offset 19, -5
 412 0154 4F93      		push r20
 413               	.LCFI30:
 414               		.cfi_def_cfa_offset 7
 415               		.cfi_offset 20, -6
 416 0156 5F93      		push r21
 417               	.LCFI31:
 418               		.cfi_def_cfa_offset 8
 419               		.cfi_offset 21, -7
 420 0158 6F93      		push r22
 421               	.LCFI32:
 422               		.cfi_def_cfa_offset 9
 423               		.cfi_offset 22, -8
 424 015a 7F93      		push r23
 425               	.LCFI33:
 426               		.cfi_def_cfa_offset 10
 427               		.cfi_offset 23, -9
 428 015c 8F93      		push r24
 429               	.LCFI34:
 430               		.cfi_def_cfa_offset 11
 431               		.cfi_offset 24, -10
 432 015e 9F93      		push r25
 433               	.LCFI35:
 434               		.cfi_def_cfa_offset 12
 435               		.cfi_offset 25, -11
 436 0160 AF93      		push r26
 437               	.LCFI36:
 438               		.cfi_def_cfa_offset 13
 439               		.cfi_offset 26, -12
 440 0162 BF93      		push r27
 441               	.LCFI37:
 442               		.cfi_def_cfa_offset 14
 443               		.cfi_offset 27, -13
 444 0164 EF93      		push r30
 445               	.LCFI38:
 446               		.cfi_def_cfa_offset 15
 447               		.cfi_offset 30, -14
 448 0166 FF93      		push r31
 449               	.LCFI39:
 450               		.cfi_def_cfa_offset 16
 451               		.cfi_offset 31, -15
 452               	/* prologue: Signal */
 453               	/* frame size = 0 */
 454               	/* stack size = 15 */
 455               	.L__stack_usage = 15
  93:main.c        ****     cli();
 456               		.loc 1 93 0
 457               	/* #APP */
 458               	 ;  93 "main.c" 1
 459 0168 F894      		cli
 460               	 ;  0 "" 2
  94:main.c        ****     test_vent_enc(0);
 461               		.loc 1 94 0
 462               	/* #NOAPP */
 463 016a 80E0      		ldi r24,0
 464 016c 0E94 0000 		call test_vent_enc
 465               	.LVL18:
  95:main.c        ****     sei();
 466               		.loc 1 95 0
 467               	/* #APP */
 468               	 ;  95 "main.c" 1
 469 0170 7894      		sei
 470               	 ;  0 "" 2
 471               	/* epilogue start */
  96:main.c        **** }
 472               		.loc 1 96 0
 473               	/* #NOAPP */
 474 0172 FF91      		pop r31
 475 0174 EF91      		pop r30
 476 0176 BF91      		pop r27
 477 0178 AF91      		pop r26
 478 017a 9F91      		pop r25
 479 017c 8F91      		pop r24
 480 017e 7F91      		pop r23
 481 0180 6F91      		pop r22
 482 0182 5F91      		pop r21
 483 0184 4F91      		pop r20
 484 0186 3F91      		pop r19
 485 0188 2F91      		pop r18
 486 018a 0F90      		pop r0
 487 018c 0FBE      		out __SREG__,r0
 488 018e 0F90      		pop r0
 489 0190 1F90      		pop r1
 490 0192 1895      		reti
 491               		.cfi_endproc
 492               	.LFE17:
 494               	.global	test_temp_enc
 496               	test_temp_enc:
 497               	.LFB18:
  97:main.c        **** 
  98:main.c        **** //********************** Temp Enc INT**********************
  99:main.c        **** 
 100:main.c        **** void test_temp_enc(int8_t up)
 101:main.c        **** {
 498               		.loc 1 101 0
 499               		.cfi_startproc
 500               	.LVL19:
 501               	/* prologue: function */
 502               	/* frame size = 0 */
 503               	/* stack size = 0 */
 504               	.L__stack_usage = 0
 505               	.LBB70:
 506               	.LBB71:
 507               		.file 2 "subs.h"
   1:subs.h        **** //#include <avr/wdt.h>
   2:subs.h        **** #define XTAL F_CPU
   3:subs.h        **** #include <stdint.h>
   4:subs.h        **** #include <avr/interrupt.h>
   5:subs.h        **** 
   6:subs.h        **** #define BTN_LONG_DELAY	2
   7:subs.h        **** 
   8:subs.h        **** typedef enum {
   9:subs.h        ****     ADC0=0,
  10:subs.h        ****     ADC1 =1,
  11:subs.h        ****     ADC2 =2,
  12:subs.h        ****     ADC3 =3,
  13:subs.h        ****     ADC4 =4,
  14:subs.h        ****     ADC5 =5,
  15:subs.h        ****     ADC6 =6,
  16:subs.h        ****     ADC7 =7
  17:subs.h        **** } adc_in_type;
  18:subs.h        **** 
  19:subs.h        **** /*************************************************************************
  20:subs.h        ****  delay loop for small accurate delays: 16-bit counter, 4 cycles/loop
  21:subs.h        ****  *************************************************************************/
  22:subs.h        **** static inline void _delayFourCycles(uint16_t __count)
  23:subs.h        **** {
  24:subs.h        ****     if (__count == 0)
  25:subs.h        **** 	__asm__ __volatile__( "rjmp 1f\n 1:" );
  26:subs.h        ****     // 2 cycles
  27:subs.h        ****     else
  28:subs.h        **** 	__asm__ __volatile__ (
 508               		.loc 2 28 0
 509 0194 E2E0      		ldi r30,lo8(2)
 510 0196 F0E0      		ldi r31,0
 511               	/* #APP */
 512               	 ;  28 "subs.h" 1
 513 0198 3197      		1: sbiw r30,1
 514 019a 01F4      		brne 1b
 515               	 ;  0 "" 2
 516               	.LVL20:
 517               	/* #NOAPP */
 518               	.LBE71:
 519               	.LBE70:
 102:main.c        ****     delay(1);
 103:main.c        ****     if (get_input(IN_BTN_T_UP) == get_input(IN_BTN_T_DWN)) {
 520               		.loc 1 103 0
 521 019c 29B1      		in r18,0x9
 522 019e 99B1      		in r25,0x9
 523 01a0 23FB      		bst r18,3
 524 01a2 3327      		clr r19
 525 01a4 30F9      		bld r19,0
 526 01a6 21E0      		ldi r18,lo8(1)
 527 01a8 2327      		eor r18,r19
 528 01aa 92FB      		bst r25,2
 529 01ac 9927      		clr r25
 530 01ae 90F9      		bld r25,0
 531 01b0 2917      		cp r18,r25
 532 01b2 01F0      		breq .L12
 104:main.c        **** 	if (up) {
 533               		.loc 1 104 0
 534 01b4 8823      		tst r24
 535 01b6 01F0      		breq .L14
 536               	.LVL21:
 537               	.LBB72:
 538               	.LBB73:
 105:main.c        **** 	    temp_enc++;
 539               		.loc 1 105 0
 540 01b8 8091 0000 		lds r24,temp_enc
 541               	.LVL22:
 542 01bc 8F5F      		subi r24,lo8(-(1))
 543 01be 00C0      		rjmp .L15
 544               	.LVL23:
 545               	.L14:
 546               	.LBE73:
 547               	.LBE72:
 106:main.c        **** 	} else {
 107:main.c        **** 	    temp_enc--;
 548               		.loc 1 107 0
 549 01c0 8091 0000 		lds r24,temp_enc
 550               	.LVL24:
 551 01c4 8150      		subi r24,lo8(-(-1))
 552               	.L15:
 553 01c6 8093 0000 		sts temp_enc,r24
 554               	.L12:
 555 01ca 0895      		ret
 556               		.cfi_endproc
 557               	.LFE18:
 559               	.global	__vector_1
 561               	__vector_1:
 562               	.LFB19:
 108:main.c        **** 	}
 109:main.c        ****     }
 110:main.c        **** }
 111:main.c        **** 
 112:main.c        **** ISR (INT0_vect) // IN_BTN_T_DWN Temp
 113:main.c        **** {
 563               		.loc 1 113 0
 564               		.cfi_startproc
 565 01cc 1F92      		push r1
 566               	.LCFI40:
 567               		.cfi_def_cfa_offset 3
 568               		.cfi_offset 1, -2
 569 01ce 0F92      		push r0
 570               	.LCFI41:
 571               		.cfi_def_cfa_offset 4
 572               		.cfi_offset 0, -3
 573 01d0 0FB6      		in r0,__SREG__
 574 01d2 0F92      		push r0
 575 01d4 1124      		clr __zero_reg__
 576 01d6 2F93      		push r18
 577               	.LCFI42:
 578               		.cfi_def_cfa_offset 5
 579               		.cfi_offset 18, -4
 580 01d8 3F93      		push r19
 581               	.LCFI43:
 582               		.cfi_def_cfa_offset 6
 583               		.cfi_offset 19, -5
 584 01da 4F93      		push r20
 585               	.LCFI44:
 586               		.cfi_def_cfa_offset 7
 587               		.cfi_offset 20, -6
 588 01dc 5F93      		push r21
 589               	.LCFI45:
 590               		.cfi_def_cfa_offset 8
 591               		.cfi_offset 21, -7
 592 01de 6F93      		push r22
 593               	.LCFI46:
 594               		.cfi_def_cfa_offset 9
 595               		.cfi_offset 22, -8
 596 01e0 7F93      		push r23
 597               	.LCFI47:
 598               		.cfi_def_cfa_offset 10
 599               		.cfi_offset 23, -9
 600 01e2 8F93      		push r24
 601               	.LCFI48:
 602               		.cfi_def_cfa_offset 11
 603               		.cfi_offset 24, -10
 604 01e4 9F93      		push r25
 605               	.LCFI49:
 606               		.cfi_def_cfa_offset 12
 607               		.cfi_offset 25, -11
 608 01e6 AF93      		push r26
 609               	.LCFI50:
 610               		.cfi_def_cfa_offset 13
 611               		.cfi_offset 26, -12
 612 01e8 BF93      		push r27
 613               	.LCFI51:
 614               		.cfi_def_cfa_offset 14
 615               		.cfi_offset 27, -13
 616 01ea EF93      		push r30
 617               	.LCFI52:
 618               		.cfi_def_cfa_offset 15
 619               		.cfi_offset 30, -14
 620 01ec FF93      		push r31
 621               	.LCFI53:
 622               		.cfi_def_cfa_offset 16
 623               		.cfi_offset 31, -15
 624               	/* prologue: Signal */
 625               	/* frame size = 0 */
 626               	/* stack size = 15 */
 627               	.L__stack_usage = 15
 114:main.c        ****     cli();
 628               		.loc 1 114 0
 629               	/* #APP */
 630               	 ;  114 "main.c" 1
 631 01ee F894      		cli
 632               	 ;  0 "" 2
 115:main.c        ****     test_temp_enc(1);
 633               		.loc 1 115 0
 634               	/* #NOAPP */
 635 01f0 81E0      		ldi r24,lo8(1)
 636 01f2 0E94 0000 		call test_temp_enc
 637               	.LVL25:
 116:main.c        ****     sei();
 638               		.loc 1 116 0
 639               	/* #APP */
 640               	 ;  116 "main.c" 1
 641 01f6 7894      		sei
 642               	 ;  0 "" 2
 643               	/* epilogue start */
 117:main.c        **** }
 644               		.loc 1 117 0
 645               	/* #NOAPP */
 646 01f8 FF91      		pop r31
 647 01fa EF91      		pop r30
 648 01fc BF91      		pop r27
 649 01fe AF91      		pop r26
 650 0200 9F91      		pop r25
 651 0202 8F91      		pop r24
 652 0204 7F91      		pop r23
 653 0206 6F91      		pop r22
 654 0208 5F91      		pop r21
 655 020a 4F91      		pop r20
 656 020c 3F91      		pop r19
 657 020e 2F91      		pop r18
 658 0210 0F90      		pop r0
 659 0212 0FBE      		out __SREG__,r0
 660 0214 0F90      		pop r0
 661 0216 1F90      		pop r1
 662 0218 1895      		reti
 663               		.cfi_endproc
 664               	.LFE19:
 666               	.global	__vector_2
 668               	__vector_2:
 669               	.LFB20:
 118:main.c        **** 
 119:main.c        **** ISR (INT1_vect) // IN_BTN_T_UP Temp
 120:main.c        **** {
 670               		.loc 1 120 0
 671               		.cfi_startproc
 672 021a 1F92      		push r1
 673               	.LCFI54:
 674               		.cfi_def_cfa_offset 3
 675               		.cfi_offset 1, -2
 676 021c 0F92      		push r0
 677               	.LCFI55:
 678               		.cfi_def_cfa_offset 4
 679               		.cfi_offset 0, -3
 680 021e 0FB6      		in r0,__SREG__
 681 0220 0F92      		push r0
 682 0222 1124      		clr __zero_reg__
 683 0224 2F93      		push r18
 684               	.LCFI56:
 685               		.cfi_def_cfa_offset 5
 686               		.cfi_offset 18, -4
 687 0226 3F93      		push r19
 688               	.LCFI57:
 689               		.cfi_def_cfa_offset 6
 690               		.cfi_offset 19, -5
 691 0228 4F93      		push r20
 692               	.LCFI58:
 693               		.cfi_def_cfa_offset 7
 694               		.cfi_offset 20, -6
 695 022a 5F93      		push r21
 696               	.LCFI59:
 697               		.cfi_def_cfa_offset 8
 698               		.cfi_offset 21, -7
 699 022c 6F93      		push r22
 700               	.LCFI60:
 701               		.cfi_def_cfa_offset 9
 702               		.cfi_offset 22, -8
 703 022e 7F93      		push r23
 704               	.LCFI61:
 705               		.cfi_def_cfa_offset 10
 706               		.cfi_offset 23, -9
 707 0230 8F93      		push r24
 708               	.LCFI62:
 709               		.cfi_def_cfa_offset 11
 710               		.cfi_offset 24, -10
 711 0232 9F93      		push r25
 712               	.LCFI63:
 713               		.cfi_def_cfa_offset 12
 714               		.cfi_offset 25, -11
 715 0234 AF93      		push r26
 716               	.LCFI64:
 717               		.cfi_def_cfa_offset 13
 718               		.cfi_offset 26, -12
 719 0236 BF93      		push r27
 720               	.LCFI65:
 721               		.cfi_def_cfa_offset 14
 722               		.cfi_offset 27, -13
 723 0238 EF93      		push r30
 724               	.LCFI66:
 725               		.cfi_def_cfa_offset 15
 726               		.cfi_offset 30, -14
 727 023a FF93      		push r31
 728               	.LCFI67:
 729               		.cfi_def_cfa_offset 16
 730               		.cfi_offset 31, -15
 731               	/* prologue: Signal */
 732               	/* frame size = 0 */
 733               	/* stack size = 15 */
 734               	.L__stack_usage = 15
 121:main.c        ****     cli();
 735               		.loc 1 121 0
 736               	/* #APP */
 737               	 ;  121 "main.c" 1
 738 023c F894      		cli
 739               	 ;  0 "" 2
 122:main.c        ****     test_temp_enc(0);
 740               		.loc 1 122 0
 741               	/* #NOAPP */
 742 023e 80E0      		ldi r24,0
 743 0240 0E94 0000 		call test_temp_enc
 744               	.LVL26:
 123:main.c        ****     sei();
 745               		.loc 1 123 0
 746               	/* #APP */
 747               	 ;  123 "main.c" 1
 748 0244 7894      		sei
 749               	 ;  0 "" 2
 750               	/* epilogue start */
 124:main.c        **** }
 751               		.loc 1 124 0
 752               	/* #NOAPP */
 753 0246 FF91      		pop r31
 754 0248 EF91      		pop r30
 755 024a BF91      		pop r27
 756 024c AF91      		pop r26
 757 024e 9F91      		pop r25
 758 0250 8F91      		pop r24
 759 0252 7F91      		pop r23
 760 0254 6F91      		pop r22
 761 0256 5F91      		pop r21
 762 0258 4F91      		pop r20
 763 025a 3F91      		pop r19
 764 025c 2F91      		pop r18
 765 025e 0F90      		pop r0
 766 0260 0FBE      		out __SREG__,r0
 767 0262 0F90      		pop r0
 768 0264 1F90      		pop r1
 769 0266 1895      		reti
 770               		.cfi_endproc
 771               	.LFE20:
 773               	.global	set_def_vals
 775               	set_def_vals:
 776               	.LFB21:
 125:main.c        **** 
 126:main.c        **** //********************** **********************
 127:main.c        **** void set_def_vals(void)
 128:main.c        **** {
 777               		.loc 1 128 0
 778               		.cfi_startproc
 779               	/* prologue: function */
 780               	/* frame size = 0 */
 781               	/* stack size = 0 */
 782               	.L__stack_usage = 0
 129:main.c        ****     vars.setup_temp = 20;
 783               		.loc 1 129 0
 784 0268 E0E0      		ldi r30,lo8(vars)
 785 026a F0E0      		ldi r31,hi8(vars)
 786 026c 84E1      		ldi r24,lo8(20)
 787 026e 8183      		std Z+1,r24
 130:main.c        ****     vars.vent_nom_seg = 4;
 788               		.loc 1 130 0
 789 0270 84E0      		ldi r24,lo8(4)
 790 0272 8283      		std Z+2,r24
 131:main.c        ****     vars.temp_seg = 2;
 791               		.loc 1 131 0
 792 0274 92E0      		ldi r25,lo8(2)
 793 0276 9383      		std Z+3,r25
 132:main.c        ****     vars.wmode = wmode_auto;
 794               		.loc 1 132 0
 795 0278 1082      		st Z,__zero_reg__
 133:main.c        ****     vars.const_cnd_frost_t = COND_T_FROST;
 796               		.loc 1 133 0
 797 027a 85E0      		ldi r24,lo8(5)
 798 027c 8087      		std Z+8,r24
 134:main.c        ****     vars.pid_P_kfc = PID_P_KFC;
 799               		.loc 1 134 0
 800 027e 8AE0      		ldi r24,lo8(10)
 801 0280 8483      		std Z+4,r24
 135:main.c        ****     vars.pid_I_kfc = PID_I_KFC;
 802               		.loc 1 135 0
 803 0282 8FE0      		ldi r24,lo8(15)
 804 0284 8583      		std Z+5,r24
 136:main.c        ****     vars.vent_var_kfc = VENT_VAR_KFC;
 805               		.loc 1 136 0
 806 0286 83E0      		ldi r24,lo8(3)
 807 0288 8683      		std Z+6,r24
 137:main.c        ****     vars.temp_seg_delay = TEMP_OUT_DELAY;
 808               		.loc 1 137 0
 809 028a 9783      		std Z+7,r25
 138:main.c        ****     vars.cond_enabled = 0;
 810               		.loc 1 138 0
 811 028c 1186      		std Z+9,__zero_reg__
 139:main.c        ****     vars.auto_defrost = 3;
 812               		.loc 1 139 0
 813 028e 8287      		std Z+10,r24
 814 0290 0895      		ret
 815               		.cfi_endproc
 816               	.LFE21:
 818               	.global	myread_eeprom
 820               	myread_eeprom:
 821               	.LFB22:
 140:main.c        **** }
 141:main.c        **** 
 142:main.c        **** void myread_eeprom(void)
 143:main.c        **** {
 822               		.loc 1 143 0
 823               		.cfi_startproc
 824               	/* prologue: function */
 825               	/* frame size = 0 */
 826               	/* stack size = 0 */
 827               	.L__stack_usage = 0
 144:main.c        ****     cli();
 828               		.loc 1 144 0
 829               	/* #APP */
 830               	 ;  144 "main.c" 1
 831 0292 F894      		cli
 832               	 ;  0 "" 2
 145:main.c        ****     eeprom_read_buf((uint8_t *) &vars, EEMEM_VARS, sizeof(vars));
 833               		.loc 1 145 0
 834               	/* #NOAPP */
 835 0294 4BE0      		ldi r20,lo8(11)
 836 0296 50E0      		ldi r21,0
 837 0298 64E6      		ldi r22,lo8(100)
 838 029a 70E0      		ldi r23,0
 839 029c 80E0      		ldi r24,lo8(vars)
 840 029e 90E0      		ldi r25,hi8(vars)
 841 02a0 0E94 0000 		call eeprom_read_buf
 842               	.LVL27:
 146:main.c        **** //    eeprom_read_block(&vars, 10, sizeof(vars));
 147:main.c        **** //    uint8_t tst = eeprom_read_byte(&ftst_ee);
 148:main.c        ****     uint8_t tst = eeprom_read_byte1(EEMEM_TST);
 843               		.loc 1 148 0
 844 02a4 82E3      		ldi r24,lo8(50)
 845 02a6 90E0      		ldi r25,0
 846 02a8 0E94 0000 		call eeprom_read_byte1
 847               	.LVL28:
 149:main.c        ****     if (tst != 0xaa) {
 848               		.loc 1 149 0
 849 02ac 8A3A      		cpi r24,lo8(-86)
 850 02ae 01F0      		breq .L19
 150:main.c        **** 	set_def_vals();
 851               		.loc 1 150 0
 852 02b0 0C94 0000 		jmp set_def_vals
 853               	.LVL29:
 854               	.L19:
 855 02b4 0895      		ret
 856               		.cfi_endproc
 857               	.LFE22:
 859               	.global	myupdate_eeprom
 861               	myupdate_eeprom:
 862               	.LFB23:
 151:main.c        ****     }
 152:main.c        **** }
 153:main.c        **** 
 154:main.c        **** void myupdate_eeprom(void)
 155:main.c        **** {
 863               		.loc 1 155 0
 864               		.cfi_startproc
 865               	/* prologue: function */
 866               	/* frame size = 0 */
 867               	/* stack size = 0 */
 868               	.L__stack_usage = 0
 156:main.c        ****     cli();
 869               		.loc 1 156 0
 870               	/* #APP */
 871               	 ;  156 "main.c" 1
 872 02b6 F894      		cli
 873               	 ;  0 "" 2
 157:main.c        ****     eeprom_update_buf(EEMEM_VARS, (uint8_t *) &vars, sizeof(vars));
 874               		.loc 1 157 0
 875               	/* #NOAPP */
 876 02b8 4BE0      		ldi r20,lo8(11)
 877 02ba 50E0      		ldi r21,0
 878 02bc 60E0      		ldi r22,lo8(vars)
 879 02be 70E0      		ldi r23,hi8(vars)
 880 02c0 84E6      		ldi r24,lo8(100)
 881 02c2 90E0      		ldi r25,0
 882 02c4 0E94 0000 		call eeprom_update_buf
 883               	.LVL30:
 158:main.c        ****     if (eeprom_read_byte1(EEMEM_TST) != 0xaa) {
 884               		.loc 1 158 0
 885 02c8 82E3      		ldi r24,lo8(50)
 886 02ca 90E0      		ldi r25,0
 887 02cc 0E94 0000 		call eeprom_read_byte1
 888               	.LVL31:
 889 02d0 8A3A      		cpi r24,lo8(-86)
 890 02d2 01F0      		breq .L21
 159:main.c        **** 	eeprom_write_byte1(EEMEM_TST, 0xaa);
 891               		.loc 1 159 0
 892 02d4 6AEA      		ldi r22,lo8(-86)
 893 02d6 82E3      		ldi r24,lo8(50)
 894 02d8 90E0      		ldi r25,0
 895 02da 0C94 0000 		jmp eeprom_write_byte1
 896               	.LVL32:
 897               	.L21:
 898 02de 0895      		ret
 899               		.cfi_endproc
 900               	.LFE23:
 902               	.global	switch_temp
 904               	switch_temp:
 905               	.LFB24:
 160:main.c        ****     }
 161:main.c        ****     /*
 162:main.c        ****      eeprom_update_block(&vars, 10, sizeof(vars));
 163:main.c        ****      uint8_t tst = 0xaa;
 164:main.c        ****      //eeprom_update_byte(&ftst_ee, &tst);
 165:main.c        ****      */
 166:main.c        **** }
 167:main.c        **** 
 168:main.c        **** /*
 169:main.c        ****  uint8_t hex_to_num(int8_t sym)
 170:main.c        ****  {
 171:main.c        ****  if (sym >= '0' && sym <= '9')
 172:main.c        ****  return (sym - '0');
 173:main.c        ****  else if (sym >= 'A' && sym <= 'F')
 174:main.c        ****  return (sym - 'A' + 10);
 175:main.c        ****  return (255);
 176:main.c        ****  }
 177:main.c        **** 
 178:main.c        ****  uint8_t str_to_num(struct m2bytes nbuf)
 179:main.c        ****  {
 180:main.c        ****  uint8_t num1, num2;
 181:main.c        **** 
 182:main.c        ****  num1 = hex_to_num(nbuf.one);
 183:main.c        ****  if (num1 >= 0 && num1 <= 9)
 184:main.c        ****  num1 *= 10;
 185:main.c        ****  else
 186:main.c        ****  return (255);
 187:main.c        ****  num2 = hex_to_num(nbuf.two);
 188:main.c        ****  if (num2 >= 0 && num2 <= 9)
 189:main.c        ****  return (num2 + num1);
 190:main.c        ****  return (255);
 191:main.c        ****  }
 192:main.c        **** 
 193:main.c        ****  void num_to_hex(struct m2bytes *nbuf)
 194:main.c        ****  {
 195:main.c        ****  uint8_t tmp, num;
 196:main.c        ****  //m2bytes nbuf;
 197:main.c        **** 
 198:main.c        ****  num = nbuf->one;
 199:main.c        ****  tmp = num / 16;
 200:main.c        ****  if (tmp > 9)
 201:main.c        ****  nbuf->one = tmp + 'A' - 10;
 202:main.c        ****  else
 203:main.c        ****  nbuf->one = tmp + '0';
 204:main.c        ****  num -= tmp * 16;
 205:main.c        ****  if (num > 9)
 206:main.c        ****  nbuf->two = num + 'A' - 10;
 207:main.c        ****  else
 208:main.c        ****  nbuf->two = num + '0';
 209:main.c        ****  }
 210:main.c        ****  */
 211:main.c        **** #define DELAY_ENC_BTWN 550
 212:main.c        **** #define DELAY_ENC_CKL_MS 40
 213:main.c        **** void switch_temp(int8_t up)
 214:main.c        **** {
 906               		.loc 1 214 0
 907               		.cfi_startproc
 908               	.LVL33:
 909               	/* prologue: function */
 910               	/* frame size = 0 */
 911               	/* stack size = 0 */
 912               	.L__stack_usage = 0
 215:main.c        ****     if (up) {
 913               		.loc 1 215 0
 914 02e0 8823      		tst r24
 915 02e2 01F0      		breq .L24
 216:main.c        **** 	if (get_output(OUT_BTN_T_UP)) {
 916               		.loc 1 216 0
 917 02e4 5D9B      		sbis 0xb,5
 918 02e6 00C0      		rjmp .L25
 217:main.c        **** 	    pin_low(OUT_BTN_T_UP);
 919               		.loc 1 217 0
 920 02e8 5D98      		cbi 0xb,5
 921               	.LVL34:
 922               	.LBB74:
 923               	.LBB75:
 924               		.loc 2 28 0
 925 02ea 8CE4      		ldi r24,lo8(76)
 926 02ec 94E0      		ldi r25,lo8(4)
 927               	.LVL35:
 928               	/* #APP */
 929               	 ;  28 "subs.h" 1
 930 02ee 0197      		1: sbiw r24,1
 931 02f0 01F4      		brne 1b
 932               	 ;  0 "" 2
 933               	.LVL36:
 934               	/* #NOAPP */
 935               	.LBE75:
 936               	.LBE74:
 218:main.c        **** 	    delay(DELAY_ENC_BTWN);
 219:main.c        **** 	    pin_low(OUT_BTN_T_DWN);
 937               		.loc 1 219 0
 938 02f2 5C98      		cbi 0xb,4
 939 02f4 00C0      		rjmp .L26
 940               	.LVL37:
 941               	.L25:
 220:main.c        **** 	} else {
 221:main.c        **** 	    pin_high(OUT_BTN_T_UP);
 942               		.loc 1 221 0
 943 02f6 5D9A      		sbi 0xb,5
 944               	.LVL38:
 945               	.LBB76:
 946               	.LBB77:
 947               		.loc 2 28 0
 948 02f8 8CE4      		ldi r24,lo8(76)
 949 02fa 94E0      		ldi r25,lo8(4)
 950               	.LVL39:
 951               	/* #APP */
 952               	 ;  28 "subs.h" 1
 953 02fc 0197      		1: sbiw r24,1
 954 02fe 01F4      		brne 1b
 955               	 ;  0 "" 2
 956               	.LVL40:
 957               	/* #NOAPP */
 958               	.LBE77:
 959               	.LBE76:
 222:main.c        **** 	    delay(DELAY_ENC_BTWN);
 223:main.c        **** 	    pin_high(OUT_BTN_T_DWN);
 960               		.loc 1 223 0
 961 0300 5C9A      		sbi 0xb,4
 962 0302 00C0      		rjmp .L26
 963               	.LVL41:
 964               	.L24:
 224:main.c        **** 	}
 225:main.c        ****     } else {
 226:main.c        **** 	if (get_output(OUT_BTN_T_UP)) {
 965               		.loc 1 226 0
 966 0304 5D9B      		sbis 0xb,5
 967 0306 00C0      		rjmp .L27
 227:main.c        **** 	    pin_low(OUT_BTN_T_DWN);
 968               		.loc 1 227 0
 969 0308 5C98      		cbi 0xb,4
 970               	.LVL42:
 971               	.LBB78:
 972               	.LBB79:
 973               		.loc 2 28 0
 974 030a 8CE4      		ldi r24,lo8(76)
 975 030c 94E0      		ldi r25,lo8(4)
 976               	.LVL43:
 977               	/* #APP */
 978               	 ;  28 "subs.h" 1
 979 030e 0197      		1: sbiw r24,1
 980 0310 01F4      		brne 1b
 981               	 ;  0 "" 2
 982               	.LVL44:
 983               	/* #NOAPP */
 984               	.LBE79:
 985               	.LBE78:
 228:main.c        **** 	    delay(DELAY_ENC_BTWN);
 229:main.c        **** 	    pin_low(OUT_BTN_T_UP);
 986               		.loc 1 229 0
 987 0312 5D98      		cbi 0xb,5
 988 0314 00C0      		rjmp .L26
 989               	.LVL45:
 990               	.L27:
 230:main.c        **** 	} else {
 231:main.c        **** 	    pin_high(OUT_BTN_T_DWN);
 991               		.loc 1 231 0
 992 0316 5C9A      		sbi 0xb,4
 993               	.LVL46:
 994               	.LBB80:
 995               	.LBB81:
 996               		.loc 2 28 0
 997 0318 8CE4      		ldi r24,lo8(76)
 998 031a 94E0      		ldi r25,lo8(4)
 999               	.LVL47:
 1000               	/* #APP */
 1001               	 ;  28 "subs.h" 1
 1002 031c 0197      		1: sbiw r24,1
 1003 031e 01F4      		brne 1b
 1004               	 ;  0 "" 2
 1005               	.LVL48:
 1006               	/* #NOAPP */
 1007               	.LBE81:
 1008               	.LBE80:
 232:main.c        **** 	    delay(DELAY_ENC_BTWN);
 233:main.c        **** 	    pin_high(OUT_BTN_T_UP);
 1009               		.loc 1 233 0
 1010 0320 5D9A      		sbi 0xb,5
 1011               	.L26:
 234:main.c        **** 	}
 235:main.c        ****     }
 236:main.c        ****     delay_ms(DELAY_ENC_CKL_MS);
 1012               		.loc 1 236 0
 1013 0322 88E2      		ldi r24,lo8(40)
 1014 0324 90E0      		ldi r25,0
 1015 0326 0C94 0000 		jmp delay_ms
 1016               	.LVL49:
 1017               		.cfi_endproc
 1018               	.LFE24:
 1020               	.global	switch_vent
 1022               	switch_vent:
 1023               	.LFB25:
 237:main.c        **** }
 238:main.c        **** 
 239:main.c        **** void switch_vent(int8_t up)
 240:main.c        **** {
 1024               		.loc 1 240 0
 1025               		.cfi_startproc
 1026               	.LVL50:
 1027               	/* prologue: function */
 1028               	/* frame size = 0 */
 1029               	/* stack size = 0 */
 1030               	.L__stack_usage = 0
 241:main.c        ****     if (up) {
 1031               		.loc 1 241 0
 1032 032a 8823      		tst r24
 1033 032c 01F0      		breq .L29
 242:main.c        **** 	if (get_output(OUT_BTN_V_UP)) {
 1034               		.loc 1 242 0
 1035 032e 5E9B      		sbis 0xb,6
 1036 0330 00C0      		rjmp .L30
 243:main.c        **** 	    pin_low(OUT_BTN_V_UP);
 1037               		.loc 1 243 0
 1038 0332 5E98      		cbi 0xb,6
 1039               	.LVL51:
 1040               	.LBB82:
 1041               	.LBB83:
 1042               		.loc 2 28 0
 1043 0334 8CE4      		ldi r24,lo8(76)
 1044 0336 94E0      		ldi r25,lo8(4)
 1045               	.LVL52:
 1046               	/* #APP */
 1047               	 ;  28 "subs.h" 1
 1048 0338 0197      		1: sbiw r24,1
 1049 033a 01F4      		brne 1b
 1050               	 ;  0 "" 2
 1051               	.LVL53:
 1052               	/* #NOAPP */
 1053               	.LBE83:
 1054               	.LBE82:
 244:main.c        **** 	    delay(DELAY_ENC_BTWN);
 245:main.c        **** 	    pin_low(OUT_BTN_V_DWN);
 1055               		.loc 1 245 0
 1056 033c 2998      		cbi 0x5,1
 1057 033e 00C0      		rjmp .L31
 1058               	.LVL54:
 1059               	.L30:
 246:main.c        **** 	} else {
 247:main.c        **** 	    pin_high(OUT_BTN_V_UP);
 1060               		.loc 1 247 0
 1061 0340 5E9A      		sbi 0xb,6
 1062               	.LVL55:
 1063               	.LBB84:
 1064               	.LBB85:
 1065               		.loc 2 28 0
 1066 0342 8CE4      		ldi r24,lo8(76)
 1067 0344 94E0      		ldi r25,lo8(4)
 1068               	.LVL56:
 1069               	/* #APP */
 1070               	 ;  28 "subs.h" 1
 1071 0346 0197      		1: sbiw r24,1
 1072 0348 01F4      		brne 1b
 1073               	 ;  0 "" 2
 1074               	.LVL57:
 1075               	/* #NOAPP */
 1076               	.LBE85:
 1077               	.LBE84:
 248:main.c        **** 	    delay(DELAY_ENC_BTWN);
 249:main.c        **** 	    pin_high(OUT_BTN_V_DWN);
 1078               		.loc 1 249 0
 1079 034a 299A      		sbi 0x5,1
 1080 034c 00C0      		rjmp .L31
 1081               	.LVL58:
 1082               	.L29:
 250:main.c        **** 	}
 251:main.c        ****     } else {
 252:main.c        **** 	if (get_output(OUT_BTN_V_UP)) {
 1083               		.loc 1 252 0
 1084 034e 5E9B      		sbis 0xb,6
 1085 0350 00C0      		rjmp .L32
 253:main.c        **** 	    pin_low(OUT_BTN_V_DWN);
 1086               		.loc 1 253 0
 1087 0352 2998      		cbi 0x5,1
 1088               	.LVL59:
 1089               	.LBB86:
 1090               	.LBB87:
 1091               		.loc 2 28 0
 1092 0354 8CE4      		ldi r24,lo8(76)
 1093 0356 94E0      		ldi r25,lo8(4)
 1094               	.LVL60:
 1095               	/* #APP */
 1096               	 ;  28 "subs.h" 1
 1097 0358 0197      		1: sbiw r24,1
 1098 035a 01F4      		brne 1b
 1099               	 ;  0 "" 2
 1100               	.LVL61:
 1101               	/* #NOAPP */
 1102               	.LBE87:
 1103               	.LBE86:
 254:main.c        **** 	    delay(DELAY_ENC_BTWN);
 255:main.c        **** 	    pin_low(OUT_BTN_V_UP);
 1104               		.loc 1 255 0
 1105 035c 5E98      		cbi 0xb,6
 1106 035e 00C0      		rjmp .L31
 1107               	.LVL62:
 1108               	.L32:
 256:main.c        **** 	} else {
 257:main.c        **** 	    pin_high(OUT_BTN_V_DWN);
 1109               		.loc 1 257 0
 1110 0360 299A      		sbi 0x5,1
 1111               	.LVL63:
 1112               	.LBB88:
 1113               	.LBB89:
 1114               		.loc 2 28 0
 1115 0362 8CE4      		ldi r24,lo8(76)
 1116 0364 94E0      		ldi r25,lo8(4)
 1117               	.LVL64:
 1118               	/* #APP */
 1119               	 ;  28 "subs.h" 1
 1120 0366 0197      		1: sbiw r24,1
 1121 0368 01F4      		brne 1b
 1122               	 ;  0 "" 2
 1123               	.LVL65:
 1124               	/* #NOAPP */
 1125               	.LBE89:
 1126               	.LBE88:
 258:main.c        **** 	    delay(DELAY_ENC_BTWN);
 259:main.c        **** 	    pin_high(OUT_BTN_V_UP);
 1127               		.loc 1 259 0
 1128 036a 5E9A      		sbi 0xb,6
 1129               	.L31:
 260:main.c        **** 	}
 261:main.c        ****     }
 262:main.c        ****     delay_ms(DELAY_ENC_CKL_MS);
 1130               		.loc 1 262 0
 1131 036c 88E2      		ldi r24,lo8(40)
 1132 036e 90E0      		ldi r25,0
 1133 0370 0C94 0000 		jmp delay_ms
 1134               	.LVL66:
 1135               		.cfi_endproc
 1136               	.LFE25:
 1138               	.global	prc2Seg
 1140               	prc2Seg:
 1141               	.LFB26:
 263:main.c        **** }
 264:main.c        **** 
 265:main.c        **** uint8_t prc2Seg(uint8_t segs, uint8_t prc)
 266:main.c        **** {
 1142               		.loc 1 266 0
 1143               		.cfi_startproc
 1144               	.LVL67:
 1145 0374 CF93      		push r28
 1146               	.LCFI68:
 1147               		.cfi_def_cfa_offset 3
 1148               		.cfi_offset 28, -2
 1149               	/* prologue: function */
 1150               	/* frame size = 0 */
 1151               	/* stack size = 1 */
 1152               	.L__stack_usage = 1
 1153 0376 C82F      		mov r28,r24
 267:main.c        ****     prc = check_range(0, prc, 100);
 1154               		.loc 1 267 0
 1155 0378 70E0      		ldi r23,0
 1156 037a 44E6      		ldi r20,lo8(100)
 1157 037c 50E0      		ldi r21,0
 1158 037e 80E0      		ldi r24,0
 1159 0380 90E0      		ldi r25,0
 1160               	.LVL68:
 1161 0382 0E94 0000 		call check_range
 1162               	.LVL69:
 268:main.c        ****     uint16_t tmp = (segs * prc + segs) / 100;
 269:main.c        ****     return tmp;
 1163               		.loc 1 269 0
 1164 0386 9C01      		movw r18,r24
 1165 0388 3327      		clr r19
 1166 038a 2F5F      		subi r18,-1
 1167 038c 3F4F      		sbci r19,-1
 1168 038e C29F      		mul r28,r18
 1169 0390 C001      		movw r24,r0
 1170 0392 C39F      		mul r28,r19
 1171 0394 900D      		add r25,r0
 1172 0396 1124      		clr __zero_reg__
 1173               	.LVL70:
 1174 0398 64E6      		ldi r22,lo8(100)
 1175 039a 70E0      		ldi r23,0
 1176 039c 0E94 0000 		call __divmodhi4
 1177               	.LVL71:
 1178 03a0 862F      		mov r24,r22
 1179               	/* epilogue start */
 270:main.c        **** }
 1180               		.loc 1 270 0
 1181 03a2 CF91      		pop r28
 1182               	.LVL72:
 1183 03a4 0895      		ret
 1184               		.cfi_endproc
 1185               	.LFE26:
 1187               	.global	seg2Prc
 1189               	seg2Prc:
 1190               	.LFB27:
 271:main.c        **** 
 272:main.c        **** uint8_t seg2Prc(uint8_t segs, uint8_t seg)
 273:main.c        **** {
 1191               		.loc 1 273 0
 1192               		.cfi_startproc
 1193               	.LVL73:
 1194               	/* prologue: function */
 1195               	/* frame size = 0 */
 1196               	/* stack size = 0 */
 1197               	.L__stack_usage = 0
 274:main.c        ****     //seg = check_range(0, seg, segs);
 275:main.c        ****     uint16_t tmp = (seg * 100) / segs;
 276:main.c        ****     return tmp;
 1198               		.loc 1 276 0
 1199 03a6 94E6      		ldi r25,lo8(100)
 1200 03a8 699F      		mul r22,r25
 1201 03aa 9001      		movw r18,r0
 1202 03ac 1124      		clr __zero_reg__
 1203 03ae 682F      		mov r22,r24
 1204               	.LVL74:
 1205 03b0 70E0      		ldi r23,0
 1206 03b2 C901      		movw r24,r18
 1207               	.LVL75:
 1208 03b4 0E94 0000 		call __divmodhi4
 1209               	.LVL76:
 1210 03b8 862F      		mov r24,r22
 277:main.c        **** }
 1211               		.loc 1 277 0
 1212 03ba 0895      		ret
 1213               		.cfi_endproc
 1214               	.LFE27:
 1216               	.global	set_temp
 1218               	set_temp:
 1219               	.LFB28:
 278:main.c        **** 
 279:main.c        **** void set_temp(uint8_t prc, int8_t full_sync)
 280:main.c        **** {
 1220               		.loc 1 280 0
 1221               		.cfi_startproc
 1222               	.LVL77:
 1223 03bc 0F93      		push r16
 1224               	.LCFI69:
 1225               		.cfi_def_cfa_offset 3
 1226               		.cfi_offset 16, -2
 1227 03be 1F93      		push r17
 1228               	.LCFI70:
 1229               		.cfi_def_cfa_offset 4
 1230               		.cfi_offset 17, -3
 1231 03c0 CF93      		push r28
 1232               	.LCFI71:
 1233               		.cfi_def_cfa_offset 5
 1234               		.cfi_offset 28, -4
 1235 03c2 DF93      		push r29
 1236               	.LCFI72:
 1237               		.cfi_def_cfa_offset 6
 1238               		.cfi_offset 29, -5
 1239               	/* prologue: function */
 1240               	/* frame size = 0 */
 1241               	/* stack size = 4 */
 1242               	.L__stack_usage = 4
 1243 03c4 D62F      		mov r29,r22
 281:main.c        ****     uint8_t seg_temp = prc2Seg(TEMP_SEG, prc);
 1244               		.loc 1 281 0
 1245 03c6 682F      		mov r22,r24
 1246               	.LVL78:
 1247 03c8 8FE0      		ldi r24,lo8(15)
 1248               	.LVL79:
 1249 03ca 0E94 0000 		call prc2Seg
 1250               	.LVL80:
 1251 03ce C82F      		mov r28,r24
 1252               	.LVL81:
 282:main.c        **** 
 283:main.c        ****     if (seg_temp == 0) { //add sync
 1253               		.loc 1 283 0
 1254 03d0 8111      		cpse r24,__zero_reg__
 1255 03d2 00C0      		rjmp .L36
 284:main.c        **** 	switch_temp(0);
 1256               		.loc 1 284 0
 1257 03d4 80E0      		ldi r24,0
 1258               	.LVL82:
 1259 03d6 00C0      		rjmp .L53
 1260               	.LVL83:
 1261               	.L36:
 285:main.c        ****     } else if (seg_temp == TEMP_SEG) {
 1262               		.loc 1 285 0
 1263 03d8 8F30      		cpi r24,lo8(15)
 1264 03da 01F4      		brne .L37
 286:main.c        **** 	switch_temp(1);
 1265               		.loc 1 286 0
 1266 03dc 81E0      		ldi r24,lo8(1)
 1267               	.LVL84:
 1268               	.L53:
 1269 03de 0E94 0000 		call switch_temp
 1270               	.LVL85:
 1271               	.L37:
 287:main.c        ****     }
 288:main.c        **** 
 289:main.c        ****     if (temp_seg_cur != seg_temp) {
 1272               		.loc 1 289 0
 1273 03e2 8091 0000 		lds r24,temp_seg_cur
 1274 03e6 2C2F      		mov r18,r28
 1275 03e8 30E0      		ldi r19,0
 1276 03ea 082E      		mov __tmp_reg__,r24
 1277 03ec 000C      		lsl r0
 1278 03ee 990B      		sbc r25,r25
 1279 03f0 8217      		cp r24,r18
 1280 03f2 9307      		cpc r25,r19
 1281 03f4 01F4      		brne .+2
 1282 03f6 00C0      		rjmp .L35
 1283               	.LVL86:
 1284               	.LBB90:
 290:main.c        **** 	uint8_t seg_t = seg_temp;
 291:main.c        **** 	if (full_sync) {
 1285               		.loc 1 291 0
 1286 03f8 DD23      		tst r29
 1287 03fa 01F0      		breq .L39
 1288               	.LBB91:
 292:main.c        **** 	    int8_t up = (temp_seg_cur > TEMP_SEG / 2);
 1289               		.loc 1 292 0
 1290 03fc 1091 0000 		lds r17,temp_seg_cur
 1291 0400 01E0      		ldi r16,lo8(1)
 1292 0402 1830      		cpi r17,lo8(8)
 1293 0404 04F4      		brge .L40
 1294 0406 00E0      		ldi r16,0
 1295               	.L40:
 1296               	.LVL87:
 1297 0408 D9E0      		ldi r29,lo8(9)
 1298               	.LVL88:
 1299               	.L41:
 1300               	.LBB92:
 293:main.c        **** 	    for (uint8_t i = 0; i < TEMP_SEG / 2 + 2; i++) {
 294:main.c        **** 		switch_temp(up);
 1301               		.loc 1 294 0 discriminator 3
 1302 040a 802F      		mov r24,r16
 1303 040c 0E94 0000 		call switch_temp
 1304               	.LVL89:
 1305 0410 D150      		subi r29,lo8(-(-1))
 1306               	.LVL90:
 293:main.c        **** 	    for (uint8_t i = 0; i < TEMP_SEG / 2 + 2; i++) {
 1307               		.loc 1 293 0 discriminator 3
 1308 0412 01F4      		brne .L41
 1309               	.LBE92:
 295:main.c        **** 	    }
 296:main.c        **** 	    if (up) {
 1310               		.loc 1 296 0
 1311 0414 1830      		cpi r17,lo8(8)
 1312 0416 04F0      		brlt .L51
 297:main.c        **** 		seg_temp = TEMP_SEG - seg_temp;
 1313               		.loc 1 297 0
 1314 0418 DFE0      		ldi r29,lo8(15)
 1315               	.LVL91:
 1316 041a DC1B      		sub r29,r28
 1317               	.LVL92:
 1318 041c 00C0      		rjmp .L42
 1319               	.LVL93:
 1320               	.L51:
 1321               	.LBE91:
 1322               	.LBE90:
 281:main.c        **** 
 1323               		.loc 1 281 0
 1324 041e DC2F      		mov r29,r28
 1325               	.LVL94:
 1326               	.L42:
 1327               	.LBB97:
 1328               	.LBB94:
 298:main.c        **** 	    }
 299:main.c        **** 	    up = !up;
 1329               		.loc 1 299 0
 1330 0420 01E0      		ldi r16,lo8(1)
 1331               	.LVL95:
 1332 0422 1830      		cpi r17,lo8(8)
 1333 0424 04F0      		brlt .L43
 1334 0426 00E0      		ldi r16,0
 1335               	.L43:
 1336               	.LVL96:
 300:main.c        **** 	    delay_ms(60);
 1337               		.loc 1 300 0
 1338 0428 8CE3      		ldi r24,lo8(60)
 1339 042a 90E0      		ldi r25,0
 1340 042c 0E94 0000 		call delay_ms
 1341               	.LVL97:
 1342               	.LBB93:
 301:main.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 1343               		.loc 1 301 0
 1344 0430 10E0      		ldi r17,0
 1345               	.LVL98:
 1346               	.L44:
 1347               		.loc 1 301 0 is_stmt 0 discriminator 1
 1348 0432 D117      		cp r29,r17
 1349 0434 01F0      		breq .L50
 302:main.c        **** 		switch_temp(up);
 1350               		.loc 1 302 0 is_stmt 1 discriminator 3
 1351 0436 802F      		mov r24,r16
 1352 0438 0E94 0000 		call switch_temp
 1353               	.LVL99:
 301:main.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 1354               		.loc 1 301 0 discriminator 3
 1355 043c 1F5F      		subi r17,lo8(-(1))
 1356               	.LVL100:
 1357 043e 00C0      		rjmp .L44
 1358               	.LVL101:
 1359               	.L50:
 1360               	.LBE93:
 1361               	.LBE94:
 303:main.c        **** 	    }
 304:main.c        **** 	} else {
 305:main.c        **** 	    int8_t up = 0;
 306:main.c        **** 	    if (seg_temp > temp_seg_cur) {
 307:main.c        **** 		seg_temp = seg_temp - temp_seg_cur; // delta
 308:main.c        **** 		up = 1;
 309:main.c        **** 	    } else {
 310:main.c        **** 		seg_temp = temp_seg_cur - seg_temp; // delta
 311:main.c        **** 	    }
 312:main.c        **** 	    for (uint8_t i = 0; i < seg_temp; i++) {
 313:main.c        **** 		switch_temp(up);
 314:main.c        **** 	    }
 315:main.c        **** 	}
 316:main.c        **** 	temp_seg_cur = seg_t;
 1362               		.loc 1 316 0
 1363 0440 C093 0000 		sts temp_seg_cur,r28
 1364 0444 00C0      		rjmp .L35
 1365               	.LVL102:
 1366               	.L39:
 1367               	.LBB95:
 306:main.c        **** 		seg_temp = seg_temp - temp_seg_cur; // delta
 1368               		.loc 1 306 0
 1369 0446 8091 0000 		lds r24,temp_seg_cur
 1370 044a 082E      		mov __tmp_reg__,r24
 1371 044c 000C      		lsl r0
 1372 044e 990B      		sbc r25,r25
 1373 0450 8217      		cp r24,r18
 1374 0452 9307      		cpc r25,r19
 1375 0454 04F4      		brge .L46
 307:main.c        **** 		up = 1;
 1376               		.loc 1 307 0
 1377 0456 8091 0000 		lds r24,temp_seg_cur
 1378 045a DC2F      		mov r29,r28
 1379               	.LVL103:
 1380 045c D81B      		sub r29,r24
 1381               	.LVL104:
 308:main.c        **** 	    } else {
 1382               		.loc 1 308 0
 1383 045e 01E0      		ldi r16,lo8(1)
 1384 0460 00C0      		rjmp .L47
 1385               	.LVL105:
 1386               	.L46:
 310:main.c        **** 	    }
 1387               		.loc 1 310 0
 1388 0462 D091 0000 		lds r29,temp_seg_cur
 1389               	.LVL106:
 1390 0466 DC1B      		sub r29,r28
 1391               	.LVL107:
 305:main.c        **** 	    if (seg_temp > temp_seg_cur) {
 1392               		.loc 1 305 0
 1393 0468 00E0      		ldi r16,0
 1394               	.LVL108:
 1395               	.L47:
 1396               	.LBB96:
 312:main.c        **** 		switch_temp(up);
 1397               		.loc 1 312 0
 1398 046a 10E0      		ldi r17,0
 1399               	.LVL109:
 1400               	.L48:
 312:main.c        **** 		switch_temp(up);
 1401               		.loc 1 312 0 is_stmt 0 discriminator 1
 1402 046c D117      		cp r29,r17
 1403 046e 01F0      		breq .L50
 313:main.c        **** 	    }
 1404               		.loc 1 313 0 is_stmt 1 discriminator 3
 1405 0470 802F      		mov r24,r16
 1406 0472 0E94 0000 		call switch_temp
 1407               	.LVL110:
 312:main.c        **** 		switch_temp(up);
 1408               		.loc 1 312 0 discriminator 3
 1409 0476 1F5F      		subi r17,lo8(-(1))
 1410               	.LVL111:
 1411 0478 00C0      		rjmp .L48
 1412               	.LVL112:
 1413               	.L35:
 1414               	/* epilogue start */
 1415               	.LBE96:
 1416               	.LBE95:
 1417               	.LBE97:
 317:main.c        ****     }
 318:main.c        **** }
 1418               		.loc 1 318 0
 1419 047a DF91      		pop r29
 1420 047c CF91      		pop r28
 1421 047e 1F91      		pop r17
 1422 0480 0F91      		pop r16
 1423 0482 0895      		ret
 1424               		.cfi_endproc
 1425               	.LFE28:
 1427               	.global	switch_cond
 1429               	switch_cond:
 1430               	.LFB29:
 319:main.c        **** 
 320:main.c        **** void switch_cond(char on)
 321:main.c        **** {
 1431               		.loc 1 321 0
 1432               		.cfi_startproc
 1433               	.LVL113:
 1434               	/* prologue: function */
 1435               	/* frame size = 0 */
 1436               	/* stack size = 0 */
 1437               	.L__stack_usage = 0
 322:main.c        ****     if (vars.cond_enabled) {
 1438               		.loc 1 322 0
 1439 0484 9091 0000 		lds r25,vars+9
 1440 0488 9923      		tst r25
 1441 048a 01F0      		breq .L55
 323:main.c        **** 	if (on && vent_seg_cur > 0) {
 1442               		.loc 1 323 0
 1443 048c 8823      		tst r24
 1444 048e 01F0      		breq .L56
 1445               		.loc 1 323 0 is_stmt 0 discriminator 1
 1446 0490 8091 0000 		lds r24,vent_seg_cur
 1447               	.LVL114:
 1448 0494 1816      		cp __zero_reg__,r24
 1449 0496 04F4      		brge .L56
 1450               	.LVL115:
 1451               	.LBB100:
 1452               	.LBB101:
 324:main.c        **** 	    CLR_FLAG(f_cond_ind_flash);
 1453               		.loc 1 324 0 is_stmt 1
 1454 0498 8091 0000 		lds r24,flags
 1455 049c 8F7D      		andi r24,lo8(-33)
 1456 049e 8093 0000 		sts flags,r24
 325:main.c        **** 	    pin_high(OUT_FROST_SW);
 1457               		.loc 1 325 0
 1458 04a2 459A      		sbi 0x8,5
 1459 04a4 0895      		ret
 1460               	.LVL116:
 1461               	.L56:
 1462               	.LBE101:
 1463               	.LBE100:
 326:main.c        **** 	} else {
 327:main.c        **** 	    SET_FLAG(f_cond_ind_flash);
 1464               		.loc 1 327 0
 1465 04a6 8091 0000 		lds r24,flags
 1466 04aa 8062      		ori r24,lo8(32)
 1467 04ac 00C0      		rjmp .L61
 1468               	.LVL117:
 1469               	.L55:
 328:main.c        **** 	    pin_low(OUT_FROST_SW);
 329:main.c        **** 	}
 330:main.c        ****     } else {
 331:main.c        **** 	CLR_FLAG(f_cond_ind_flash);
 1470               		.loc 1 331 0
 1471 04ae 8091 0000 		lds r24,flags
 1472               	.LVL118:
 1473 04b2 8F7D      		andi r24,lo8(-33)
 1474               	.L61:
 1475 04b4 8093 0000 		sts flags,r24
 332:main.c        **** 	pin_low(OUT_FROST_SW);
 1476               		.loc 1 332 0
 1477 04b8 4598      		cbi 0x8,5
 1478 04ba 0895      		ret
 1479               		.cfi_endproc
 1480               	.LFE29:
 1482               	.global	set_vent_seg
 1484               	set_vent_seg:
 1485               	.LFB30:
 333:main.c        ****     }
 334:main.c        **** }
 335:main.c        **** 
 336:main.c        **** void set_vent_seg(uint8_t seg_vent, int8_t full_sync)
 337:main.c        **** {
 1486               		.loc 1 337 0
 1487               		.cfi_startproc
 1488               	.LVL119:
 1489 04bc FF92      		push r15
 1490               	.LCFI73:
 1491               		.cfi_def_cfa_offset 3
 1492               		.cfi_offset 15, -2
 1493 04be 0F93      		push r16
 1494               	.LCFI74:
 1495               		.cfi_def_cfa_offset 4
 1496               		.cfi_offset 16, -3
 1497 04c0 1F93      		push r17
 1498               	.LCFI75:
 1499               		.cfi_def_cfa_offset 5
 1500               		.cfi_offset 17, -4
 1501 04c2 CF93      		push r28
 1502               	.LCFI76:
 1503               		.cfi_def_cfa_offset 6
 1504               		.cfi_offset 28, -5
 1505 04c4 DF93      		push r29
 1506               	.LCFI77:
 1507               		.cfi_def_cfa_offset 7
 1508               		.cfi_offset 29, -6
 1509               	/* prologue: function */
 1510               	/* frame size = 0 */
 1511               	/* stack size = 5 */
 1512               	.L__stack_usage = 5
 1513 04c6 062F      		mov r16,r22
 338:main.c        ****     seg_vent = check_range(0, seg_vent, VENT_SEG);
 1514               		.loc 1 338 0
 1515 04c8 682F      		mov r22,r24
 1516               	.LVL120:
 1517 04ca 70E0      		ldi r23,0
 1518 04cc 48E0      		ldi r20,lo8(8)
 1519 04ce 50E0      		ldi r21,0
 1520 04d0 80E0      		ldi r24,0
 1521 04d2 90E0      		ldi r25,0
 1522               	.LVL121:
 1523 04d4 0E94 0000 		call check_range
 1524               	.LVL122:
 1525 04d8 EC01      		movw r28,r24
 1526 04da 182F      		mov r17,r24
 1527               	.LVL123:
 339:main.c        **** 
 340:main.c        ****     if (seg_vent == 0) { //add sync
 1528               		.loc 1 340 0
 1529 04dc 8111      		cpse r24,__zero_reg__
 1530 04de 00C0      		rjmp .L63
 341:main.c        **** 	switch_vent(0);
 1531               		.loc 1 341 0
 1532 04e0 80E0      		ldi r24,0
 1533               	.LVL124:
 1534 04e2 0E94 0000 		call switch_vent
 1535               	.LVL125:
 342:main.c        **** 	switch_cond(0); // выключаем кондиционер
 1536               		.loc 1 342 0
 1537 04e6 80E0      		ldi r24,0
 1538 04e8 0E94 0000 		call switch_cond
 1539               	.LVL126:
 1540 04ec 00C0      		rjmp .L64
 1541               	.LVL127:
 1542               	.L63:
 343:main.c        ****     } else if (seg_vent == VENT_SEG) {
 1543               		.loc 1 343 0
 1544 04ee 8830      		cpi r24,lo8(8)
 1545 04f0 01F4      		brne .L64
 344:main.c        **** 	switch_vent(1);
 1546               		.loc 1 344 0
 1547 04f2 81E0      		ldi r24,lo8(1)
 1548               	.LVL128:
 1549 04f4 0E94 0000 		call switch_vent
 1550               	.LVL129:
 1551               	.L64:
 345:main.c        ****     }
 346:main.c        **** 
 347:main.c        ****     if (vent_seg_cur != seg_vent) {
 1552               		.loc 1 347 0
 1553 04f8 8091 0000 		lds r24,vent_seg_cur
 1554 04fc 9E01      		movw r18,r28
 1555 04fe 3327      		clr r19
 1556 0500 082E      		mov __tmp_reg__,r24
 1557 0502 000C      		lsl r0
 1558 0504 990B      		sbc r25,r25
 1559 0506 8217      		cp r24,r18
 1560 0508 9307      		cpc r25,r19
 1561 050a 01F0      		breq .L62
 1562               	.LVL130:
 1563               	.LBB102:
 348:main.c        **** 	uint8_t seg_v = seg_vent;
 349:main.c        **** 	if (full_sync) {
 1564               		.loc 1 349 0
 1565 050c 0023      		tst r16
 1566 050e 01F0      		breq .L66
 1567 0510 00E0      		ldi r16,0
 1568               	.LVL131:
 1569               	.L67:
 1570               	.LBB103:
 350:main.c        **** 	    for (uint8_t i = 0; i < vent_seg_cur + 2; i++) {
 1571               		.loc 1 350 0 discriminator 1
 1572 0512 8091 0000 		lds r24,vent_seg_cur
 1573 0516 082E      		mov __tmp_reg__,r24
 1574 0518 000C      		lsl r0
 1575 051a 990B      		sbc r25,r25
 1576 051c 0196      		adiw r24,1
 1577 051e 202F      		mov r18,r16
 1578 0520 30E0      		ldi r19,0
 1579 0522 8217      		cp r24,r18
 1580 0524 9307      		cpc r25,r19
 1581 0526 04F0      		brlt .L76
 351:main.c        **** 		switch_vent(0);
 1582               		.loc 1 351 0 discriminator 3
 1583 0528 80E0      		ldi r24,0
 1584 052a 0E94 0000 		call switch_vent
 1585               	.LVL132:
 350:main.c        **** 	    for (uint8_t i = 0; i < vent_seg_cur + 2; i++) {
 1586               		.loc 1 350 0 discriminator 3
 1587 052e 0F5F      		subi r16,lo8(-(1))
 1588               	.LVL133:
 1589 0530 00C0      		rjmp .L67
 1590               	.L76:
 1591               	.LBE103:
 352:main.c        **** 	    }
 353:main.c        **** 	    delay_ms(60);
 1592               		.loc 1 353 0
 1593 0532 8CE3      		ldi r24,lo8(60)
 1594 0534 90E0      		ldi r25,0
 1595 0536 0E94 0000 		call delay_ms
 1596               	.LVL134:
 1597               	.LBB104:
 354:main.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
 1598               		.loc 1 354 0
 1599 053a 00E0      		ldi r16,0
 1600               	.LVL135:
 1601               	.L69:
 1602               		.loc 1 354 0 is_stmt 0 discriminator 1
 1603 053c 0117      		cp r16,r17
 1604 053e 00F4      		brsh .L75
 355:main.c        **** 		switch_vent(1);
 1605               		.loc 1 355 0 is_stmt 1 discriminator 3
 1606 0540 81E0      		ldi r24,lo8(1)
 1607 0542 0E94 0000 		call switch_vent
 1608               	.LVL136:
 354:main.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
 1609               		.loc 1 354 0 discriminator 3
 1610 0546 0F5F      		subi r16,lo8(-(1))
 1611               	.LVL137:
 1612 0548 00C0      		rjmp .L69
 1613               	.LVL138:
 1614               	.L75:
 1615               	.LBE104:
 356:main.c        **** 	    }
 357:main.c        **** 	} else {
 358:main.c        **** 	    int8_t up = 0;
 359:main.c        **** 	    if (seg_vent > vent_seg_cur) {
 360:main.c        **** 		seg_vent = seg_vent - vent_seg_cur; // delta
 361:main.c        **** 		up = 1;
 362:main.c        **** 	    } else {
 363:main.c        **** 		seg_vent = vent_seg_cur - seg_vent; // delta
 364:main.c        **** 	    }
 365:main.c        **** 	    for (uint8_t i = 0; i < seg_vent; i++) {
 366:main.c        **** 		switch_vent(up);
 367:main.c        **** 	    }
 368:main.c        **** 	}
 369:main.c        **** 	vent_seg_cur = seg_v;
 1616               		.loc 1 369 0
 1617 054a C093 0000 		sts vent_seg_cur,r28
 1618 054e 00C0      		rjmp .L62
 1619               	.LVL139:
 1620               	.L66:
 1621               	.LBB105:
 359:main.c        **** 		seg_vent = seg_vent - vent_seg_cur; // delta
 1622               		.loc 1 359 0
 1623 0550 8091 0000 		lds r24,vent_seg_cur
 1624 0554 082E      		mov __tmp_reg__,r24
 1625 0556 000C      		lsl r0
 1626 0558 990B      		sbc r25,r25
 1627 055a 8217      		cp r24,r18
 1628 055c 9307      		cpc r25,r19
 1629 055e 04F4      		brge .L71
 360:main.c        **** 		up = 1;
 1630               		.loc 1 360 0
 1631 0560 8091 0000 		lds r24,vent_seg_cur
 1632 0564 1C2F      		mov r17,r28
 1633 0566 181B      		sub r17,r24
 1634               	.LVL140:
 361:main.c        **** 	    } else {
 1635               		.loc 1 361 0
 1636 0568 FF24      		clr r15
 1637 056a F394      		inc r15
 1638 056c 00C0      		rjmp .L72
 1639               	.LVL141:
 1640               	.L71:
 363:main.c        **** 	    }
 1641               		.loc 1 363 0
 1642 056e 1091 0000 		lds r17,vent_seg_cur
 1643 0572 1C1B      		sub r17,r28
 1644               	.LVL142:
 358:main.c        **** 	    if (seg_vent > vent_seg_cur) {
 1645               		.loc 1 358 0
 1646 0574 F12C      		mov r15,__zero_reg__
 1647               	.LVL143:
 1648               	.L72:
 1649               	.LBB106:
 365:main.c        **** 		switch_vent(up);
 1650               		.loc 1 365 0
 1651 0576 00E0      		ldi r16,0
 1652               	.LVL144:
 1653               	.L73:
 365:main.c        **** 		switch_vent(up);
 1654               		.loc 1 365 0 is_stmt 0 discriminator 1
 1655 0578 1017      		cp r17,r16
 1656 057a 01F0      		breq .L75
 366:main.c        **** 	    }
 1657               		.loc 1 366 0 is_stmt 1 discriminator 3
 1658 057c 8F2D      		mov r24,r15
 1659 057e 0E94 0000 		call switch_vent
 1660               	.LVL145:
 365:main.c        **** 		switch_vent(up);
 1661               		.loc 1 365 0 discriminator 3
 1662 0582 0F5F      		subi r16,lo8(-(1))
 1663               	.LVL146:
 1664 0584 00C0      		rjmp .L73
 1665               	.LVL147:
 1666               	.L62:
 1667               	/* epilogue start */
 1668               	.LBE106:
 1669               	.LBE105:
 1670               	.LBE102:
 370:main.c        ****     }
 371:main.c        **** }
 1671               		.loc 1 371 0
 1672 0586 DF91      		pop r29
 1673 0588 CF91      		pop r28
 1674 058a 1F91      		pop r17
 1675 058c 0F91      		pop r16
 1676 058e FF90      		pop r15
 1677 0590 0895      		ret
 1678               		.cfi_endproc
 1679               	.LFE30:
 1681               	.global	set_vent_prc
 1683               	set_vent_prc:
 1684               	.LFB31:
 372:main.c        **** 
 373:main.c        **** void set_vent_prc(uint8_t prc, int8_t full_sync)
 374:main.c        **** {
 1685               		.loc 1 374 0
 1686               		.cfi_startproc
 1687               	.LVL148:
 1688 0592 CF93      		push r28
 1689               	.LCFI78:
 1690               		.cfi_def_cfa_offset 3
 1691               		.cfi_offset 28, -2
 1692               	/* prologue: function */
 1693               	/* frame size = 0 */
 1694               	/* stack size = 1 */
 1695               	.L__stack_usage = 1
 1696 0594 C62F      		mov r28,r22
 375:main.c        ****     uint8_t seg_vent = prc2Seg(VENT_SEG, prc);
 1697               		.loc 1 375 0
 1698 0596 682F      		mov r22,r24
 1699               	.LVL149:
 1700 0598 88E0      		ldi r24,lo8(8)
 1701               	.LVL150:
 1702 059a 0E94 0000 		call prc2Seg
 1703               	.LVL151:
 376:main.c        ****     set_vent_seg(seg_vent, full_sync);
 1704               		.loc 1 376 0
 1705 059e 6C2F      		mov r22,r28
 1706               	/* epilogue start */
 377:main.c        **** }
 1707               		.loc 1 377 0
 1708 05a0 CF91      		pop r28
 1709               	.LVL152:
 376:main.c        ****     set_vent_seg(seg_vent, full_sync);
 1710               		.loc 1 376 0
 1711 05a2 0C94 0000 		jmp set_vent_seg
 1712               	.LVL153:
 1713               		.cfi_endproc
 1714               	.LFE31:
 1716               	.global	__addsf3
 1717               	.global	calcTemp
 1719               	calcTemp:
 1720               	.LFB32:
 378:main.c        **** 
 379:main.c        **** float calcTemp(adc_in_type input)
 380:main.c        **** {/*
 1721               		.loc 1 380 0
 1722               		.cfi_startproc
 1723               	.LVL154:
 1724               	/* prologue: function */
 1725               	/* frame size = 0 */
 1726               	/* stack size = 0 */
 1727               	.L__stack_usage = 0
 381:main.c        ****     ADC_Mux(input);
 382:main.c        ****     float resf = 0;
 383:main.c        ****     for (int i = 0; i < ADC_MCNT; i++) {
 384:main.c        **** 	ADC_Start();
 385:main.c        **** 	while (ADCIsRun())
 386:main.c        **** 	    ;
 387:main.c        **** 	resf += ADC_GetData();
 388:main.c        ****     }
 389:main.c        **** 
 390:main.c        ****     resf /= ADC_MCNT;
 391:main.c        **** 
 392:main.c        ****     resf = 3132.0 / resf - 1;
 393:main.c        ****     resf = 100.0 / resf;
 394:main.c        **** 
 395:main.c        ****     resf = (TR_NTC_KFC * TR_NTC_T0_GRAD_K) / (TR_NTC_KFC + (TR_NTC_T0_GRAD_K * log(resf / TR_NTC_T0
 396:main.c        **** 	    + 0.5;
 397:main.c        **** 
 398:main.c        ****     return resf;
 399:main.c        **** */
 400:main.c        **** 
 401:main.c        ****     if(input == IN_ADC_T_SALON){
 1728               		.loc 1 401 0
 1729 05a6 8730      		cpi r24,lo8(7)
 1730 05a8 01F4      		brne .L80
 1731               	.LVL155:
 1732               	.LBB109:
 1733               	.LBB110:
 402:main.c        **** 	return Ts+0.1;
 1734               		.loc 1 402 0
 1735 05aa 6091 0000 		lds r22,Ts
 1736 05ae 7091 0000 		lds r23,Ts+1
 1737 05b2 8091 0000 		lds r24,Ts+2
 1738 05b6 9091 0000 		lds r25,Ts+3
 1739 05ba 2DEC      		ldi r18,lo8(-51)
 1740 05bc 3CEC      		ldi r19,lo8(-52)
 1741 05be 4CEC      		ldi r20,lo8(-52)
 1742 05c0 5DE3      		ldi r21,lo8(61)
 1743 05c2 0E94 0000 		call __addsf3
 1744               	.LVL156:
 1745 05c6 0895      		ret
 1746               	.LVL157:
 1747               	.L80:
 1748               	.LBE110:
 1749               	.LBE109:
 403:main.c        ****     }
 404:main.c        ****     return -13;
 1750               		.loc 1 404 0
 1751 05c8 60E0      		ldi r22,0
 1752 05ca 70E0      		ldi r23,0
 1753 05cc 80E5      		ldi r24,lo8(80)
 1754 05ce 91EC      		ldi r25,lo8(-63)
 405:main.c        **** }
 1755               		.loc 1 405 0
 1756 05d0 0895      		ret
 1757               		.cfi_endproc
 1758               	.LFE32:
 1760               	.global	__floatsisf
 1761               	.global	__ltsf2
 1762               		.section	.rodata.str1.1
 1763               	.LC2:
 1764 0005 4D68 00   		.string	"Mh"
 1765               	.LC3:
 1766 0008 4D66 00   		.string	"Mf"
 1767               	.LC4:
 1768 000b 4D63 00   		.string	"Mc"
 1769               		.text
 1770               	.global	calcCond
 1772               	calcCond:
 1773               	.LFB33:
 406:main.c        **** 
 407:main.c        **** void calcCond(void)
 408:main.c        **** {
 1774               		.loc 1 408 0
 1775               		.cfi_startproc
 1776 05d2 CF92      		push r12
 1777               	.LCFI79:
 1778               		.cfi_def_cfa_offset 3
 1779               		.cfi_offset 12, -2
 1780 05d4 DF92      		push r13
 1781               	.LCFI80:
 1782               		.cfi_def_cfa_offset 4
 1783               		.cfi_offset 13, -3
 1784 05d6 EF92      		push r14
 1785               	.LCFI81:
 1786               		.cfi_def_cfa_offset 5
 1787               		.cfi_offset 14, -4
 1788 05d8 FF92      		push r15
 1789               	.LCFI82:
 1790               		.cfi_def_cfa_offset 6
 1791               		.cfi_offset 15, -5
 1792 05da CF93      		push r28
 1793               	.LCFI83:
 1794               		.cfi_def_cfa_offset 7
 1795               		.cfi_offset 28, -6
 1796               	/* prologue: function */
 1797               	/* frame size = 0 */
 1798               	/* stack size = 5 */
 1799               	.L__stack_usage = 5
 409:main.c        **** 
 410:main.c        ****     if (Ti > vars.setup_temp) {
 1800               		.loc 1 410 0
 1801 05dc 6091 0000 		lds r22,vars+1
 1802 05e0 C090 0000 		lds r12,Ti
 1803 05e4 D090 0000 		lds r13,Ti+1
 1804 05e8 E090 0000 		lds r14,Ti+2
 1805 05ec F090 0000 		lds r15,Ti+3
 1806 05f0 062E      		mov __tmp_reg__,r22
 1807 05f2 000C      		lsl r0
 1808 05f4 770B      		sbc r23,r23
 1809 05f6 880B      		sbc r24,r24
 1810 05f8 990B      		sbc r25,r25
 1811 05fa 0E94 0000 		call __floatsisf
 1812               	.LVL158:
 1813 05fe A701      		movw r20,r14
 1814 0600 9601      		movw r18,r12
 1815 0602 0E94 0000 		call __ltsf2
 1816               	.LVL159:
 1817 0606 87FF      		sbrs r24,7
 1818 0608 00C0      		rjmp .L106
 411:main.c        **** 	CLR_FLAG(f_mode_hot);
 1819               		.loc 1 411 0
 1820 060a 8091 0000 		lds r24,flags
 1821 060e 8D7F      		andi r24,lo8(-3)
 1822 0610 00C0      		rjmp .L107
 1823               	.L106:
 412:main.c        ****     } else if (temp_seg_cur > VENT_TO_HOT_SW_SEG) {
 1824               		.loc 1 412 0
 1825 0612 8091 0000 		lds r24,temp_seg_cur
 1826 0616 8430      		cpi r24,lo8(4)
 1827 0618 04F0      		brlt .L84
 413:main.c        **** 	SET_FLAG(f_mode_hot);
 1828               		.loc 1 413 0
 1829 061a 8091 0000 		lds r24,flags
 1830 061e 8260      		ori r24,lo8(2)
 1831               	.L107:
 1832 0620 8093 0000 		sts flags,r24
 1833               	.L84:
 414:main.c        ****     }
 415:main.c        **** 
 416:main.c        ****     if ( TST_FLAG(f_mode_frost_cicle_on) && Ti > (vars.setup_temp - COND_WORK_DELTA_T * 2)
 1834               		.loc 1 416 0
 1835 0624 8091 0000 		lds r24,flags
 1836 0628 82FF      		sbrs r24,2
 1837 062a 00C0      		rjmp .L85
 1838               		.loc 1 416 0 is_stmt 0 discriminator 1
 1839 062c 6091 0000 		lds r22,vars+1
 1840 0630 C090 0000 		lds r12,Ti
 1841 0634 D090 0000 		lds r13,Ti+1
 1842 0638 E090 0000 		lds r14,Ti+2
 1843 063c F090 0000 		lds r15,Ti+3
 1844 0640 062E      		mov __tmp_reg__,r22
 1845 0642 000C      		lsl r0
 1846 0644 770B      		sbc r23,r23
 1847 0646 6A50      		subi r22,10
 1848 0648 7109      		sbc r23,__zero_reg__
 1849 064a 072E      		mov __tmp_reg__,r23
 1850 064c 000C      		lsl r0
 1851 064e 880B      		sbc r24,r24
 1852 0650 990B      		sbc r25,r25
 1853 0652 0E94 0000 		call __floatsisf
 1854               	.LVL160:
 1855 0656 A701      		movw r20,r14
 1856 0658 9601      		movw r18,r12
 1857 065a 0E94 0000 		call __ltsf2
 1858               	.LVL161:
 1859 065e 87FF      		sbrs r24,7
 1860 0660 00C0      		rjmp .L85
 417:main.c        **** 	    && Ti > vars.const_cnd_frost_t) {
 1861               		.loc 1 417 0 is_stmt 1
 1862 0662 6091 0000 		lds r22,vars+8
 1863 0666 C090 0000 		lds r12,Ti
 1864 066a D090 0000 		lds r13,Ti+1
 1865 066e E090 0000 		lds r14,Ti+2
 1866 0672 F090 0000 		lds r15,Ti+3
 1867 0676 062E      		mov __tmp_reg__,r22
 1868 0678 000C      		lsl r0
 1869 067a 770B      		sbc r23,r23
 1870 067c 880B      		sbc r24,r24
 1871 067e 990B      		sbc r25,r25
 1872 0680 0E94 0000 		call __floatsisf
 1873               	.LVL162:
 1874 0684 A701      		movw r20,r14
 1875 0686 9601      		movw r18,r12
 1876 0688 0E94 0000 		call __ltsf2
 1877               	.LVL163:
 1878 068c 87FD      		sbrc r24,7
 1879 068e 00C0      		rjmp .L109
 1880               	.L85:
 418:main.c        **** 	SET_FLAG(f_mode_frost_cicle_on);
 419:main.c        ****     } else if (!TST_FLAG(f_mode_frost_cicle_on) && Ti > (vars.setup_temp - COND_WORK_DELTA_T)
 1881               		.loc 1 419 0
 1882 0690 8091 0000 		lds r24,flags
 1883 0694 82FD      		sbrc r24,2
 1884 0696 00C0      		rjmp .L89
 1885               		.loc 1 419 0 is_stmt 0 discriminator 1
 1886 0698 6091 0000 		lds r22,vars+1
 1887 069c C090 0000 		lds r12,Ti
 1888 06a0 D090 0000 		lds r13,Ti+1
 1889 06a4 E090 0000 		lds r14,Ti+2
 1890 06a8 F090 0000 		lds r15,Ti+3
 1891 06ac 062E      		mov __tmp_reg__,r22
 1892 06ae 000C      		lsl r0
 1893 06b0 770B      		sbc r23,r23
 1894 06b2 6550      		subi r22,5
 1895 06b4 7109      		sbc r23,__zero_reg__
 1896 06b6 072E      		mov __tmp_reg__,r23
 1897 06b8 000C      		lsl r0
 1898 06ba 880B      		sbc r24,r24
 1899 06bc 990B      		sbc r25,r25
 1900 06be 0E94 0000 		call __floatsisf
 1901               	.LVL164:
 1902 06c2 A701      		movw r20,r14
 1903 06c4 9601      		movw r18,r12
 1904 06c6 0E94 0000 		call __ltsf2
 1905               	.LVL165:
 1906 06ca 87FF      		sbrs r24,7
 1907 06cc 00C0      		rjmp .L89
 420:main.c        **** 	    && Ts > (vars.setup_temp - COND_OVERCOOL_DELTA_T)) {
 1908               		.loc 1 420 0 is_stmt 1
 1909 06ce 6091 0000 		lds r22,vars+1
 1910 06d2 C090 0000 		lds r12,Ts
 1911 06d6 D090 0000 		lds r13,Ts+1
 1912 06da E090 0000 		lds r14,Ts+2
 1913 06de F090 0000 		lds r15,Ts+3
 1914 06e2 062E      		mov __tmp_reg__,r22
 1915 06e4 000C      		lsl r0
 1916 06e6 770B      		sbc r23,r23
 1917 06e8 880B      		sbc r24,r24
 1918 06ea 990B      		sbc r25,r25
 1919 06ec 0E94 0000 		call __floatsisf
 1920               	.LVL166:
 1921 06f0 A701      		movw r20,r14
 1922 06f2 9601      		movw r18,r12
 1923 06f4 0E94 0000 		call __ltsf2
 1924               	.LVL167:
 1925 06f8 87FF      		sbrs r24,7
 1926 06fa 00C0      		rjmp .L89
 1927               	.L109:
 421:main.c        **** 	SET_FLAG(f_mode_frost_cicle_on);
 1928               		.loc 1 421 0
 1929 06fc 8091 0000 		lds r24,flags
 1930 0700 8460      		ori r24,lo8(4)
 1931 0702 00C0      		rjmp .L108
 1932               	.L89:
 422:main.c        ****     } else {
 423:main.c        **** 	CLR_FLAG(f_mode_frost_cicle_on);
 1933               		.loc 1 423 0
 1934 0704 8091 0000 		lds r24,flags
 1935 0708 8B7F      		andi r24,lo8(-5)
 1936               	.L108:
 1937 070a 8093 0000 		sts flags,r24
 1938               	.LVL168:
 424:main.c        ****     }
 425:main.c        **** 
 426:main.c        ****     char mode_cond_on = 0;
 427:main.c        ****     if ((!TST_FLAG(f_mode_hot) || get_output(OUT_FROST_SW)) && TST_FLAG(f_mode_frost_cicle_on)) {
 1939               		.loc 1 427 0
 1940 070e 8091 0000 		lds r24,flags
 1941 0712 81FF      		sbrs r24,1
 1942 0714 00C0      		rjmp .L92
 1943               		.loc 1 427 0 is_stmt 0 discriminator 2
 1944 0716 459B      		sbis 0x8,5
 1945 0718 00C0      		rjmp .L94
 1946               	.L92:
 1947               		.loc 1 427 0 discriminator 3
 1948 071a 6091 0000 		lds r22,flags
 426:main.c        ****     if ((!TST_FLAG(f_mode_hot) || get_output(OUT_FROST_SW)) && TST_FLAG(f_mode_frost_cicle_on)) {
 1949               		.loc 1 426 0 is_stmt 1 discriminator 3
 1950 071e 62FB      		bst r22,2
 1951 0720 CC27      		clr r28
 1952 0722 C0F9      		bld r28,0
 1953 0724 00C0      		rjmp .L93
 1954               	.L94:
 426:main.c        ****     if ((!TST_FLAG(f_mode_hot) || get_output(OUT_FROST_SW)) && TST_FLAG(f_mode_frost_cicle_on)) {
 1955               		.loc 1 426 0 is_stmt 0
 1956 0726 C0E0      		ldi r28,0
 1957               	.L93:
 1958               	.LVL169:
 428:main.c        **** 	mode_cond_on = 1;
 429:main.c        ****     }
 430:main.c        **** 
 431:main.c        ****     switch_cond(mode_cond_on);
 1959               		.loc 1 431 0 is_stmt 1
 1960 0728 8C2F      		mov r24,r28
 1961 072a 0E94 0000 		call switch_cond
 1962               	.LVL170:
 432:main.c        **** 
 433:main.c        ****     int_to_uart("Mh", TST_FLAG(f_mode_hot));
 1963               		.loc 1 433 0
 1964 072e 6091 0000 		lds r22,flags
 1965 0732 6270      		andi r22,lo8(2)
 1966 0734 70E0      		ldi r23,0
 1967 0736 80E0      		ldi r24,lo8(.LC2)
 1968 0738 90E0      		ldi r25,hi8(.LC2)
 1969 073a 0E94 0000 		call int_to_uart
 1970               	.LVL171:
 434:main.c        ****     int_to_uart("Mf", TST_FLAG(f_mode_frost_cicle_on));
 1971               		.loc 1 434 0
 1972 073e 6091 0000 		lds r22,flags
 1973 0742 6470      		andi r22,lo8(4)
 1974 0744 70E0      		ldi r23,0
 1975 0746 80E0      		ldi r24,lo8(.LC3)
 1976 0748 90E0      		ldi r25,hi8(.LC3)
 1977 074a 0E94 0000 		call int_to_uart
 1978               	.LVL172:
 435:main.c        ****     int_to_uart("Mc", mode_cond_on);
 1979               		.loc 1 435 0
 1980 074e 6C2F      		mov r22,r28
 1981 0750 70E0      		ldi r23,0
 1982 0752 80E0      		ldi r24,lo8(.LC4)
 1983 0754 90E0      		ldi r25,hi8(.LC4)
 1984               	/* epilogue start */
 436:main.c        **** }
 1985               		.loc 1 436 0
 1986 0756 CF91      		pop r28
 1987               	.LVL173:
 1988 0758 FF90      		pop r15
 1989 075a EF90      		pop r14
 1990 075c DF90      		pop r13
 1991 075e CF90      		pop r12
 435:main.c        ****     int_to_uart("Mc", mode_cond_on);
 1992               		.loc 1 435 0
 1993 0760 0C94 0000 		jmp int_to_uart
 1994               	.LVL174:
 1995               		.cfi_endproc
 1996               	.LFE33:
 1998               	.global	__floatunsisf
 1999               	.global	__mulsf3
 2000               		.section	.rodata.str1.1
 2001               	.LC5:
 2002 000e 5670 00   		.string	"Vp"
 2003               	.LC6:
 2004 0011 566E 00   		.string	"Vn"
 2005               	.LC7:
 2006 0014 5661 00   		.string	"Va"
 2007               		.text
 2008               	.global	calcVent
 2010               	calcVent:
 2011               	.LFB34:
 437:main.c        **** 
 438:main.c        **** void calcVent(float id)
 439:main.c        **** {
 2012               		.loc 1 439 0
 2013               		.cfi_startproc
 2014               	.LVL175:
 2015 0764 4F92      		push r4
 2016               	.LCFI84:
 2017               		.cfi_def_cfa_offset 3
 2018               		.cfi_offset 4, -2
 2019 0766 5F92      		push r5
 2020               	.LCFI85:
 2021               		.cfi_def_cfa_offset 4
 2022               		.cfi_offset 5, -3
 2023 0768 6F92      		push r6
 2024               	.LCFI86:
 2025               		.cfi_def_cfa_offset 5
 2026               		.cfi_offset 6, -4
 2027 076a 7F92      		push r7
 2028               	.LCFI87:
 2029               		.cfi_def_cfa_offset 6
 2030               		.cfi_offset 7, -5
 2031 076c 8F92      		push r8
 2032               	.LCFI88:
 2033               		.cfi_def_cfa_offset 7
 2034               		.cfi_offset 8, -6
 2035 076e 9F92      		push r9
 2036               	.LCFI89:
 2037               		.cfi_def_cfa_offset 8
 2038               		.cfi_offset 9, -7
 2039 0770 AF92      		push r10
 2040               	.LCFI90:
 2041               		.cfi_def_cfa_offset 9
 2042               		.cfi_offset 10, -8
 2043 0772 BF92      		push r11
 2044               	.LCFI91:
 2045               		.cfi_def_cfa_offset 10
 2046               		.cfi_offset 11, -9
 2047 0774 CF92      		push r12
 2048               	.LCFI92:
 2049               		.cfi_def_cfa_offset 11
 2050               		.cfi_offset 12, -10
 2051 0776 DF92      		push r13
 2052               	.LCFI93:
 2053               		.cfi_def_cfa_offset 12
 2054               		.cfi_offset 13, -11
 2055 0778 EF92      		push r14
 2056               	.LCFI94:
 2057               		.cfi_def_cfa_offset 13
 2058               		.cfi_offset 14, -12
 2059 077a FF92      		push r15
 2060               	.LCFI95:
 2061               		.cfi_def_cfa_offset 14
 2062               		.cfi_offset 15, -13
 2063 077c 0F93      		push r16
 2064               	.LCFI96:
 2065               		.cfi_def_cfa_offset 15
 2066               		.cfi_offset 16, -14
 2067 077e 1F93      		push r17
 2068               	.LCFI97:
 2069               		.cfi_def_cfa_offset 16
 2070               		.cfi_offset 17, -15
 2071 0780 CF93      		push r28
 2072               	.LCFI98:
 2073               		.cfi_def_cfa_offset 17
 2074               		.cfi_offset 28, -16
 2075               	/* prologue: function */
 2076               	/* frame size = 0 */
 2077               	/* stack size = 15 */
 2078               	.L__stack_usage = 15
 2079 0782 6B01      		movw r12,r22
 2080 0784 7C01      		movw r14,r24
 440:main.c        ****     float vent_nom_prc = seg2Prc(VENT_SEG, vars.vent_nom_seg);
 2081               		.loc 1 440 0
 2082 0786 6091 0000 		lds r22,vars+2
 2083               	.LVL176:
 2084 078a 84E6      		ldi r24,lo8(100)
 2085 078c 689F      		mul r22,r24
 2086 078e B001      		movw r22,r0
 2087 0790 1124      		clr __zero_reg__
 2088               	.LVL177:
 2089 0792 93E0      		ldi r25,3
 2090               		1:
 2091 0794 7595      		asr r23
 2092 0796 6795      		ror r22
 2093 0798 9A95      		dec r25
 2094 079a 01F4      		brne 1b
 2095 079c 70E0      		ldi r23,0
 2096 079e 80E0      		ldi r24,0
 2097 07a0 90E0      		ldi r25,0
 2098 07a2 0E94 0000 		call __floatunsisf
 2099               	.LVL178:
 2100 07a6 2B01      		movw r4,r22
 2101 07a8 3C01      		movw r6,r24
 2102               	.LVL179:
 441:main.c        ****     //delta = (delta / (float) vars.setup_temp) * (float) VENT_ADD_CTRL_CFC;
 442:main.c        ****     /*
 443:main.c        ****      float kfc = vent_nom_prc;
 444:main.c        ****      kfc = kfc / (float) vars.vent_var_kfc;
 445:main.c        ****      float vc = fabs((delta / (float) vars.setup_temp) * kfc);
 446:main.c        **** 
 447:main.c        ****      int_to_uart("Vp", vent_nom_prc);
 448:main.c        ****      int_to_uart("Vn", vars.vent_nom_seg);
 449:main.c        ****      float_to_uart("v0", vc);
 450:main.c        **** 
 451:main.c        ****      if ((delta > 0.0 && id > 0.0) || (delta < 0.0 && id < 0.0)) {
 452:main.c        ****      vc = vc * kfc / (-15.0);
 453:main.c        ****      }
 454:main.c        ****      float_to_uart("v1", vc);
 455:main.c        **** 
 456:main.c        ****      // if (TST_FLAG(f_mode_hot)) {
 457:main.c        ****      vc = (float) vent_nom_prc + vc;
 458:main.c        ****      //} else {
 459:main.c        ****      //delta = (float) vent_nom_prc - last_delta;
 460:main.c        ****      //}
 461:main.c        ****      float_to_uart("v2", vc);
 462:main.c        **** 
 463:main.c        ****      vc = check_rangef(0, vc, 100);
 464:main.c        ****      float_to_uart("v3", vc);
 465:main.c        **** 
 466:main.c        ****      kfc = vent_add_prc;
 467:main.c        ****      //vc = (vc + kfc * 3.0) / 4.0;
 468:main.c        ****      float_to_uart("v4", vc);
 469:main.c        **** 
 470:main.c        ****      if (fabs(kfc - vc) > 5) { // >5%
 471:main.c        ****      if (kfc > vc) { //old > new
 472:main.c        ****      vent_add_prc = vent_add_prc - 5; // max step 5%
 473:main.c        ****      } else {
 474:main.c        ****      vent_add_prc = vent_add_prc + 5;
 475:main.c        ****      }
 476:main.c        ****      } else {
 477:main.c        ****      vent_add_prc = vc;
 478:main.c        ****      }
 479:main.c        **** 
 480:main.c        ****      if (vent_add_prc < 15) { // min 1 seg
 481:main.c        ****      vent_add_prc = 15;
 482:main.c        ****      }
 483:main.c        ****      */
 484:main.c        **** 
 485:main.c        ****     float p = last_delta * (float) vars.vent_var_kfc * (float) vars.pid_P_kfc;
 2103               		.loc 1 485 0
 2104 07aa 6091 0000 		lds r22,vars+6
 2105 07ae 8090 0000 		lds r8,last_delta
 2106 07b2 9090 0000 		lds r9,last_delta+1
 2107 07b6 A090 0000 		lds r10,last_delta+2
 2108 07ba B090 0000 		lds r11,last_delta+3
 2109 07be C091 0000 		lds r28,vars+4
 2110 07c2 062E      		mov __tmp_reg__,r22
 2111 07c4 000C      		lsl r0
 2112 07c6 770B      		sbc r23,r23
 2113 07c8 880B      		sbc r24,r24
 2114 07ca 990B      		sbc r25,r25
 2115 07cc 0E94 0000 		call __floatsisf
 2116               	.LVL180:
 2117 07d0 A501      		movw r20,r10
 2118 07d2 9401      		movw r18,r8
 2119 07d4 0E94 0000 		call __mulsf3
 2120               	.LVL181:
 2121 07d8 4B01      		movw r8,r22
 2122 07da 5C01      		movw r10,r24
 2123 07dc 6C2F      		mov r22,r28
 2124 07de CC0F      		lsl r28
 2125 07e0 770B      		sbc r23,r23
 2126 07e2 880B      		sbc r24,r24
 2127 07e4 990B      		sbc r25,r25
 2128 07e6 0E94 0000 		call __floatsisf
 2129               	.LVL182:
 2130 07ea 9B01      		movw r18,r22
 2131 07ec AC01      		movw r20,r24
 2132 07ee C501      		movw r24,r10
 2133 07f0 B401      		movw r22,r8
 2134 07f2 0E94 0000 		call __mulsf3
 2135               	.LVL183:
 2136 07f6 4B01      		movw r8,r22
 2137 07f8 5C01      		movw r10,r24
 2138               	.LVL184:
 2139               	.LBB111:
 2140               	.LBB112:
  43:main.c        ****     /*    USART_SendStr(id);
 2141               		.loc 1 43 0
 2142 07fa 0E94 0000 		call __fixsfsi
 2143               	.LVL185:
 2144 07fe 80E0      		ldi r24,lo8(.LC5)
 2145 0800 90E0      		ldi r25,hi8(.LC5)
 2146 0802 0E94 0000 		call int_to_uart
 2147               	.LVL186:
 2148               	.LBE112:
 2149               	.LBE111:
 486:main.c        ****     float_to_uart("Vp", p);
 487:main.c        **** 
 488:main.c        ****     if (id < 0.0) {
 2150               		.loc 1 488 0
 2151 0806 20E0      		ldi r18,0
 2152 0808 30E0      		ldi r19,0
 2153 080a A901      		movw r20,r18
 2154 080c C701      		movw r24,r14
 2155 080e B601      		movw r22,r12
 2156 0810 0E94 0000 		call __ltsf2
 2157               	.LVL187:
 2158 0814 87FF      		sbrs r24,7
 2159 0816 00C0      		rjmp .L111
 489:main.c        **** 	p = -p;
 2160               		.loc 1 489 0
 2161 0818 B7FA      		bst r11,7
 2162 081a B094      		com r11
 2163 081c B7F8      		bld r11,7
 2164 081e B094      		com r11
 2165               	.LVL188:
 2166               	.L111:
 490:main.c        ****     }
 491:main.c        **** 
 492:main.c        ****     float rng = vent_nom_prc / 2;
 2167               		.loc 1 492 0
 2168 0820 20E0      		ldi r18,0
 2169 0822 30E0      		ldi r19,0
 2170 0824 40E0      		ldi r20,0
 2171 0826 5FE3      		ldi r21,lo8(63)
 2172 0828 C301      		movw r24,r6
 2173 082a B201      		movw r22,r4
 2174 082c 0E94 0000 		call __mulsf3
 2175               	.LVL189:
 2176 0830 7B01      		movw r14,r22
 2177 0832 8C01      		movw r16,r24
 2178               	.LVL190:
 493:main.c        ****     p = check_rangef(-rng, p, rng);
 2179               		.loc 1 493 0
 2180 0834 9058      		subi r25,0x80
 2181 0836 A501      		movw r20,r10
 2182 0838 9401      		movw r18,r8
 2183 083a 0E94 0000 		call check_rangef
 2184               	.LVL191:
 2185 083e 6B01      		movw r12,r22
 2186 0840 7C01      		movw r14,r24
 2187               	.LVL192:
 2188               	.LBB113:
 2189               	.LBB114:
  43:main.c        ****     /*    USART_SendStr(id);
 2190               		.loc 1 43 0
 2191 0842 0E94 0000 		call __fixsfsi
 2192               	.LVL193:
 2193 0846 80E0      		ldi r24,lo8(.LC6)
 2194 0848 90E0      		ldi r25,hi8(.LC6)
 2195 084a 0E94 0000 		call int_to_uart
 2196               	.LVL194:
 2197               	.LBE114:
 2198               	.LBE113:
 494:main.c        ****     float_to_uart("Vn", p);
 495:main.c        **** 
 496:main.c        ****     vent_add_prc = check_rangef(0, p + vent_nom_prc, 100);
 2199               		.loc 1 496 0
 2200 084e A701      		movw r20,r14
 2201 0850 9601      		movw r18,r12
 2202 0852 C301      		movw r24,r6
 2203 0854 B201      		movw r22,r4
 2204 0856 0E94 0000 		call __addsf3
 2205               	.LVL195:
 2206 085a 9B01      		movw r18,r22
 2207 085c AC01      		movw r20,r24
 2208 085e E12C      		mov r14,__zero_reg__
 2209 0860 F12C      		mov r15,__zero_reg__
 2210 0862 08EC      		ldi r16,lo8(-56)
 2211 0864 12E4      		ldi r17,lo8(66)
 2212               	.LVL196:
 2213 0866 60E0      		ldi r22,0
 2214 0868 70E0      		ldi r23,0
 2215 086a CB01      		movw r24,r22
 2216 086c 0E94 0000 		call check_rangef
 2217               	.LVL197:
 2218 0870 0E94 0000 		call __fixsfsi
 2219               	.LVL198:
 2220 0874 6093 0000 		sts vent_add_prc,r22
 497:main.c        ****     int_to_uart("Va", vent_add_prc);
 2221               		.loc 1 497 0
 2222 0878 6091 0000 		lds r22,vent_add_prc
 2223 087c 062E      		mov __tmp_reg__,r22
 2224 087e 000C      		lsl r0
 2225 0880 770B      		sbc r23,r23
 2226 0882 80E0      		ldi r24,lo8(.LC7)
 2227 0884 90E0      		ldi r25,hi8(.LC7)
 2228               	/* epilogue start */
 498:main.c        **** }
 2229               		.loc 1 498 0
 2230 0886 CF91      		pop r28
 2231 0888 1F91      		pop r17
 2232 088a 0F91      		pop r16
 2233 088c FF90      		pop r15
 2234 088e EF90      		pop r14
 2235 0890 DF90      		pop r13
 2236 0892 CF90      		pop r12
 2237               	.LVL199:
 2238 0894 BF90      		pop r11
 2239 0896 AF90      		pop r10
 2240 0898 9F90      		pop r9
 2241 089a 8F90      		pop r8
 2242 089c 7F90      		pop r7
 2243 089e 6F90      		pop r6
 2244 08a0 5F90      		pop r5
 2245 08a2 4F90      		pop r4
 2246               	.LVL200:
 497:main.c        ****     int_to_uart("Va", vent_add_prc);
 2247               		.loc 1 497 0
 2248 08a4 0C94 0000 		jmp int_to_uart
 2249               	.LVL201:
 2250               		.cfi_endproc
 2251               	.LFE34:
 2253               		.section	.rodata.str1.1
 2254               	.LC8:
 2255 0017 5469 00   		.string	"Ti"
 2256               	.LC9:
 2257 001a 5473 00   		.string	"Ts"
 2258               	.LC10:
 2259 001d 5374 00   		.string	"St"
 2260               	.LC11:
 2261 0020 6C44 00   		.string	"lD"
 2262               	.global	__subsf3
 2263               	.LC12:
 2264 0023 4474 00   		.string	"Dt"
 2265               	.LC13:
 2266 0026 4964 00   		.string	"Id"
 2267               	.global	__divsf3
 2268               	.global	__gtsf2
 2269               	.LC14:
 2270 0029 4970 00   		.string	"Ip"
 2271               	.LC15:
 2272 002c 7069 6400 		.string	"pid"
 2273               	.global	__fixunssfsi
 2274               	.LC16:
 2275 0030 6F75 7400 		.string	"out"
 2276               		.text
 2277               	.global	calcVal
 2279               	calcVal:
 2280               	.LFB35:
 499:main.c        **** 
 500:main.c        **** void calcVal(void)
 501:main.c        **** {
 2281               		.loc 1 501 0
 2282               		.cfi_startproc
 2283 08a8 4F92      		push r4
 2284               	.LCFI99:
 2285               		.cfi_def_cfa_offset 3
 2286               		.cfi_offset 4, -2
 2287 08aa 5F92      		push r5
 2288               	.LCFI100:
 2289               		.cfi_def_cfa_offset 4
 2290               		.cfi_offset 5, -3
 2291 08ac 6F92      		push r6
 2292               	.LCFI101:
 2293               		.cfi_def_cfa_offset 5
 2294               		.cfi_offset 6, -4
 2295 08ae 7F92      		push r7
 2296               	.LCFI102:
 2297               		.cfi_def_cfa_offset 6
 2298               		.cfi_offset 7, -5
 2299 08b0 8F92      		push r8
 2300               	.LCFI103:
 2301               		.cfi_def_cfa_offset 7
 2302               		.cfi_offset 8, -6
 2303 08b2 9F92      		push r9
 2304               	.LCFI104:
 2305               		.cfi_def_cfa_offset 8
 2306               		.cfi_offset 9, -7
 2307 08b4 AF92      		push r10
 2308               	.LCFI105:
 2309               		.cfi_def_cfa_offset 9
 2310               		.cfi_offset 10, -8
 2311 08b6 BF92      		push r11
 2312               	.LCFI106:
 2313               		.cfi_def_cfa_offset 10
 2314               		.cfi_offset 11, -9
 2315 08b8 CF92      		push r12
 2316               	.LCFI107:
 2317               		.cfi_def_cfa_offset 11
 2318               		.cfi_offset 12, -10
 2319 08ba DF92      		push r13
 2320               	.LCFI108:
 2321               		.cfi_def_cfa_offset 12
 2322               		.cfi_offset 13, -11
 2323 08bc EF92      		push r14
 2324               	.LCFI109:
 2325               		.cfi_def_cfa_offset 13
 2326               		.cfi_offset 14, -12
 2327 08be FF92      		push r15
 2328               	.LCFI110:
 2329               		.cfi_def_cfa_offset 14
 2330               		.cfi_offset 15, -13
 2331 08c0 0F93      		push r16
 2332               	.LCFI111:
 2333               		.cfi_def_cfa_offset 15
 2334               		.cfi_offset 16, -14
 2335 08c2 1F93      		push r17
 2336               	.LCFI112:
 2337               		.cfi_def_cfa_offset 16
 2338               		.cfi_offset 17, -15
 2339 08c4 CF93      		push r28
 2340               	.LCFI113:
 2341               		.cfi_def_cfa_offset 17
 2342               		.cfi_offset 28, -16
 2343               	/* prologue: function */
 2344               	/* frame size = 0 */
 2345               	/* stack size = 15 */
 2346               	.L__stack_usage = 15
 502:main.c        ****     calcCond();
 2347               		.loc 1 502 0
 2348 08c6 0E94 0000 		call calcCond
 2349               	.LVL202:
 503:main.c        **** 
 504:main.c        ****     int_to_uart("Ti", Ti);
 2350               		.loc 1 504 0
 2351 08ca 6091 0000 		lds r22,Ti
 2352 08ce 7091 0000 		lds r23,Ti+1
 2353 08d2 8091 0000 		lds r24,Ti+2
 2354 08d6 9091 0000 		lds r25,Ti+3
 2355 08da 0E94 0000 		call __fixsfsi
 2356               	.LVL203:
 2357 08de 80E0      		ldi r24,lo8(.LC8)
 2358 08e0 90E0      		ldi r25,hi8(.LC8)
 2359 08e2 0E94 0000 		call int_to_uart
 2360               	.LVL204:
 505:main.c        ****     int_to_uart("Ts", Ts);
 2361               		.loc 1 505 0
 2362 08e6 6091 0000 		lds r22,Ts
 2363 08ea 7091 0000 		lds r23,Ts+1
 2364 08ee 8091 0000 		lds r24,Ts+2
 2365 08f2 9091 0000 		lds r25,Ts+3
 2366 08f6 0E94 0000 		call __fixsfsi
 2367               	.LVL205:
 2368 08fa 80E0      		ldi r24,lo8(.LC9)
 2369 08fc 90E0      		ldi r25,hi8(.LC9)
 2370 08fe 0E94 0000 		call int_to_uart
 2371               	.LVL206:
 506:main.c        ****     int_to_uart("St", vars.setup_temp);
 2372               		.loc 1 506 0
 2373 0902 6091 0000 		lds r22,vars+1
 2374 0906 062E      		mov __tmp_reg__,r22
 2375 0908 000C      		lsl r0
 2376 090a 770B      		sbc r23,r23
 2377 090c 80E0      		ldi r24,lo8(.LC10)
 2378 090e 90E0      		ldi r25,hi8(.LC10)
 2379 0910 0E94 0000 		call int_to_uart
 2380               	.LVL207:
 507:main.c        ****     float_to_uart("lD", last_delta);
 2381               		.loc 1 507 0
 2382 0914 6091 0000 		lds r22,last_delta
 2383 0918 7091 0000 		lds r23,last_delta+1
 2384 091c 8091 0000 		lds r24,last_delta+2
 2385 0920 9091 0000 		lds r25,last_delta+3
 2386               	.LVL208:
 2387               	.LBB115:
 2388               	.LBB116:
  43:main.c        ****     /*    USART_SendStr(id);
 2389               		.loc 1 43 0
 2390 0924 0E94 0000 		call __fixsfsi
 2391               	.LVL209:
 2392 0928 80E0      		ldi r24,lo8(.LC11)
 2393 092a 90E0      		ldi r25,hi8(.LC11)
 2394 092c 0E94 0000 		call int_to_uart
 2395               	.LVL210:
 2396               	.LBE116:
 2397               	.LBE115:
 508:main.c        ****     float delta = (float) vars.setup_temp;
 2398               		.loc 1 508 0
 2399 0930 6091 0000 		lds r22,vars+1
 2400               	.LVL211:
 509:main.c        ****     delta = check_rangef(-40.0, delta - Ts, 40.0);
 2401               		.loc 1 509 0
 2402 0934 C090 0000 		lds r12,Ts
 2403 0938 D090 0000 		lds r13,Ts+1
 2404 093c E090 0000 		lds r14,Ts+2
 2405 0940 F090 0000 		lds r15,Ts+3
 2406 0944 062E      		mov __tmp_reg__,r22
 2407 0946 000C      		lsl r0
 2408 0948 770B      		sbc r23,r23
 2409 094a 880B      		sbc r24,r24
 2410 094c 990B      		sbc r25,r25
 2411 094e 0E94 0000 		call __floatsisf
 2412               	.LVL212:
 2413 0952 A701      		movw r20,r14
 2414 0954 9601      		movw r18,r12
 2415 0956 0E94 0000 		call __subsf3
 2416               	.LVL213:
 2417 095a 9B01      		movw r18,r22
 2418 095c AC01      		movw r20,r24
 2419 095e E12C      		mov r14,__zero_reg__
 2420 0960 F12C      		mov r15,__zero_reg__
 2421 0962 00E2      		ldi r16,lo8(32)
 2422 0964 12E4      		ldi r17,lo8(66)
 2423 0966 60E0      		ldi r22,0
 2424 0968 70E0      		ldi r23,0
 2425 096a 80E2      		ldi r24,lo8(32)
 2426 096c 92EC      		ldi r25,lo8(-62)
 2427 096e 0E94 0000 		call check_rangef
 2428               	.LVL214:
 2429 0972 6B01      		movw r12,r22
 2430 0974 7C01      		movw r14,r24
 2431               	.LVL215:
 510:main.c        ****     if (fabs(delta) < 0.2) {
 2432               		.loc 1 510 0
 2433 0976 9F77      		andi r25,0x7f
 2434 0978 2DEC      		ldi r18,lo8(-51)
 2435 097a 3CEC      		ldi r19,lo8(-52)
 2436 097c 4CE4      		ldi r20,lo8(76)
 2437 097e 5EE3      		ldi r21,lo8(62)
 2438 0980 0E94 0000 		call __ltsf2
 2439               	.LVL216:
 2440 0984 87FF      		sbrs r24,7
 2441 0986 00C0      		rjmp .L115
 511:main.c        **** 	delta = 0.0;
 2442               		.loc 1 511 0
 2443 0988 C12C      		mov r12,__zero_reg__
 2444 098a D12C      		mov r13,__zero_reg__
 2445 098c 7601      		movw r14,r12
 2446               	.LVL217:
 2447               	.L115:
 2448               	.LBB117:
 2449               	.LBB118:
  43:main.c        ****     /*    USART_SendStr(id);
 2450               		.loc 1 43 0
 2451 098e C701      		movw r24,r14
 2452 0990 B601      		movw r22,r12
 2453 0992 0E94 0000 		call __fixsfsi
 2454               	.LVL218:
 2455 0996 80E0      		ldi r24,lo8(.LC12)
 2456 0998 90E0      		ldi r25,hi8(.LC12)
 2457 099a 0E94 0000 		call int_to_uart
 2458               	.LVL219:
 2459               	.LBE118:
 2460               	.LBE117:
 512:main.c        ****     }
 513:main.c        ****     float_to_uart("Dt", delta);
 514:main.c        ****     float id = delta - last_delta;
 2461               		.loc 1 514 0
 2462 099e 2091 0000 		lds r18,last_delta
 2463 09a2 3091 0000 		lds r19,last_delta+1
 2464 09a6 4091 0000 		lds r20,last_delta+2
 2465 09aa 5091 0000 		lds r21,last_delta+3
 2466 09ae C701      		movw r24,r14
 2467 09b0 B601      		movw r22,r12
 2468 09b2 0E94 0000 		call __subsf3
 2469               	.LVL220:
 2470 09b6 2B01      		movw r4,r22
 2471 09b8 3C01      		movw r6,r24
 2472               	.LVL221:
 515:main.c        ****     last_delta = delta;
 2473               		.loc 1 515 0
 2474 09ba C092 0000 		sts last_delta,r12
 2475 09be D092 0000 		sts last_delta+1,r13
 2476 09c2 E092 0000 		sts last_delta+2,r14
 2477 09c6 F092 0000 		sts last_delta+3,r15
 2478               	.LVL222:
 2479               	.LBB119:
 2480               	.LBB120:
  43:main.c        ****     /*    USART_SendStr(id);
 2481               		.loc 1 43 0
 2482 09ca 0E94 0000 		call __fixsfsi
 2483               	.LVL223:
 2484 09ce 80E0      		ldi r24,lo8(.LC13)
 2485 09d0 90E0      		ldi r25,hi8(.LC13)
 2486 09d2 0E94 0000 		call int_to_uart
 2487               	.LVL224:
 2488               	.LBE120:
 2489               	.LBE119:
 516:main.c        ****     float_to_uart("Id", id);
 517:main.c        **** 
 518:main.c        ****     float pid = (delta + (Ipid * (float) vars.pid_I_kfc) / 100.0 + (id * (float) PID_D_KFC) / 100.0
 2490               		.loc 1 518 0
 2491 09d6 6091 0000 		lds r22,vars+5
 2492 09da 8090 0000 		lds r8,Ipid
 2493 09de 9090 0000 		lds r9,Ipid+1
 2494 09e2 A090 0000 		lds r10,Ipid+2
 2495 09e6 B090 0000 		lds r11,Ipid+3
 519:main.c        **** 	    * (float) vars.pid_P_kfc;
 2496               		.loc 1 519 0
 2497 09ea C091 0000 		lds r28,vars+4
 518:main.c        **** 	    * (float) vars.pid_P_kfc;
 2498               		.loc 1 518 0
 2499 09ee 062E      		mov __tmp_reg__,r22
 2500 09f0 000C      		lsl r0
 2501 09f2 770B      		sbc r23,r23
 2502 09f4 880B      		sbc r24,r24
 2503 09f6 990B      		sbc r25,r25
 2504 09f8 0E94 0000 		call __floatsisf
 2505               	.LVL225:
 2506 09fc A501      		movw r20,r10
 2507 09fe 9401      		movw r18,r8
 2508 0a00 0E94 0000 		call __mulsf3
 2509               	.LVL226:
 2510 0a04 20E0      		ldi r18,0
 2511 0a06 30E0      		ldi r19,0
 2512 0a08 48EC      		ldi r20,lo8(-56)
 2513 0a0a 52E4      		ldi r21,lo8(66)
 2514 0a0c 0E94 0000 		call __divsf3
 2515               	.LVL227:
 2516 0a10 A701      		movw r20,r14
 2517 0a12 9601      		movw r18,r12
 2518 0a14 0E94 0000 		call __addsf3
 2519               	.LVL228:
 2520 0a18 4B01      		movw r8,r22
 2521 0a1a 5C01      		movw r10,r24
 2522 0a1c 20E0      		ldi r18,0
 2523 0a1e 30E0      		ldi r19,0
 2524 0a20 40E2      		ldi r20,lo8(32)
 2525 0a22 51E4      		ldi r21,lo8(65)
 2526 0a24 C301      		movw r24,r6
 2527 0a26 B201      		movw r22,r4
 2528 0a28 0E94 0000 		call __mulsf3
 2529               	.LVL229:
 2530 0a2c 20E0      		ldi r18,0
 2531 0a2e 30E0      		ldi r19,0
 2532 0a30 48EC      		ldi r20,lo8(-56)
 2533 0a32 52E4      		ldi r21,lo8(66)
 2534 0a34 0E94 0000 		call __divsf3
 2535               	.LVL230:
 2536 0a38 9B01      		movw r18,r22
 2537 0a3a AC01      		movw r20,r24
 2538 0a3c C501      		movw r24,r10
 2539 0a3e B401      		movw r22,r8
 2540 0a40 0E94 0000 		call __addsf3
 2541               	.LVL231:
 2542 0a44 2B01      		movw r4,r22
 2543 0a46 3C01      		movw r6,r24
 2544               	.LVL232:
 2545 0a48 6C2F      		mov r22,r28
 2546 0a4a CC0F      		lsl r28
 2547 0a4c 770B      		sbc r23,r23
 2548 0a4e 880B      		sbc r24,r24
 2549 0a50 990B      		sbc r25,r25
 2550 0a52 0E94 0000 		call __floatsisf
 2551               	.LVL233:
 2552 0a56 9B01      		movw r18,r22
 2553 0a58 AC01      		movw r20,r24
 2554 0a5a C301      		movw r24,r6
 2555 0a5c B201      		movw r22,r4
 2556 0a5e 0E94 0000 		call __mulsf3
 2557               	.LVL234:
 2558 0a62 4B01      		movw r8,r22
 2559 0a64 5C01      		movw r10,r24
 2560               	.LVL235:
 520:main.c        **** 
 521:main.c        ****     if (!(pid > 100.0 && delta > 0.0) && !(pid < -100.0 && delta < 0.0)) {
 2561               		.loc 1 521 0
 2562 0a66 20E0      		ldi r18,0
 2563 0a68 30E0      		ldi r19,0
 2564 0a6a 48EC      		ldi r20,lo8(-56)
 2565 0a6c 52E4      		ldi r21,lo8(66)
 2566 0a6e 0E94 0000 		call __gtsf2
 2567               	.LVL236:
 2568 0a72 1816      		cp __zero_reg__,r24
 2569 0a74 04F4      		brge .L117
 2570               		.loc 1 521 0 is_stmt 0 discriminator 2
 2571 0a76 20E0      		ldi r18,0
 2572 0a78 30E0      		ldi r19,0
 2573 0a7a A901      		movw r20,r18
 2574 0a7c C701      		movw r24,r14
 2575 0a7e B601      		movw r22,r12
 2576 0a80 0E94 0000 		call __gtsf2
 2577               	.LVL237:
 2578 0a84 1816      		cp __zero_reg__,r24
 2579 0a86 04F0      		brlt .L119
 2580               	.L117:
 2581               		.loc 1 521 0 discriminator 3
 2582 0a88 20E0      		ldi r18,0
 2583 0a8a 30E0      		ldi r19,0
 2584 0a8c 48EC      		ldi r20,lo8(-56)
 2585 0a8e 52EC      		ldi r21,lo8(-62)
 2586 0a90 C501      		movw r24,r10
 2587 0a92 B401      		movw r22,r8
 2588 0a94 0E94 0000 		call __ltsf2
 2589               	.LVL238:
 2590 0a98 87FF      		sbrs r24,7
 2591 0a9a 00C0      		rjmp .L120
 2592               		.loc 1 521 0 discriminator 4
 2593 0a9c 20E0      		ldi r18,0
 2594 0a9e 30E0      		ldi r19,0
 2595 0aa0 A901      		movw r20,r18
 2596 0aa2 C701      		movw r24,r14
 2597 0aa4 B601      		movw r22,r12
 2598 0aa6 0E94 0000 		call __ltsf2
 2599               	.LVL239:
 2600 0aaa 87FD      		sbrc r24,7
 2601 0aac 00C0      		rjmp .L119
 2602               	.L120:
 522:main.c        **** 	Ipid += delta;
 2603               		.loc 1 522 0 is_stmt 1
 2604 0aae 2091 0000 		lds r18,Ipid
 2605 0ab2 3091 0000 		lds r19,Ipid+1
 2606 0ab6 4091 0000 		lds r20,Ipid+2
 2607 0aba 5091 0000 		lds r21,Ipid+3
 2608 0abe C701      		movw r24,r14
 2609 0ac0 B601      		movw r22,r12
 2610 0ac2 0E94 0000 		call __addsf3
 2611               	.LVL240:
 2612 0ac6 6093 0000 		sts Ipid,r22
 2613 0aca 7093 0000 		sts Ipid+1,r23
 2614 0ace 8093 0000 		sts Ipid+2,r24
 2615 0ad2 9093 0000 		sts Ipid+3,r25
 2616               	.L119:
 523:main.c        ****     }
 524:main.c        **** 
 525:main.c        ****     float_to_uart("Ip", Ipid);
 2617               		.loc 1 525 0
 2618 0ad6 6091 0000 		lds r22,Ipid
 2619 0ada 7091 0000 		lds r23,Ipid+1
 2620 0ade 8091 0000 		lds r24,Ipid+2
 2621 0ae2 9091 0000 		lds r25,Ipid+3
 2622               	.LVL241:
 2623               	.LBB121:
 2624               	.LBB122:
  43:main.c        ****     /*    USART_SendStr(id);
 2625               		.loc 1 43 0
 2626 0ae6 0E94 0000 		call __fixsfsi
 2627               	.LVL242:
 2628 0aea 80E0      		ldi r24,lo8(.LC14)
 2629 0aec 90E0      		ldi r25,hi8(.LC14)
 2630 0aee 0E94 0000 		call int_to_uart
 2631               	.LVL243:
 2632               	.LBE122:
 2633               	.LBE121:
 2634               	.LBB123:
 2635               	.LBB124:
 2636 0af2 C501      		movw r24,r10
 2637 0af4 B401      		movw r22,r8
 2638 0af6 0E94 0000 		call __fixsfsi
 2639               	.LVL244:
 2640 0afa 80E0      		ldi r24,lo8(.LC15)
 2641 0afc 90E0      		ldi r25,hi8(.LC15)
 2642 0afe 0E94 0000 		call int_to_uart
 2643               	.LVL245:
 2644               	.LBE124:
 2645               	.LBE123:
 526:main.c        ****     float_to_uart("pid", pid);
 527:main.c        **** 
 528:main.c        ****     temp_out_delay++;
 2646               		.loc 1 528 0
 2647 0b02 8091 0000 		lds r24,temp_out_delay
 2648 0b06 8F5F      		subi r24,lo8(-(1))
 2649 0b08 8093 0000 		sts temp_out_delay,r24
 529:main.c        ****     if (temp_out_delay > vars.temp_seg_delay) {
 2650               		.loc 1 529 0
 2651 0b0c 2091 0000 		lds r18,temp_out_delay
 2652 0b10 8091 0000 		lds r24,vars+7
 2653 0b14 30E0      		ldi r19,0
 2654 0b16 082E      		mov __tmp_reg__,r24
 2655 0b18 000C      		lsl r0
 2656 0b1a 990B      		sbc r25,r25
 2657 0b1c 8217      		cp r24,r18
 2658 0b1e 9307      		cpc r25,r19
 2659 0b20 04F4      		brge .L122
 530:main.c        **** 	temp_out_delay = 0;
 2660               		.loc 1 530 0
 2661 0b22 1092 0000 		sts temp_out_delay,__zero_reg__
 531:main.c        **** 	//temp_out_prc = (check_rangef(0, pid, 101) + temp_out_prc) / 2;
 532:main.c        **** 	temp_out_prc = check_rangef(0, pid, 101);
 2662               		.loc 1 532 0
 2663 0b26 E12C      		mov r14,__zero_reg__
 2664 0b28 F12C      		mov r15,__zero_reg__
 2665 0b2a 0AEC      		ldi r16,lo8(-54)
 2666 0b2c 12E4      		ldi r17,lo8(66)
 2667 0b2e A501      		movw r20,r10
 2668 0b30 9401      		movw r18,r8
 2669 0b32 60E0      		ldi r22,0
 2670 0b34 70E0      		ldi r23,0
 2671 0b36 CB01      		movw r24,r22
 2672 0b38 0E94 0000 		call check_rangef
 2673               	.LVL246:
 2674 0b3c 0E94 0000 		call __fixunssfsi
 2675               	.LVL247:
 2676 0b40 6093 0000 		sts temp_out_prc,r22
 2677               	.L122:
 533:main.c        ****     }
 534:main.c        **** 
 535:main.c        ****     int_to_uart("out", temp_out_prc);
 2678               		.loc 1 535 0
 2679 0b44 6091 0000 		lds r22,temp_out_prc
 2680 0b48 70E0      		ldi r23,0
 2681 0b4a 80E0      		ldi r24,lo8(.LC16)
 2682 0b4c 90E0      		ldi r25,hi8(.LC16)
 2683 0b4e 0E94 0000 		call int_to_uart
 2684               	.LVL248:
 536:main.c        **** 
 537:main.c        ****     //calcVent(id);
 538:main.c        ****     calcVent(pid);
 2685               		.loc 1 538 0
 2686 0b52 C501      		movw r24,r10
 2687 0b54 B401      		movw r22,r8
 2688 0b56 0E94 0000 		call calcVent
 2689               	.LVL249:
 2690               	/* epilogue start */
 539:main.c        **** 
 540:main.c        ****     uart_nl();
 541:main.c        **** }
 2691               		.loc 1 541 0
 2692 0b5a CF91      		pop r28
 2693 0b5c 1F91      		pop r17
 2694 0b5e 0F91      		pop r16
 2695 0b60 FF90      		pop r15
 2696 0b62 EF90      		pop r14
 2697 0b64 DF90      		pop r13
 2698 0b66 CF90      		pop r12
 2699               	.LVL250:
 2700 0b68 BF90      		pop r11
 2701 0b6a AF90      		pop r10
 2702 0b6c 9F90      		pop r9
 2703 0b6e 8F90      		pop r8
 2704               	.LVL251:
 2705 0b70 7F90      		pop r7
 2706 0b72 6F90      		pop r6
 2707 0b74 5F90      		pop r5
 2708 0b76 4F90      		pop r4
 540:main.c        **** }
 2709               		.loc 1 540 0
 2710 0b78 0C94 0000 		jmp uart_nl
 2711               	.LVL252:
 2712               		.cfi_endproc
 2713               	.LFE35:
 2715               	.global	recycleSwitch
 2717               	recycleSwitch:
 2718               	.LFB36:
 542:main.c        **** 
 543:main.c        **** void recycleSwitch(void) // эмуляция нажатия
 544:main.c        **** {
 2719               		.loc 1 544 0
 2720               		.cfi_startproc
 2721               	/* prologue: function */
 2722               	/* frame size = 0 */
 2723               	/* stack size = 0 */
 2724               	.L__stack_usage = 0
 545:main.c        ****     pin_low(OUT_BTN_Recycle);
 2725               		.loc 1 545 0
 2726 0b7c 5898      		cbi 0xb,0
 546:main.c        ****     set_dir_out(OUT_BTN_Recycle);
 2727               		.loc 1 546 0
 2728 0b7e 509A      		sbi 0xa,0
 547:main.c        ****     delay_ms(50);
 2729               		.loc 1 547 0
 2730 0b80 82E3      		ldi r24,lo8(50)
 2731 0b82 90E0      		ldi r25,0
 2732 0b84 0E94 0000 		call delay_ms
 2733               	.LVL253:
 548:main.c        **** //    pin_high(OUT_BTN_Recycle);
 549:main.c        ****     set_dir_in(OUT_BTN_Recycle);
 2734               		.loc 1 549 0
 2735 0b88 5098      		cbi 0xa,0
 2736 0b8a 0895      		ret
 2737               		.cfi_endproc
 2738               	.LFE36:
 2740               	.global	prefAirSwitch
 2742               	prefAirSwitch:
 2743               	.LFB37:
 550:main.c        **** }
 551:main.c        **** 
 552:main.c        **** void prefAirSwitch(void) // эмуляция нажатия
 553:main.c        **** {
 2744               		.loc 1 553 0
 2745               		.cfi_startproc
 2746               	/* prologue: function */
 2747               	/* frame size = 0 */
 2748               	/* stack size = 0 */
 2749               	.L__stack_usage = 0
 554:main.c        ****     pin_low(OUT_BTN_PREF_MODE);
 2750               		.loc 1 554 0
 2751 0b8c 4098      		cbi 0x8,0
 555:main.c        ****     set_dir_out(OUT_BTN_PREF_MODE);
 2752               		.loc 1 555 0
 2753 0b8e 389A      		sbi 0x7,0
 556:main.c        ****     delay_ms(50);
 2754               		.loc 1 556 0
 2755 0b90 82E3      		ldi r24,lo8(50)
 2756 0b92 90E0      		ldi r25,0
 2757 0b94 0E94 0000 		call delay_ms
 2758               	.LVL254:
 557:main.c        ****     set_dir_in(OUT_BTN_PREF_MODE);
 2759               		.loc 1 557 0
 2760 0b98 3898      		cbi 0x7,0
 2761 0b9a 0895      		ret
 2762               		.cfi_endproc
 2763               	.LFE37:
 2765               	.global	hiAirSwitch
 2767               	hiAirSwitch:
 2768               	.LFB38:
 558:main.c        **** }
 559:main.c        **** 
 560:main.c        **** void hiAirSwitch(void) // эмуляция нажатия
 561:main.c        **** {
 2769               		.loc 1 561 0
 2770               		.cfi_startproc
 2771               	/* prologue: function */
 2772               	/* frame size = 0 */
 2773               	/* stack size = 0 */
 2774               	.L__stack_usage = 0
 562:main.c        ****     pin_low(IN_BTN_HI_MODE);
 2775               		.loc 1 562 0
 2776 0b9c 4498      		cbi 0x8,4
 563:main.c        ****     set_dir_out(IN_BTN_HI_MODE);
 2777               		.loc 1 563 0
 2778 0b9e 3C9A      		sbi 0x7,4
 564:main.c        ****     delay_ms(50);
 2779               		.loc 1 564 0
 2780 0ba0 82E3      		ldi r24,lo8(50)
 2781 0ba2 90E0      		ldi r25,0
 2782 0ba4 0E94 0000 		call delay_ms
 2783               	.LVL255:
 565:main.c        ****     set_dir_in(IN_BTN_HI_MODE);
 2784               		.loc 1 565 0
 2785 0ba8 3C98      		cbi 0x7,4
 2786 0baa 0895      		ret
 2787               		.cfi_endproc
 2788               	.LFE38:
 2790               	.global	setup_pins
 2792               	setup_pins:
 2793               	.LFB39:
 566:main.c        **** }
 567:main.c        **** 
 568:main.c        **** void setup_pins(void)
 569:main.c        **** {
 2794               		.loc 1 569 0
 2795               		.cfi_startproc
 2796               	/* prologue: function */
 2797               	/* frame size = 0 */
 2798               	/* stack size = 0 */
 2799               	.L__stack_usage = 0
 570:main.c        ****     PORTB = 0;
 2800               		.loc 1 570 0
 2801 0bac 15B8      		out 0x5,__zero_reg__
 571:main.c        ****     PORTC = 0;
 2802               		.loc 1 571 0
 2803 0bae 18B8      		out 0x8,__zero_reg__
 572:main.c        ****     PORTD = 0;
 2804               		.loc 1 572 0
 2805 0bb0 1BB8      		out 0xb,__zero_reg__
 573:main.c        ****     DDRB = 0; //dir to in
 2806               		.loc 1 573 0
 2807 0bb2 14B8      		out 0x4,__zero_reg__
 574:main.c        ****     DDRC = 0; //dir to in
 2808               		.loc 1 574 0
 2809 0bb4 17B8      		out 0x7,__zero_reg__
 575:main.c        ****     DDRD = 0; //dir to in
 2810               		.loc 1 575 0
 2811 0bb6 1AB8      		out 0xa,__zero_reg__
 576:main.c        ****     /*    set_dir_in(IN_BTN_HI_MODE);
 577:main.c        ****      set_dir_in(IN_BTN_SETUP);
 578:main.c        ****      set_dir_in(IN_BTN_T_UP);
 579:main.c        ****      set_dir_in(IN_BTN_T_DWN);
 580:main.c        ****      set_dir_in(IN_BTN_V_UP);
 581:main.c        ****      set_dir_in(IN_BTN_V_DWN);
 582:main.c        ****      set_dir_in(IN_ACC);
 583:main.c        ****      IN_NIGHT_BR
 584:main.c        ****      set_dir_in(IN_FROST_BTN);*/
 585:main.c        **** 
 586:main.c        ****     pin_low(OUT_FROST_SW);
 2812               		.loc 1 586 0
 2813 0bb8 4598      		cbi 0x8,5
 587:main.c        ****     set_dir_out(OUT_FROST_SW);
 2814               		.loc 1 587 0
 2815 0bba 3D9A      		sbi 0x7,5
 588:main.c        ****     pin_low(OUT_FROST_IND);
 2816               		.loc 1 588 0
 2817 0bbc 4198      		cbi 0x8,1
 589:main.c        ****     set_dir_out(OUT_FROST_IND);
 2818               		.loc 1 589 0
 2819 0bbe 399A      		sbi 0x7,1
 590:main.c        ****     set_dir_out(OUT_BTN_T_UP);
 2820               		.loc 1 590 0
 2821 0bc0 559A      		sbi 0xa,5
 591:main.c        ****     set_dir_out(OUT_BTN_T_DWN);
 2822               		.loc 1 591 0
 2823 0bc2 549A      		sbi 0xa,4
 592:main.c        ****     set_dir_out(OUT_BTN_V_UP);
 2824               		.loc 1 592 0
 2825 0bc4 569A      		sbi 0xa,6
 593:main.c        ****     set_dir_out(OUT_BTN_V_DWN);
 2826               		.loc 1 593 0
 2827 0bc6 219A      		sbi 0x4,1
 2828 0bc8 0895      		ret
 2829               		.cfi_endproc
 2830               	.LFE39:
 2832               	.global	setup_display
 2834               	setup_display:
 2835               	.LFB40:
 594:main.c        **** }
 595:main.c        **** 
 596:main.c        **** void setup_display(void)
 597:main.c        **** {
 2836               		.loc 1 597 0
 2837               		.cfi_startproc
 2838               	/* prologue: function */
 2839               	/* frame size = 0 */
 2840               	/* stack size = 0 */
 2841               	.L__stack_usage = 0
 598:main.c        ****     Send_7219(0x09, 0x00); //режим декодирования
 2842               		.loc 1 598 0
 2843 0bca 60E0      		ldi r22,0
 2844 0bcc 89E0      		ldi r24,lo8(9)
 2845 0bce 0E94 0000 		call Send_7219
 2846               	.LVL256:
 599:main.c        ****     int8_t br_dsp = DISP_BRG_MIN;
 600:main.c        ****     if (!get_input(IN_NIGHT_BR)) {
 2847               		.loc 1 600 0
 2848 0bd2 3299      		sbic 0x6,2
 2849 0bd4 00C0      		rjmp .L132
 601:main.c        **** 	br_dsp = DISP_BRG_MAX;
 2850               		.loc 1 601 0
 2851 0bd6 67E0      		ldi r22,lo8(7)
 2852 0bd8 00C0      		rjmp .L131
 2853               	.L132:
 599:main.c        ****     int8_t br_dsp = DISP_BRG_MIN;
 2854               		.loc 1 599 0
 2855 0bda 61E0      		ldi r22,lo8(1)
 2856               	.L131:
 2857               	.LVL257:
 602:main.c        ****     }
 603:main.c        ****     Send_7219(0x0A, br_dsp); //яркость
 2858               		.loc 1 603 0
 2859 0bdc 8AE0      		ldi r24,lo8(10)
 2860 0bde 0E94 0000 		call Send_7219
 2861               	.LVL258:
 604:main.c        ****     Send_7219(0x0B, DISP_LEN - 1); //сколько разрядов используем
 2862               		.loc 1 604 0
 2863 0be2 63E0      		ldi r22,lo8(3)
 2864 0be4 8BE0      		ldi r24,lo8(11)
 2865 0be6 0E94 0000 		call Send_7219
 2866               	.LVL259:
 605:main.c        ****     Send_7219(0x0C, 1); //включим индикатор
 2867               		.loc 1 605 0
 2868 0bea 61E0      		ldi r22,lo8(1)
 2869 0bec 8CE0      		ldi r24,lo8(12)
 2870 0bee 0E94 0000 		call Send_7219
 2871               	.LVL260:
 606:main.c        ****     Send_7219(0x0F, 0x00);
 2872               		.loc 1 606 0
 2873 0bf2 60E0      		ldi r22,0
 2874 0bf4 8FE0      		ldi r24,lo8(15)
 2875 0bf6 0C94 0000 		jmp Send_7219
 2876               	.LVL261:
 2877               		.cfi_endproc
 2878               	.LFE40:
 2880               		.section	.text.startup,"ax",@progbits
 2881               	.global	main
 2883               	main:
 2884               	.LFB41:
 607:main.c        **** }
 608:main.c        **** 
 609:main.c        **** int main(void)
 610:main.c        **** {
 2885               		.loc 1 610 0
 2886               		.cfi_startproc
 2887               	/* prologue: function */
 2888               	/* frame size = 0 */
 2889               	/* stack size = 0 */
 2890               	.L__stack_usage = 0
 611:main.c        ****     wdt_reset();
 2891               		.loc 1 611 0
 2892               	/* #APP */
 2893               	 ;  611 "main.c" 1
 2894 0000 A895      		wdr
 2895               	 ;  0 "" 2
 612:main.c        ****     cli();
 2896               		.loc 1 612 0
 2897               	 ;  612 "main.c" 1
 2898 0002 F894      		cli
 2899               	 ;  0 "" 2
 2900               	.LVL262:
 2901               	/* #NOAPP */
 2902               	.LBB136:
 2903               	.LBB137:
 2904               		.file 3 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2905               		.loc 3 473 0
 2906 0004 C8E1      		ldi r28,lo8(24)
 2907 0006 18E2      		ldi r17,lo8(40)
 2908               	/* #APP */
 2909               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 2910 0008 0FB6      		in __tmp_reg__,__SREG__
 2911 000a F894      		cli
 2912 000c A895      		wdr
 2913 000e C093 6000 		sts 96, r28
 2914 0012 0FBE      		out __SREG__,__tmp_reg__
 2915 0014 1093 6000 		sts 96, r17
 2916               	 	
 2917               	 ;  0 "" 2
 2918               	.LVL263:
 2919               	/* #NOAPP */
 2920               	.LBE137:
 2921               	.LBE136:
 613:main.c        ****     wdt_enable(WDTO_4S);
 614:main.c        ****     wdt_reset();
 2922               		.loc 1 614 0
 2923               	/* #APP */
 2924               	 ;  614 "main.c" 1
 2925 0018 A895      		wdr
 2926               	 ;  0 "" 2
 2927               	.LVL264:
 615:main.c        ****     int8_t disp_num = 0;
 616:main.c        ****     uint8_t disp_bar = 0;
 617:main.c        ****     int8_t tmp;
 618:main.c        ****     uint8_t time_cnt;
 619:main.c        ****     int8_t smode = 0;
 620:main.c        ****     int8_t bdelay = 0;
 621:main.c        **** 
 622:main.c        ****     vent_add_prc = 0;
 2928               		.loc 1 622 0
 2929               	/* #NOAPP */
 2930 001a 1092 0000 		sts vent_add_prc,__zero_reg__
 623:main.c        ****     temp_out_prc = 0;
 2931               		.loc 1 623 0
 2932 001e 1092 0000 		sts temp_out_prc,__zero_reg__
 624:main.c        ****     temp_out_delay = TEMP_OUT_DELAY;
 2933               		.loc 1 624 0
 2934 0022 82E0      		ldi r24,lo8(2)
 2935 0024 8093 0000 		sts temp_out_delay,r24
 625:main.c        **** 
 626:main.c        **** //    powerUp_time_sec = 0;
 627:main.c        ****     Ipid = 0.0;
 2936               		.loc 1 627 0
 2937 0028 1092 0000 		sts Ipid,__zero_reg__
 2938 002c 1092 0000 		sts Ipid+1,__zero_reg__
 2939 0030 1092 0000 		sts Ipid+2,__zero_reg__
 2940 0034 1092 0000 		sts Ipid+3,__zero_reg__
 628:main.c        ****     last_delta = 0.0;
 2941               		.loc 1 628 0
 2942 0038 1092 0000 		sts last_delta,__zero_reg__
 2943 003c 1092 0000 		sts last_delta+1,__zero_reg__
 2944 0040 1092 0000 		sts last_delta+2,__zero_reg__
 2945 0044 1092 0000 		sts last_delta+3,__zero_reg__
 629:main.c        ****     flags = 0;
 2946               		.loc 1 629 0
 2947 0048 1092 0000 		sts flags,__zero_reg__
 630:main.c        ****     SET_FLAG(f_mode_hot);
 2948               		.loc 1 630 0
 2949 004c 8091 0000 		lds r24,flags
 2950 0050 8260      		ori r24,lo8(2)
 2951 0052 8093 0000 		sts flags,r24
 631:main.c        ****     CLR_FLAG(f_cond_btn_press);
 2952               		.loc 1 631 0
 2953 0056 8091 0000 		lds r24,flags
 2954 005a 8F7E      		andi r24,lo8(-17)
 2955 005c 8093 0000 		sts flags,r24
 632:main.c        **** 
 633:main.c        ****     setup_pins();
 2956               		.loc 1 633 0
 2957 0060 0E94 0000 		call setup_pins
 2958               	.LVL265:
 634:main.c        **** 
 635:main.c        **** /*    while (!get_input(IN_ACC)) { //ACC off
 636:main.c        **** 	wdt_reset();
 637:main.c        **** 	delay_ms(100); // wait for ACC
 638:main.c        ****     }
 639:main.c        **** */
 640:main.c        ****     delay_ms(10);
 2959               		.loc 1 640 0
 2960 0064 8AE0      		ldi r24,lo8(10)
 2961 0066 90E0      		ldi r25,0
 2962 0068 0E94 0000 		call delay_ms
 2963               	.LVL266:
 641:main.c        ****     myread_eeprom();
 2964               		.loc 1 641 0
 2965 006c 0E94 0000 		call myread_eeprom
 2966               	.LVL267:
 642:main.c        ****     //TODO sei();
 643:main.c        **** 
 644:main.c        ****     ADC_Init();
 2967               		.loc 1 644 0
 2968 0070 0E94 0000 		call ADC_Init
 2969               	.LVL268:
 645:main.c        ****     USART_Init();
 2970               		.loc 1 645 0
 2971 0074 0E94 0000 		call USART_Init
 2972               	.LVL269:
 646:main.c        ****     //int_to_uart("T", 0);
 647:main.c        **** 
 648:main.c        ****     SPI_init();
 2973               		.loc 1 648 0
 2974 0078 0E94 0000 		call SPI_init
 2975               	.LVL270:
 649:main.c        ****     delay_ms(1);
 2976               		.loc 1 649 0
 2977 007c 81E0      		ldi r24,lo8(1)
 2978 007e 90E0      		ldi r25,0
 2979 0080 0E94 0000 		call delay_ms
 2980               	.LVL271:
 650:main.c        **** 
 651:main.c        ****     //int_to_uart("T", 1);
 652:main.c        ****     Send_7219(0, 0);
 2981               		.loc 1 652 0
 2982 0084 60E0      		ldi r22,0
 2983 0086 80E0      		ldi r24,0
 2984 0088 0E94 0000 		call Send_7219
 2985               	.LVL272:
 653:main.c        ****     delay_ms(1);
 2986               		.loc 1 653 0
 2987 008c 81E0      		ldi r24,lo8(1)
 2988 008e 90E0      		ldi r25,0
 2989 0090 0E94 0000 		call delay_ms
 2990               	.LVL273:
 654:main.c        ****     Clear_7219();
 2991               		.loc 1 654 0
 2992 0094 0E94 0000 		call Clear_7219
 2993               	.LVL274:
 655:main.c        ****     Send_7219(0x09, 0x00); //режим декодирования
 2994               		.loc 1 655 0
 2995 0098 60E0      		ldi r22,0
 2996 009a 89E0      		ldi r24,lo8(9)
 2997 009c 0E94 0000 		call Send_7219
 2998               	.LVL275:
 656:main.c        ****     Send_7219(0x0A, 0x01); //яркость
 2999               		.loc 1 656 0
 3000 00a0 61E0      		ldi r22,lo8(1)
 3001 00a2 8AE0      		ldi r24,lo8(10)
 3002 00a4 0E94 0000 		call Send_7219
 3003               	.LVL276:
 657:main.c        ****     Send_7219(0x0B, DISP_LEN - 1); //сколько разрядов используем
 3004               		.loc 1 657 0
 3005 00a8 63E0      		ldi r22,lo8(3)
 3006 00aa 8BE0      		ldi r24,lo8(11)
 3007 00ac 0E94 0000 		call Send_7219
 3008               	.LVL277:
 658:main.c        ****     Send_7219(0x0D, 0x00);
 3009               		.loc 1 658 0
 3010 00b0 60E0      		ldi r22,0
 3011 00b2 8DE0      		ldi r24,lo8(13)
 3012 00b4 0E94 0000 		call Send_7219
 3013               	.LVL278:
 659:main.c        ****     Send_7219(0x0E, 0x00);
 3014               		.loc 1 659 0
 3015 00b8 60E0      		ldi r22,0
 3016 00ba 8EE0      		ldi r24,lo8(14)
 3017 00bc 0E94 0000 		call Send_7219
 3018               	.LVL279:
 660:main.c        ****     Send_7219(0x0F, 0x00);
 3019               		.loc 1 660 0
 3020 00c0 60E0      		ldi r22,0
 3021 00c2 8FE0      		ldi r24,lo8(15)
 3022 00c4 0E94 0000 		call Send_7219
 3023               	.LVL280:
 661:main.c        ****     delay_ms(1);
 3024               		.loc 1 661 0
 3025 00c8 81E0      		ldi r24,lo8(1)
 3026 00ca 90E0      		ldi r25,0
 3027 00cc 0E94 0000 		call delay_ms
 3028               	.LVL281:
 662:main.c        **** 
 663:main.c        ****     //int_to_uart("T", 2);
 664:main.c        ****     wdt_reset();
 3029               		.loc 1 664 0
 3030               	/* #APP */
 3031               	 ;  664 "main.c" 1
 3032 00d0 A895      		wdr
 3033               	 ;  0 "" 2
 665:main.c        **** 
 666:main.c        ****     disp_num = vars.setup_temp;
 3034               		.loc 1 666 0
 3035               	/* #NOAPP */
 3036 00d2 D091 0000 		lds r29,vars+1
 3037               	.LVL282:
 667:main.c        ****     Disp_Num(disp_num, 0);
 3038               		.loc 1 667 0
 3039 00d6 60E0      		ldi r22,0
 3040 00d8 8D2F      		mov r24,r29
 3041 00da 0E94 0000 		call Disp_Num
 3042               	.LVL283:
 668:main.c        ****     Send_7219(0x0C, 1); //включим индикатор
 3043               		.loc 1 668 0
 3044 00de 61E0      		ldi r22,lo8(1)
 3045 00e0 8CE0      		ldi r24,lo8(12)
 3046 00e2 0E94 0000 		call Send_7219
 3047               	.LVL284:
 669:main.c        ****     disp_bar = vars.vent_nom_seg;
 3048               		.loc 1 669 0
 3049 00e6 D090 0000 		lds r13,vars+2
 3050               	.LVL285:
 670:main.c        ****     Disp_Bars(disp_bar);
 3051               		.loc 1 670 0
 3052 00ea 8D2D      		mov r24,r13
 3053 00ec 0E94 0000 		call Disp_Bars
 3054               	.LVL286:
 671:main.c        **** 
 672:main.c        ****     cli();
 3055               		.loc 1 672 0
 3056               	/* #APP */
 3057               	 ;  672 "main.c" 1
 3058 00f0 F894      		cli
 3059               	 ;  0 "" 2
 673:main.c        ****     //int_to_uart("T", 3);
 674:main.c        **** //timer init
 675:main.c        ****     TCCR1A = 0;  	//Т/С1 отсоединен от вывода ОС1, режим ШИМ откл
 3060               		.loc 1 675 0
 3061               	/* #NOAPP */
 3062 00f2 1092 8000 		sts 128,__zero_reg__
 676:main.c        ****     TCCR1B = 4;  	//Коэффициент деления частоты системной	син
 3063               		.loc 1 676 0
 3064 00f6 84E0      		ldi r24,lo8(4)
 3065 00f8 8093 8100 		sts 129,r24
 677:main.c        ****     TCNT1 = 0x10000 - (F_CPU / 512); //Инициализируем счетный регистр
 3066               		.loc 1 677 0
 3067 00fc 87EF      		ldi r24,lo8(-9)
 3068 00fe 92EC      		ldi r25,lo8(-62)
 3069 0100 9093 8500 		sts 132+1,r25
 3070 0104 8093 8400 		sts 132,r24
 678:main.c        **** 
 679:main.c        ****     TIFR1 = 0;       //Сбрасываем все флаги прерываний от Т/С1
 3071               		.loc 1 679 0
 3072 0108 16BA      		out 0x16,__zero_reg__
 680:main.c        ****     TIMSK1 = 1 << TOIE1;  	//Разрешаем прерывание при переполнени
 3073               		.loc 1 680 0
 3074 010a 81E0      		ldi r24,lo8(1)
 3075 010c 8093 6F00 		sts 111,r24
 681:main.c        **** 
 682:main.c        ****     //interrupt setup
 683:main.c        ****     EICRA = 0; // External Interrupt Control Register A
 3076               		.loc 1 683 0
 3077 0110 1092 6900 		sts 105,__zero_reg__
 684:main.c        ****     EIMSK = 0; //External Interrupt Mask Register
 3078               		.loc 1 684 0
 3079 0114 1DBA      		out 0x1d,__zero_reg__
 685:main.c        **** /*    EIMSK = (1 << INT0) | (1 << INT1);
 686:main.c        ****     EICRA = (1 << ISC00) | (1 << ISC10); // set INT0 + INT1 to trigger on ANY logic change
 687:main.c        **** 
 688:main.c        ****     //int_to_uart("T", 4);
 689:main.c        **** 
 690:main.c        ****     //set by IN_BTN_V_DWN  + IN_BTN_V_UP
 691:main.c        ****     PCMSK0 = (1 << PCINT0);  // set PCINT0 to trigger an interrupt on state change
 692:main.c        ****     PCMSK2 = (1 << PCINT23);  // set PCINT23 to trigger an interrupt on state change
 693:main.c        ****     PCICR = (1 << PCIE0) | (1 << PCIE2);    // Pin Change Interrupt Control Register
 694:main.c        **** */
 695:main.c        ****     PCMSK0 = 0;
 3080               		.loc 1 695 0
 3081 0116 1092 6B00 		sts 107,__zero_reg__
 696:main.c        ****     PCMSK2 = 0;
 3082               		.loc 1 696 0
 3083 011a 1092 6D00 		sts 109,__zero_reg__
 697:main.c        ****     PCICR = 0;
 3084               		.loc 1 697 0
 3085 011e 1092 6800 		sts 104,__zero_reg__
 698:main.c        **** 
 699:main.c        **** //todo	GIMSK = 0;     	//Запрет внешних прерываний
 700:main.c        ****     //int_to_uart("T", 5);
 701:main.c        ****     delay_ms(10);
 3086               		.loc 1 701 0
 3087 0122 8AE0      		ldi r24,lo8(10)
 3088 0124 90E0      		ldi r25,0
 3089 0126 0E94 0000 		call delay_ms
 3090               	.LVL287:
 702:main.c        ****     sei();
 3091               		.loc 1 702 0
 3092               	/* #APP */
 3093               	 ;  702 "main.c" 1
 3094 012a 7894      		sei
 3095               	 ;  0 "" 2
 703:main.c        **** 
 704:main.c        ****     vent_enc = 0;
 3096               		.loc 1 704 0
 3097               	/* #NOAPP */
 3098 012c 1092 0000 		sts vent_enc,__zero_reg__
 705:main.c        ****     temp_enc = 0;
 3099               		.loc 1 705 0
 3100 0130 1092 0000 		sts temp_enc,__zero_reg__
 3101               	.LVL288:
 706:main.c        ****     time_cnt = 0;
 707:main.c        **** 
 708:main.c        ****     wdt_reset();
 3102               		.loc 1 708 0
 3103               	/* #APP */
 3104               	 ;  708 "main.c" 1
 3105 0134 A895      		wdr
 3106               	 ;  0 "" 2
 709:main.c        ****     vent_seg_cur = VENT_SEG;
 3107               		.loc 1 709 0
 3108               	/* #NOAPP */
 3109 0136 88E0      		ldi r24,lo8(8)
 3110 0138 8093 0000 		sts vent_seg_cur,r24
 710:main.c        ****     temp_seg_cur = TEMP_SEG;
 3111               		.loc 1 710 0
 3112 013c 8FE0      		ldi r24,lo8(15)
 3113 013e 8093 0000 		sts temp_seg_cur,r24
 711:main.c        ****     set_vent_seg(0, 1);
 3114               		.loc 1 711 0
 3115 0142 61E0      		ldi r22,lo8(1)
 3116 0144 80E0      		ldi r24,0
 3117 0146 0E94 0000 		call set_vent_seg
 3118               	.LVL289:
 712:main.c        ****     set_temp(0, 1);
 3119               		.loc 1 712 0
 3120 014a 61E0      		ldi r22,lo8(1)
 3121 014c 80E0      		ldi r24,0
 3122 014e 0E94 0000 		call set_temp
 3123               	.LVL290:
 3124               	.LBB138:
 3125               	.LBB139:
 3126               		.loc 3 473 0
 3127               	/* #APP */
 3128               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 3129 0152 0FB6      		in __tmp_reg__,__SREG__
 3130 0154 F894      		cli
 3131 0156 A895      		wdr
 3132 0158 C093 6000 		sts 96, r28
 3133 015c 0FBE      		out __SREG__,__tmp_reg__
 3134 015e 1093 6000 		sts 96, r17
 3135               	 	
 3136               	 ;  0 "" 2
 3137               	.LVL291:
 3138               	/* #NOAPP */
 3139               	.LBE139:
 3140               	.LBE138:
 713:main.c        **** 
 714:main.c        ****     wdt_enable(WDTO_4S);
 715:main.c        ****     //int_to_uart("T", 10);
 716:main.c        **** /*
 717:main.c        ****     if (vars.auto_defrost) {
 718:main.c        **** 	tmp = 5;
 719:main.c        **** 	while (tmp--) {
 720:main.c        **** 	    wdt_reset();
 721:main.c        **** 	    Ts = calcTemp(IN_ADC_T_SALON);
 722:main.c        **** 	    delay_ms(100);
 723:main.c        **** 	}
 724:main.c        **** 	tmp = vars.auto_defrost - 3;
 725:main.c        **** 	if (Ts < tmp) {
 726:main.c        **** 	    smode = smode_hi_mode;
 727:main.c        **** 	}
 728:main.c        ****     }
 729:main.c        **** */
 730:main.c        ****     Ts = 16.0;
 3141               		.loc 1 730 0
 3142 0162 80E0      		ldi r24,0
 3143 0164 90E0      		ldi r25,0
 3144 0166 A0E8      		ldi r26,lo8(-128)
 3145 0168 B1E4      		ldi r27,lo8(65)
 3146 016a 8093 0000 		sts Ts,r24
 3147 016e 9093 0000 		sts Ts+1,r25
 3148 0172 A093 0000 		sts Ts+2,r26
 3149 0176 B093 0000 		sts Ts+3,r27
 731:main.c        **** 
 732:main.c        ****     Ipid =  (float) vars.setup_temp;
 3150               		.loc 1 732 0
 3151 017a 6091 0000 		lds r22,vars+1
 3152 017e 062E      		mov __tmp_reg__,r22
 3153 0180 000C      		lsl r0
 3154 0182 770B      		sbc r23,r23
 3155 0184 880B      		sbc r24,r24
 3156 0186 990B      		sbc r25,r25
 3157 0188 0E94 0000 		call __floatsisf
 3158               	.LVL292:
 3159 018c 6093 0000 		sts Ipid,r22
 3160 0190 7093 0000 		sts Ipid+1,r23
 3161 0194 8093 0000 		sts Ipid+2,r24
 3162 0198 9093 0000 		sts Ipid+3,r25
 733:main.c        ****     Ipid = check_rangef(-(100/PID_I_KFC), Ipid - Ts, 100/PID_I_KFC);
 3163               		.loc 1 733 0
 3164 019c 6091 0000 		lds r22,Ipid
 3165 01a0 7091 0000 		lds r23,Ipid+1
 3166 01a4 8091 0000 		lds r24,Ipid+2
 3167 01a8 9091 0000 		lds r25,Ipid+3
 3168 01ac 2091 0000 		lds r18,Ts
 3169 01b0 3091 0000 		lds r19,Ts+1
 3170 01b4 4091 0000 		lds r20,Ts+2
 3171 01b8 5091 0000 		lds r21,Ts+3
 3172 01bc 0E94 0000 		call __subsf3
 3173               	.LVL293:
 3174 01c0 9B01      		movw r18,r22
 3175 01c2 AC01      		movw r20,r24
 3176 01c4 E12C      		mov r14,__zero_reg__
 3177 01c6 F12C      		mov r15,__zero_reg__
 3178 01c8 00EC      		ldi r16,lo8(-64)
 3179 01ca 10E4      		ldi r17,lo8(64)
 3180 01cc 60E0      		ldi r22,0
 3181 01ce 70E0      		ldi r23,0
 3182 01d0 80EC      		ldi r24,lo8(-64)
 3183 01d2 90EC      		ldi r25,lo8(-64)
 3184 01d4 0E94 0000 		call check_rangef
 3185               	.LVL294:
 3186 01d8 6093 0000 		sts Ipid,r22
 3187 01dc 7093 0000 		sts Ipid+1,r23
 3188 01e0 8093 0000 		sts Ipid+2,r24
 3189 01e4 9093 0000 		sts Ipid+3,r25
 734:main.c        **** 
 735:main.c        ****     wdt_reset();
 3190               		.loc 1 735 0
 3191               	/* #APP */
 3192               	 ;  735 "main.c" 1
 3193 01e8 A895      		wdr
 3194               	 ;  0 "" 2
 706:main.c        **** 
 3195               		.loc 1 706 0
 3196               	/* #NOAPP */
 3197 01ea C0E0      		ldi r28,0
 3198               	.LBB140:
 3199               	.LBB141:
 275:main.c        ****     return tmp;
 3200               		.loc 1 275 0
 3201 01ec 0FE0      		ldi r16,lo8(15)
 3202 01ee 10E0      		ldi r17,0
 3203               	.LBE141:
 3204               	.LBE140:
 3205               	.LBB143:
 736:main.c        ****     while (1) {
 737:main.c        **** //	if (get_input(IN_ACC)) { //ACC on
 738:main.c        **** 	if (1) { //ACC on
 739:main.c        **** 
 740:main.c        **** 	    if (smode == smode_hi_mode) {	//HI_MODE
 741:main.c        **** 		time_cnt = 0;
 742:main.c        **** 		tmp = 10;
 743:main.c        **** 		if (get_input(IN_BTN_HI_MODE)) { // не нажата
 744:main.c        **** 		    recycleSwitch(); //recycle mode on
 745:main.c        **** 		    hiAirSwitch(); // обдув на лобовое
 746:main.c        **** 		    smode = smode_hi_mode_work;
 747:main.c        **** 		}
 748:main.c        **** 
 749:main.c        **** 		set_temp(100, 1);
 750:main.c        **** 		set_vent_seg(tmp, 1);
 751:main.c        **** 
 752:main.c        **** 		Disp_Num_Seg(NUM0_SEG, 'H', 0);
 753:main.c        **** 		Disp_Num_Seg(NUM1_SEG, 'I', 0);
 754:main.c        **** 
 755:main.c        **** 	    } else if (smode == smode_hi_mode_work) {		//HI_MODE WORK
 756:main.c        **** 		//if (time_cnt > 2)
 757:main.c        **** 		{
 758:main.c        **** 		    if (time_cnt > HI_HOT_TMO_S || !get_input(IN_BTN_HI_MODE) || !get_input(OUT_BTN_PREF_MODE)) {
 759:main.c        **** 			smode = 0;
 760:main.c        **** 			time_cnt = 0;
 761:main.c        **** 			recycleSwitch(); //recycle mode off
 762:main.c        **** 			if (get_input(IN_BTN_HI_MODE)) {
 763:main.c        **** 			    prefAirSwitch(); // переключаем в любимый режим обдува
 764:main.c        **** 			}
 765:main.c        **** 		    }
 766:main.c        **** 		}
 767:main.c        **** 
 768:main.c        **** 		if (vent_enc) {
 769:main.c        **** 		    tmp = check_range(0, tmp + vent_enc, VENT_SEG);
 770:main.c        **** 		    time_cnt = 0;
 771:main.c        **** 		    vent_enc = 0;
 772:main.c        **** 		}
 773:main.c        **** 
 774:main.c        **** 		set_temp(100, 1);
 775:main.c        **** 		set_vent_seg(tmp, 1);
 776:main.c        **** 
 777:main.c        **** 		//Disp_Num_Seg(NUM0_SEG, 'H', 0);
 778:main.c        **** 		//Disp_Num_Seg(NUM1_SEG, 'I', 0);
 779:main.c        **** 		Disp_Bars(tmp);
 780:main.c        **** 	    } else if (smode) {		//Setup mode
 781:main.c        **** 
 782:main.c        **** 		if (time_cnt > SETUP_TMO_S) {
 783:main.c        **** 		    smode = 0;
 784:main.c        **** 		    time_cnt = 0;
 785:main.c        **** 		    disp_num = vars.setup_temp;
 786:main.c        **** 		    //cbtn = 0;
 787:main.c        **** 		    continue;
 788:main.c        **** 		}
 789:main.c        **** 
 790:main.c        **** 		if (vent_enc) { // переключаем пункты настройки
 791:main.c        **** 		    smode = check_range(1, smode + vent_enc, smode_SETUP_LAST - 1);
 792:main.c        **** 		    time_cnt = 0;
 793:main.c        **** 		    vent_enc = 0;
 794:main.c        **** 		    disp_num = smode - 1;
 795:main.c        **** 		    tmp = 'c';
 796:main.c        **** 		}
 797:main.c        **** 
 798:main.c        **** 		int8_t lf = 0;
 799:main.c        **** 		if (time_cnt > 0) {
 800:main.c        **** 		    lf = 1;
 801:main.c        **** 		}
 802:main.c        **** 
 803:main.c        **** 		if (temp_enc) { //изменение параметра
 804:main.c        **** 		    lf = 1;
 805:main.c        **** 		    time_cnt = 0;
 806:main.c        **** 		}
 807:main.c        **** 
 808:main.c        **** 		if (lf) {
 809:main.c        **** 		    tmp = 0;
 810:main.c        **** 		    switch (smode) {
 811:main.c        **** 		    case smode_manual: // в ручной режим
 812:main.c        **** 			tmp = 'r';
 813:main.c        **** 			vars.wmode = check_range(0, vars.wmode + temp_enc, 1);
 814:main.c        **** 			if (vars.wmode == wmode_auto) {
 815:main.c        **** 			    disp_num = 'A';
 816:main.c        **** 			    set_vent_seg(1, 1);
 817:main.c        **** 			    set_temp(0, 1);
 818:main.c        **** 			} else {
 819:main.c        **** 			    disp_num = 'P';
 820:main.c        **** 			    //set_vent_seg(vars.vent_nom_seg, 1);
 821:main.c        **** 			    //set_temp(seg2Prc(TEMP_SEG, vars.temp_seg), 1);
 822:main.c        **** 			}
 823:main.c        **** 			break;
 824:main.c        **** 		    case smode_auto_defrost: // авто подогрев лобового при включен
 825:main.c        **** 			tmp = 'H';
 826:main.c        **** 			vars.auto_defrost = check_range(0, vars.auto_defrost + temp_enc, 5);
 827:main.c        **** 			disp_num = vars.auto_defrost;
 828:main.c        **** 			break;
 829:main.c        **** 		    case smode_load_def: // загрузить данные по умолчанию
 830:main.c        **** 			tmp = 'L';
 831:main.c        **** 			disp_num = '?';
 832:main.c        **** 			if (!get_input(IN_FROST_BTN)) { // press setup mode
 833:main.c        **** 			    set_def_vals();
 834:main.c        **** 			    disp_num = smode - 1;
 835:main.c        **** 			    tmp = 'c';
 836:main.c        **** 			    time_cnt = 0;
 837:main.c        **** 			}
 838:main.c        **** 			break;
 839:main.c        **** 		    case smode_cnd_frost: //температура обмерзания кондиционера
 840:main.c        **** 			tmp = 'C';
 841:main.c        **** 			vars.const_cnd_frost_t = check_range(0, vars.const_cnd_frost_t + temp_enc, 9);
 842:main.c        **** 			disp_num = vars.const_cnd_frost_t;
 843:main.c        **** 			break;
 844:main.c        **** 		    case smode_seg_delay: // пропуск изменений заслонки
 845:main.c        **** 			tmp = 'd';
 846:main.c        **** 			vars.temp_seg_delay = check_range(0, vars.temp_seg_delay + temp_enc, 5);
 847:main.c        **** 			disp_num = vars.temp_seg_delay;
 848:main.c        **** 			break;
 849:main.c        **** 		    case smode_vent_kfc: //кфц отклонения вентилятора на изменен
 850:main.c        **** 			tmp = 'P';
 851:main.c        **** 			vars.vent_var_kfc = check_range(1, vars.vent_var_kfc + temp_enc, 9);
 852:main.c        **** 			disp_num = vars.vent_var_kfc;
 853:main.c        **** 			break;
 854:main.c        **** 		    case smode_pid_P_kfc: //П кфц
 855:main.c        **** 			vars.pid_P_kfc = check_range(1, vars.pid_P_kfc + temp_enc, 50);
 856:main.c        **** 			disp_num = vars.pid_P_kfc;
 857:main.c        **** 			break;
 858:main.c        **** 		    case smode_disp_T_isp: //просмотр датчиков
 859:main.c        **** 			disp_num = calcTemp(IN_ADC_T_FROST);
 860:main.c        **** 			break;
 861:main.c        **** 		    case smode_disp_T_salon:
 862:main.c        **** 			disp_num = calcTemp(IN_ADC_T_SALON);
 863:main.c        **** 			break;
 864:main.c        **** 		    }
 865:main.c        **** 		    temp_enc = 0;
 866:main.c        **** 		}
 867:main.c        **** 
 868:main.c        **** 		if (tmp) {
 869:main.c        **** 		    Disp_Num_Seg(NUM0_SEG, tmp, 0);
 870:main.c        **** 		    Disp_Num_Seg(NUM1_SEG, disp_num, 0);
 871:main.c        **** 		} else {
 872:main.c        **** 		    Disp_Num(disp_num, 0);
 873:main.c        **** 		}
 874:main.c        **** 		Disp_Bars(smode);
 875:main.c        **** 
 876:main.c        **** 	    } else { // work mode
 877:main.c        **** 
 878:main.c        **** 		if (vars.wmode == wmode_auto) {
 879:main.c        **** 		    switch (time_cnt) {
 880:main.c        **** 		    case 0:
 881:main.c        **** 			setup_display();
 882:main.c        **** 			time_cnt++;
 883:main.c        **** 			break;
 884:main.c        **** 		    case 1 ... 6:
 885:main.c        **** 			break;
 886:main.c        **** 		    case 7:
 887:main.c        **** 			Ti = calcTemp(IN_ADC_T_FROST);
 3206               		.loc 1 887 0
 3207 01f0 812C      		mov r8,__zero_reg__
 3208 01f2 912C      		mov r9,__zero_reg__
 3209 01f4 90E5      		ldi r25,lo8(80)
 3210 01f6 A92E      		mov r10,r25
 3211 01f8 91EC      		ldi r25,lo8(-63)
 3212 01fa B92E      		mov r11,r25
 3213               	.LVL295:
 3214               	.L150:
 3215               	.LBE143:
 878:main.c        **** 		    switch (time_cnt) {
 3216               		.loc 1 878 0
 3217 01fc 8091 0000 		lds r24,vars
 3218 0200 8111      		cpse r24,__zero_reg__
 3219 0202 00C0      		rjmp .L134
 879:main.c        **** 		    case 0:
 3220               		.loc 1 879 0
 3221 0204 8C2F      		mov r24,r28
 3222 0206 90E0      		ldi r25,0
 3223 0208 8031      		cpi r24,16
 3224 020a 9105      		cpc r25,__zero_reg__
 3225 020c 00F0      		brlo .+2
 3226 020e 00C0      		rjmp .L135
 3227 0210 FC01      		movw r30,r24
 3228 0212 E050      		subi r30,lo8(-(gs(.L137)))
 3229 0214 F040      		sbci r31,hi8(-(gs(.L137)))
 3230 0216 0C94 0000 		jmp __tablejump2__
 3231               	.LVL296:
 3232               		.section	.progmem.gcc_sw_table,"a",@progbits
 3233               		.p2align	1
 3234               	.L137:
 3235 0000 0000      		.word gs(.L136)
 3236 0002 0000      		.word gs(.L138)
 3237 0004 0000      		.word gs(.L138)
 3238 0006 0000      		.word gs(.L138)
 3239 0008 0000      		.word gs(.L138)
 3240 000a 0000      		.word gs(.L138)
 3241 000c 0000      		.word gs(.L138)
 3242 000e 0000      		.word gs(.L139)
 3243 0010 0000      		.word gs(.L138)
 3244 0012 0000      		.word gs(.L140)
 3245 0014 0000      		.word gs(.L138)
 3246 0016 0000      		.word gs(.L141)
 3247 0018 0000      		.word gs(.L138)
 3248 001a 0000      		.word gs(.L142)
 3249 001c 0000      		.word gs(.L138)
 3250 001e 0000      		.word gs(.L143)
 3251               		.section	.text.startup
 3252               	.L136:
 3253               	.LBB147:
 881:main.c        **** 			time_cnt++;
 3254               		.loc 1 881 0
 3255 021a 0E94 0000 		call setup_display
 3256               	.LVL297:
 882:main.c        **** 			break;
 3257               		.loc 1 882 0
 3258 021e C1E0      		ldi r28,lo8(1)
 883:main.c        **** 		    case 1 ... 6:
 3259               		.loc 1 883 0
 3260 0220 00C0      		rjmp .L138
 3261               	.LVL298:
 3262               	.L139:
 3263               		.loc 1 887 0
 3264 0222 8092 0000 		sts Ti,r8
 3265 0226 9092 0000 		sts Ti+1,r9
 3266 022a A092 0000 		sts Ti+2,r10
 3267 022e B092 0000 		sts Ti+3,r11
 3268               	.LVL299:
 888:main.c        **** 			time_cnt = 8;
 3269               		.loc 1 888 0
 3270 0232 C8E0      		ldi r28,lo8(8)
 889:main.c        **** 			break;
 3271               		.loc 1 889 0
 3272 0234 00C0      		rjmp .L138
 3273               	.LVL300:
 3274               	.L140:
 3275               	.LBB144:
 3276               	.LBB145:
 3277               	.LBB146:
 402:main.c        ****     }
 3278               		.loc 1 402 0
 3279 0236 6091 0000 		lds r22,Ts
 3280 023a 7091 0000 		lds r23,Ts+1
 3281 023e 8091 0000 		lds r24,Ts+2
 3282 0242 9091 0000 		lds r25,Ts+3
 3283 0246 2DEC      		ldi r18,lo8(-51)
 3284 0248 3CEC      		ldi r19,lo8(-52)
 3285 024a 4CEC      		ldi r20,lo8(-52)
 3286 024c 5DE3      		ldi r21,lo8(61)
 3287 024e 0E94 0000 		call __addsf3
 3288               	.LVL301:
 3289               	.LBE146:
 3290               	.LBE145:
 3291               	.LBE144:
 890:main.c        **** 		    case 8:
 891:main.c        **** 			break;
 892:main.c        **** 		    case 9:
 893:main.c        **** 			Ts = calcTemp(IN_ADC_T_SALON);
 3292               		.loc 1 893 0
 3293 0252 6093 0000 		sts Ts,r22
 3294 0256 7093 0000 		sts Ts+1,r23
 3295 025a 8093 0000 		sts Ts+2,r24
 3296 025e 9093 0000 		sts Ts+3,r25
 894:main.c        **** 			float t = Ts + 0.4;
 3297               		.loc 1 894 0
 3298 0262 6091 0000 		lds r22,Ts
 3299 0266 7091 0000 		lds r23,Ts+1
 3300 026a 8091 0000 		lds r24,Ts+2
 3301 026e 9091 0000 		lds r25,Ts+3
 3302               	.LVL302:
 895:main.c        **** 			disp_num = t;
 3303               		.loc 1 895 0
 3304 0272 2DEC      		ldi r18,lo8(-51)
 3305 0274 3CEC      		ldi r19,lo8(-52)
 3306 0276 4CEC      		ldi r20,lo8(-52)
 3307 0278 5EE3      		ldi r21,lo8(62)
 3308 027a 0E94 0000 		call __addsf3
 3309               	.LVL303:
 3310 027e 0E94 0000 		call __fixsfsi
 3311               	.LVL304:
 3312 0282 D62F      		mov r29,r22
 3313               	.LVL305:
 896:main.c        **** 			time_cnt++;
 3314               		.loc 1 896 0
 3315 0284 CAE0      		ldi r28,lo8(10)
 897:main.c        **** 			break;
 3316               		.loc 1 897 0
 3317 0286 00C0      		rjmp .L138
 3318               	.LVL306:
 3319               	.L141:
 898:main.c        **** 		    case 10:
 899:main.c        **** 			break;
 900:main.c        **** 		    case 11: //calc
 901:main.c        **** 			calcVal();
 3320               		.loc 1 901 0
 3321 0288 0E94 0000 		call calcVal
 3322               	.LVL307:
 902:main.c        **** 			time_cnt++;
 3323               		.loc 1 902 0
 3324 028c CCE0      		ldi r28,lo8(12)
 903:main.c        **** 			break;
 3325               		.loc 1 903 0
 3326 028e 00C0      		rjmp .L138
 3327               	.LVL308:
 3328               	.L142:
 904:main.c        **** 		    case 12:
 905:main.c        **** 			break;
 906:main.c        **** 		    case 13:
 907:main.c        **** 			set_temp(temp_out_prc, 1);
 3329               		.loc 1 907 0
 3330 0290 8091 0000 		lds r24,temp_out_prc
 3331 0294 61E0      		ldi r22,lo8(1)
 3332 0296 0E94 0000 		call set_temp
 3333               	.LVL309:
 908:main.c        **** 			time_cnt++;
 3334               		.loc 1 908 0
 3335 029a CEE0      		ldi r28,lo8(14)
 909:main.c        **** 			break;
 3336               		.loc 1 909 0
 3337 029c 00C0      		rjmp .L138
 3338               	.LVL310:
 3339               	.L143:
 910:main.c        **** 		    case 14:
 911:main.c        **** 			break;
 912:main.c        **** 		    case 15:
 913:main.c        **** 			set_vent_prc(vent_add_prc, 1);
 3340               		.loc 1 913 0
 3341 029e 8091 0000 		lds r24,vent_add_prc
 3342 02a2 61E0      		ldi r22,lo8(1)
 3343 02a4 0E94 0000 		call set_vent_prc
 3344               	.LVL311:
 914:main.c        **** 			disp_bar = vent_seg_cur;
 3345               		.loc 1 914 0
 3346 02a8 D090 0000 		lds r13,vent_seg_cur
 3347               	.LVL312:
 915:main.c        **** 			SET_FLAG(f_num_dot)
 3348               		.loc 1 915 0
 3349 02ac 8091 0000 		lds r24,flags
 3350 02b0 8860      		ori r24,lo8(8)
 3351 02b2 8093 0000 		sts flags,r24
 3352               	.LVL313:
 916:main.c        **** 			time_cnt++;
 3353               		.loc 1 916 0
 3354 02b6 C0E1      		ldi r28,lo8(16)
 917:main.c        **** 			break;
 3355               		.loc 1 917 0
 3356 02b8 00C0      		rjmp .L138
 3357               	.LVL314:
 3358               	.L135:
 918:main.c        **** 		    default: //  цикл
 919:main.c        **** 			time_cnt = 0;
 920:main.c        **** 			CLR_FLAG(f_num_dot)
 3359               		.loc 1 920 0
 3360 02ba 8091 0000 		lds r24,flags
 3361 02be 877F      		andi r24,lo8(-9)
 3362 02c0 8093 0000 		sts flags,r24
 919:main.c        **** 			CLR_FLAG(f_num_dot)
 3363               		.loc 1 919 0
 3364 02c4 C0E0      		ldi r28,0
 3365               	.LVL315:
 3366               	.L138:
 3367               	.LBE147:
 921:main.c        **** 		    }
 922:main.c        **** 
 923:main.c        **** 		    if (vent_enc) {
 3368               		.loc 1 923 0
 3369 02c6 8091 0000 		lds r24,vent_enc
 3370 02ca 8823      		tst r24
 3371 02cc 01F0      		breq .L144
 924:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEG + 2);
 3372               		.loc 1 924 0
 3373 02ce 8091 0000 		lds r24,vars+2
 3374 02d2 6091 0000 		lds r22,vent_enc
 3375 02d6 062E      		mov __tmp_reg__,r22
 3376 02d8 000C      		lsl r0
 3377 02da 770B      		sbc r23,r23
 3378 02dc 680F      		add r22,r24
 3379 02de 711D      		adc r23,__zero_reg__
 3380 02e0 87FD      		sbrc r24,7
 3381 02e2 7A95      		dec r23
 3382 02e4 4AE0      		ldi r20,lo8(10)
 3383 02e6 50E0      		ldi r21,0
 3384 02e8 80E0      		ldi r24,0
 3385 02ea 90E0      		ldi r25,0
 3386 02ec 0E94 0000 		call check_range
 3387               	.LVL316:
 3388 02f0 8093 0000 		sts vars+2,r24
 925:main.c        **** 			disp_bar = vars.vent_nom_seg;
 3389               		.loc 1 925 0
 3390 02f4 D090 0000 		lds r13,vars+2
 3391               	.LVL317:
 926:main.c        **** 			time_cnt = 10;
 927:main.c        **** 			vent_enc = 0;
 3392               		.loc 1 927 0
 3393 02f8 1092 0000 		sts vent_enc,__zero_reg__
 926:main.c        **** 			time_cnt = 10;
 3394               		.loc 1 926 0
 3395 02fc CAE0      		ldi r28,lo8(10)
 3396               	.LVL318:
 3397               	.L144:
 928:main.c        **** 		    }
 929:main.c        **** 
 930:main.c        **** 		    if (temp_enc) {
 3398               		.loc 1 930 0
 3399 02fe 8091 0000 		lds r24,temp_enc
 3400 0302 8823      		tst r24
 3401 0304 01F0      		breq .L145
 931:main.c        **** 			vars.setup_temp = check_range(15, vars.setup_temp + temp_enc, 30);
 3402               		.loc 1 931 0
 3403 0306 8091 0000 		lds r24,vars+1
 3404 030a 6091 0000 		lds r22,temp_enc
 3405 030e 062E      		mov __tmp_reg__,r22
 3406 0310 000C      		lsl r0
 3407 0312 770B      		sbc r23,r23
 3408 0314 680F      		add r22,r24
 3409 0316 711D      		adc r23,__zero_reg__
 3410 0318 87FD      		sbrc r24,7
 3411 031a 7A95      		dec r23
 3412 031c 4EE1      		ldi r20,lo8(30)
 3413 031e 50E0      		ldi r21,0
 3414 0320 8FE0      		ldi r24,lo8(15)
 3415 0322 90E0      		ldi r25,0
 3416 0324 0E94 0000 		call check_range
 3417               	.LVL319:
 3418 0328 8093 0000 		sts vars+1,r24
 932:main.c        **** 			disp_num = vars.setup_temp;
 3419               		.loc 1 932 0
 3420 032c D091 0000 		lds r29,vars+1
 3421               	.LVL320:
 933:main.c        **** 			time_cnt = 0;
 934:main.c        **** 			temp_enc = 0;
 3422               		.loc 1 934 0
 3423 0330 1092 0000 		sts temp_enc,__zero_reg__
 933:main.c        **** 			time_cnt = 0;
 3424               		.loc 1 933 0
 3425 0334 C0E0      		ldi r28,0
 3426 0336 00C0      		rjmp .L145
 3427               	.LVL321:
 3428               	.L134:
 935:main.c        **** 		    }
 936:main.c        **** 
 937:main.c        **** 		} else { // manual
 938:main.c        **** 
 939:main.c        **** 		    if (time_cnt > 10) {
 3429               		.loc 1 939 0
 3430 0338 CB30      		cpi r28,lo8(11)
 3431 033a 00F0      		brlo .L146
 940:main.c        **** 			setup_display();
 3432               		.loc 1 940 0
 3433 033c 0E94 0000 		call setup_display
 3434               	.LVL322:
 941:main.c        **** 			time_cnt = 0;
 3435               		.loc 1 941 0
 3436 0340 C0E0      		ldi r28,0
 3437               	.LVL323:
 3438               	.L146:
 942:main.c        **** 		    }
 943:main.c        **** /*
 944:main.c        **** 		    if (vent_enc) {
 945:main.c        **** 			vars.vent_nom_seg = check_range(0, vars.vent_nom_seg + vent_enc, VENT_SEG);
 946:main.c        **** 			vent_enc = 0;
 947:main.c        **** 		    }
 948:main.c        **** 
 949:main.c        **** 		    if (temp_enc) {
 950:main.c        **** 			vars.temp_seg = check_range(0, vars.temp_seg + temp_enc, TEMP_SEG);
 951:main.c        **** 			temp_enc = 0;
 952:main.c        **** 		    }
 953:main.c        **** */
 954:main.c        **** 		    disp_bar = vars.vent_nom_seg;
 3439               		.loc 1 954 0
 3440 0342 D090 0000 		lds r13,vars+2
 3441               	.LVL324:
 955:main.c        **** 		    disp_num = seg2Prc(TEMP_SEG, vars.temp_seg);
 3442               		.loc 1 955 0
 3443 0346 8091 0000 		lds r24,vars+3
 3444               	.LVL325:
 3445               	.LBB148:
 3446               	.LBB142:
 275:main.c        ****     return tmp;
 3447               		.loc 1 275 0
 3448 034a 24E6      		ldi r18,lo8(100)
 3449 034c 829F      		mul r24,r18
 3450 034e C001      		movw r24,r0
 3451 0350 1124      		clr __zero_reg__
 3452               	.LVL326:
 3453 0352 B801      		movw r22,r16
 3454 0354 0E94 0000 		call __divmodhi4
 3455 0358 F62E      		mov r15,r22
 3456               	.LVL327:
 3457               	.LBE142:
 3458               	.LBE148:
 3459               		.loc 1 955 0
 3460 035a D62F      		mov r29,r22
 3461               	.LVL328:
 956:main.c        **** 		    set_vent_seg(vars.vent_nom_seg, 0);
 3462               		.loc 1 956 0
 3463 035c 8091 0000 		lds r24,vars+2
 3464 0360 60E0      		ldi r22,0
 3465 0362 0E94 0000 		call set_vent_seg
 3466               	.LVL329:
 957:main.c        **** 		    set_temp(disp_num, 0);
 3467               		.loc 1 957 0
 3468 0366 60E0      		ldi r22,0
 3469 0368 8F2D      		mov r24,r15
 3470 036a 0E94 0000 		call set_temp
 3471               	.LVL330:
 958:main.c        **** 		    switch_cond(1);
 3472               		.loc 1 958 0
 3473 036e 81E0      		ldi r24,lo8(1)
 3474 0370 0E94 0000 		call switch_cond
 3475               	.LVL331:
 3476               	.L145:
 959:main.c        **** 		}
 960:main.c        **** // логика
 961:main.c        **** // кнопки
 962:main.c        **** /*
 963:main.c        **** 		if (!get_input(IN_BTN_HI_MODE)) { // to hi hot mode
 964:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 965:main.c        **** 			smode = smode_hi_mode;
 966:main.c        **** 		    }
 967:main.c        **** 		    time_cnt = 0;
 968:main.c        **** 		} else if (!get_input(IN_FROST_BTN)) { // to setup mode
 969:main.c        **** 		    SET_FLAG(f_cond_btn_press);
 970:main.c        **** 		    if (delay_btn_check(&bdelay)) {
 971:main.c        **** 			smode = 1;
 972:main.c        **** 			disp_num = 0;
 973:main.c        **** 			tmp = 'c';
 974:main.c        **** 			CLR_FLAG(f_cond_btn_press);
 975:main.c        **** 			vent_enc = 0;
 976:main.c        **** 			temp_enc = 0;
 977:main.c        **** 		    }
 978:main.c        **** 		    time_cnt = 0;
 979:main.c        **** 		} else {
 980:main.c        **** 		    if (TST_FLAG(f_cond_btn_press)) {
 981:main.c        **** 			if (vars.cond_enabled) {
 982:main.c        **** 			    vars.cond_enabled = 0;
 983:main.c        **** 			} else {
 984:main.c        **** 			    vars.cond_enabled = 1;
 985:main.c        **** 			}
 986:main.c        **** 			CLR_FLAG(f_cond_btn_press);
 987:main.c        **** 		    }
 988:main.c        **** 		    bdelay = 0;
 989:main.c        **** 		}
 990:main.c        **** */
 991:main.c        **** //дисплей
 992:main.c        **** 		Disp_Num(disp_num, TST_FLAG(f_num_dot));
 3477               		.loc 1 992 0
 3478 0374 6091 0000 		lds r22,flags
 3479 0378 6870      		andi r22,lo8(8)
 3480 037a 8D2F      		mov r24,r29
 3481 037c 0E94 0000 		call Disp_Num
 3482               	.LVL332:
 993:main.c        **** 		Disp_Bars(disp_bar);
 3483               		.loc 1 993 0
 3484 0380 8D2D      		mov r24,r13
 3485 0382 0E94 0000 		call Disp_Bars
 3486               	.LVL333:
 994:main.c        **** 	    }
 995:main.c        **** 
 996:main.c        **** 	    if (TST_FLAG(f_e1sec)) {
 3487               		.loc 1 996 0
 3488 0386 8091 0000 		lds r24,flags
 3489 038a 80FF      		sbrs r24,0
 3490 038c 00C0      		rjmp .L147
 997:main.c        **** 		time_cnt++;
 3491               		.loc 1 997 0
 3492 038e CF5F      		subi r28,lo8(-(1))
 3493               	.LVL334:
 998:main.c        **** 		if (bdelay) {
 999:main.c        **** 		    bdelay++;
1000:main.c        **** 		}
1001:main.c        **** 		CLR_FLAG(f_e1sec);
 3494               		.loc 1 1001 0
 3495 0390 8091 0000 		lds r24,flags
 3496 0394 8E7F      		andi r24,lo8(-2)
 3497 0396 8093 0000 		sts flags,r24
1002:main.c        **** 
1003:main.c        **** 		if (TST_FLAG(f_cond_ind_flash)) {
 3498               		.loc 1 1003 0
 3499 039a 8091 0000 		lds r24,flags
 3500 039e 85FD      		sbrc r24,5
1004:main.c        **** 		    pin_low(OUT_FROST_IND);
 3501               		.loc 1 1004 0
 3502 03a0 4198      		cbi 0x8,1
 3503               	.L147:
1005:main.c        **** 		}
1006:main.c        **** 	    }
1007:main.c        **** 
1008:main.c        **** 	} else { //poweroff prepare
1009:main.c        **** 	    time_cnt = 0;
1010:main.c        **** 	    wdt_reset();
1011:main.c        **** 	    myupdate_eeprom();
1012:main.c        **** 	    for (uint8_t i = 0; i < VENT_SEG; i++) {
1013:main.c        **** 		switch_vent(0);
1014:main.c        **** 	    }
1015:main.c        **** 	    for (uint8_t i = 0; i < TEMP_SEG; i++) {
1016:main.c        **** 		switch_temp(0);
1017:main.c        **** 	    }
1018:main.c        **** 	    Send_7219(0, 0);
1019:main.c        **** 	    Send_7219(0x0C, 0); //выключим индикатор
1020:main.c        **** 	    delay_ms(10);
1021:main.c        **** 
1022:main.c        **** 	    wdt_enable(WDTO_15MS); // reboot
1023:main.c        **** 	    while (1) {
1024:main.c        **** 		delay_s(1);
1025:main.c        **** 	    }
1026:main.c        **** 	}
1027:main.c        **** 
1028:main.c        **** 	delay_ms(100);
 3504               		.loc 1 1028 0
 3505 03a2 84E6      		ldi r24,lo8(100)
 3506 03a4 90E0      		ldi r25,0
 3507 03a6 0E94 0000 		call delay_ms
 3508               	.LVL335:
1029:main.c        **** 
1030:main.c        **** 	if (vars.cond_enabled) {
 3509               		.loc 1 1030 0
 3510 03aa 8091 0000 		lds r24,vars+9
 3511 03ae 8823      		tst r24
 3512 03b0 01F0      		breq .L148
1031:main.c        **** 	    pin_high(OUT_FROST_IND);
 3513               		.loc 1 1031 0
 3514 03b2 419A      		sbi 0x8,1
 3515 03b4 00C0      		rjmp .L149
 3516               	.L148:
1032:main.c        **** 	} else {
1033:main.c        **** 	    pin_low(OUT_FROST_IND);
 3517               		.loc 1 1033 0
 3518 03b6 4198      		cbi 0x8,1
1034:main.c        **** 	    switch_cond(0);
 3519               		.loc 1 1034 0
 3520 03b8 80E0      		ldi r24,0
 3521 03ba 0E94 0000 		call switch_cond
 3522               	.LVL336:
 3523               	.L149:
1035:main.c        **** 	}
1036:main.c        **** 
1037:main.c        **** 	wdt_reset();
 3524               		.loc 1 1037 0
 3525               	/* #APP */
 3526               	 ;  1037 "main.c" 1
 3527 03be A895      		wdr
 3528               	 ;  0 "" 2
 3529               	/* #NOAPP */
 3530 03c0 00C0      		rjmp .L150
 3531               		.cfi_endproc
 3532               	.LFE41:
 3534               		.comm	vars,11,1
 3535               	.global	Ts
 3536               		.section .bss
 3539               	Ts:
 3540 0000 0000 0000 		.zero	4
 3541               	.global	Ti
 3544               	Ti:
 3545 0004 0000 0000 		.zero	4
 3546               		.comm	flags,1,1
 3547               		.comm	temp_out_delay,1,1
 3548               		.comm	temp_out_prc,1,1
 3549               		.comm	vent_add_prc,1,1
 3550               		.comm	last_delta,4,1
 3551               		.comm	Ipid,4,1
 3552               		.comm	temp_enc,1,1
 3553               		.comm	vent_enc,1,1
 3554               		.comm	temp_seg_cur,1,1
 3555               		.comm	vent_seg_cur,1,1
 3556               		.text
 3557               	.Letext0:
 3558               		.file 4 "/usr/lib/avr/include/stdint.h"
 3559               		.file 5 "vars.h"
 3560               		.file 6 "usart.h"
 3561               		.file 7 "/usr/lib/avr/include/stdio.h"
 3562               		.file 8 "disp.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccsCQ9wu.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccsCQ9wu.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccsCQ9wu.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccsCQ9wu.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccsCQ9wu.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccsCQ9wu.s:18     .text:0000000000000000 int_to_uart
     /tmp/ccsCQ9wu.s:115    .text:0000000000000074 float_to_uart
     /tmp/ccsCQ9wu.s:152    .text:000000000000008c uart_nl
     /tmp/ccsCQ9wu.s:173    .text:0000000000000098 __vector_13
                            *COM*:0000000000000001 flags
     /tmp/ccsCQ9wu.s:235    .text:00000000000000ce test_vent_enc
                            *COM*:0000000000000001 vent_enc
     /tmp/ccsCQ9wu.s:282    .text:00000000000000f8 __vector_3
     /tmp/ccsCQ9wu.s:389    .text:0000000000000146 __vector_5
     /tmp/ccsCQ9wu.s:496    .text:0000000000000194 test_temp_enc
                            *COM*:0000000000000001 temp_enc
     /tmp/ccsCQ9wu.s:561    .text:00000000000001cc __vector_1
     /tmp/ccsCQ9wu.s:668    .text:000000000000021a __vector_2
     /tmp/ccsCQ9wu.s:775    .text:0000000000000268 set_def_vals
                            *COM*:000000000000000b vars
     /tmp/ccsCQ9wu.s:820    .text:0000000000000292 myread_eeprom
     /tmp/ccsCQ9wu.s:861    .text:00000000000002b6 myupdate_eeprom
     /tmp/ccsCQ9wu.s:904    .text:00000000000002e0 switch_temp
     /tmp/ccsCQ9wu.s:1022   .text:000000000000032a switch_vent
     /tmp/ccsCQ9wu.s:1140   .text:0000000000000374 prc2Seg
     /tmp/ccsCQ9wu.s:1189   .text:00000000000003a6 seg2Prc
     /tmp/ccsCQ9wu.s:1218   .text:00000000000003bc set_temp
                            *COM*:0000000000000001 temp_seg_cur
     /tmp/ccsCQ9wu.s:1429   .text:0000000000000484 switch_cond
                            *COM*:0000000000000001 vent_seg_cur
     /tmp/ccsCQ9wu.s:1484   .text:00000000000004bc set_vent_seg
     /tmp/ccsCQ9wu.s:1683   .text:0000000000000592 set_vent_prc
     /tmp/ccsCQ9wu.s:1719   .text:00000000000005a6 calcTemp
     /tmp/ccsCQ9wu.s:3539   .bss:0000000000000000 Ts
     /tmp/ccsCQ9wu.s:1772   .text:00000000000005d2 calcCond
     /tmp/ccsCQ9wu.s:3544   .bss:0000000000000004 Ti
     /tmp/ccsCQ9wu.s:2010   .text:0000000000000764 calcVent
                            *COM*:0000000000000004 last_delta
                            *COM*:0000000000000001 vent_add_prc
     /tmp/ccsCQ9wu.s:2279   .text:00000000000008a8 calcVal
                            *COM*:0000000000000004 Ipid
                            *COM*:0000000000000001 temp_out_delay
                            *COM*:0000000000000001 temp_out_prc
     /tmp/ccsCQ9wu.s:2717   .text:0000000000000b7c recycleSwitch
     /tmp/ccsCQ9wu.s:2742   .text:0000000000000b8c prefAirSwitch
     /tmp/ccsCQ9wu.s:2767   .text:0000000000000b9c hiAirSwitch
     /tmp/ccsCQ9wu.s:2792   .text:0000000000000bac setup_pins
     /tmp/ccsCQ9wu.s:2834   .text:0000000000000bca setup_display
     /tmp/ccsCQ9wu.s:2883   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
USART_SendStr
snprintf
USART_PutChar
__fixsfsi
eeprom_read_buf
eeprom_read_byte1
eeprom_update_buf
eeprom_write_byte1
delay_ms
check_range
__divmodhi4
__addsf3
__floatsisf
__ltsf2
__floatunsisf
__mulsf3
check_rangef
__subsf3
__divsf3
__gtsf2
__fixunssfsi
Send_7219
ADC_Init
USART_Init
SPI_init
Clear_7219
Disp_Num
Disp_Bars
__tablejump2__
__do_copy_data
__do_clear_bss
